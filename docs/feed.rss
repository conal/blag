<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
  <title>Reasonably Polymorphic</title>
  <link>http://reasonablypolymorphic.com</link>
  <atom:link href="http://reasonablypolymorphic.com/feed.rss" rel="self" type="application/rss+xml" />
  <description>There will be math and Haskell and it will be in ya face.</description>
  <category>Life</category>
  <copyright>2018 Sandy Maguire</copyright>
  <pubDate>2021-10-16T12:06:00Z</pubDate>
  <language>en-us</language>
  <image>
      <url>http://reasonablypolymorphic.com/images/favicon.png</url>
    <title>Sandy Maguire</title>
    <link>http://reasonablypolymorphic.com</link>
  </image>
  <item>
      <title>Proving Equivalence of Polysemy Interpreters</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>http://reasonablypolymorphic.com/blog/proving-equivalence/index.html</link>
      <guid>http://reasonablypolymorphic.com/blog/proving-equivalence/index.html</guid>
      <pubDate>2021-10-16T12:06:00Z</pubDate>
      <content:encoded><![CDATA[
        <p>Let’s talk <a href="https://reasonablypolymorphic.com/blog/polysemy-check/">more</a> about <a href="https://github.com/polysemy-research/polysemy-check"><code>polysemy-check</code></a>. Last week we looked at how to do property-testing for a <code>polysemy</code> effects’ laws. Today, we’ll investigate how to show that two interpretations are equivalent.</p>
<p>To continue with last week’s example, let’s say we have an effect that corresponds to having a <code>Stack</code> that we can push and pop:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Stack</span> s m a <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>  <span class="dt">Push</span><span class="ot">      ::</span> s <span class="ot">-&gt;</span> <span class="dt">Stack</span> s m ()</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>  <span class="dt">Pop</span><span class="ot">       ::</span> <span class="dt">Stack</span> s m (<span class="dt">Maybe</span> s)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>  <span class="dt">RemoveAll</span><span class="ot"> ::</span> <span class="dt">Stack</span> s m ()</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>  <span class="dt">Size</span><span class="ot">      ::</span> <span class="dt">Stack</span> s m <span class="dt">Int</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a><span class="kw">deriving</span> <span class="kw">instance</span> <span class="dt">Show</span> s <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">Stack</span> s m a)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>deriveGenericK &#39;<span class="dt">&#39;Stack</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a>makeSem &#39;<span class="dt">&#39;Stack</span></span></code></pre></div>
<p>Since we’d like to prove the equivalence of two interpretations, we’ll need to first write two interpretations. But, to illustrate, we’re going simulate multiple interpreters via a single interpretation, parameterized by which bugs should be present in it.</p>
<p>purposes of brevity, we’ll write a single interpretation of <code>Stack s</code> in terms of <code>State [s]</code>, and then interpret <em>that</em> in two different ways. In essence, what we’re really testing here is the equivalence of two <code>State</code> interpretations, but it’s good enough for an example.</p>
<p>We’ll start with the bugs:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Bug</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">PushTwice</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">DontRemove</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>  <span class="kw">deriving</span> stock (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>, <span class="dt">Enum</span>, <span class="dt">Bounded</span>)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Arbitrary</span> <span class="dt">Bug</span> <span class="kw">where</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>  arbitrary <span class="ot">=</span> elements [<span class="fu">minBound</span><span class="op">..</span><span class="fu">maxBound</span>]</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a><span class="ot">hasBug ::</span> [<span class="dt">Bug</span>] <span class="ot">-&gt;</span> <span class="dt">Bug</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>hasBug <span class="ot">=</span> <span class="fu">flip</span> <span class="fu">elem</span></span></code></pre></div>
<p>The <code>PushTwice</code> bug, as you might expect, dispatched a <code>Push</code> command so that it pushes twice onto the stack. The <code>DontRemove</code> bug causes <code>RemoveAll</code> to be a no-op. Armed with our bugs, we can write a little interpreter for <code>Stack</code> that translates <code>Stack s</code> commands into <code>State [s]</code> commands, and then immediately runs the <code>State</code> effect:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>runStack</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a><span class="ot">    ::</span> [<span class="dt">Bug</span>]</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>    <span class="ot">-&gt;</span> <span class="dt">Sem</span> (<span class="dt">Stack</span> s &#39;<span class="op">:</span> r) a</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>    <span class="ot">-&gt;</span> <span class="dt">Sem</span> r ([s], a)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>runStack bugs <span class="ot">=</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>  (runState [] <span class="op">.</span>) <span class="op">$</span> reinterpret <span class="op">$</span> \<span class="kw">case</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>    <span class="dt">Push</span> s <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>      modify (s <span class="op">:</span>)</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>      when (hasBug bugs <span class="dt">PushTwice</span>) <span class="op">$</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a>        modify (s <span class="op">:</span>)</span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true"></a>    <span class="dt">Pop</span> <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true"></a>      r <span class="ot">&lt;-</span> gets listToMaybe</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true"></a>      modify (<span class="fu">drop</span> <span class="dv">1</span>)</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true"></a>      <span class="fu">pure</span> r</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true"></a></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true"></a>    <span class="dt">RemoveAll</span> <span class="ot">-&gt;</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true"></a>      unless (hasBug bugs <span class="dt">DontRemove</span>) <span class="op">$</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true"></a>        put []</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true"></a></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true"></a>    <span class="dt">Size</span> <span class="ot">-&gt;</span></span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true"></a>      gets <span class="fu">length</span></span></code></pre></div>
<p>For our efforts we are rewarded: <code>runState</code> gives rise to four interpreters for the price of one. We can now ask whether or not these interpreters are equivalent. Enter <code>propEquivalent</code>:</p>
<p>With these interpreters out of the way, it’s time to answer our original question: are <code>pureStack</code> and <code>ioStack</code> equivalent? Which is to say, do they get the same answer for every possible program? Enter <code>propEquivalent</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>prepropEquivalent</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="ot">    ::</span> <span class="kw">forall</span> effs r1 r2 f</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>     <span class="op">.</span> ( <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Show</span> a <span class="ot">=&gt;</span> <span class="dt">Show</span> (f a)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>       , <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="dt">Eq</span> (f a)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>       )</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>    <span class="ot">=&gt;</span> ( <span class="dt">Inject</span> effs r1</span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>       , <span class="dt">Inject</span> effs r2</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>       , <span class="dt">Arbitrary</span> (<span class="dt">Sem</span> effs <span class="dt">Int</span>)</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>       )</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>    <span class="ot">=&gt;</span> (<span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Sem</span> r1 a <span class="ot">-&gt;</span> <span class="dt">IO</span> (f a))</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a>    <span class="ot">-&gt;</span> (<span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Sem</span> r2 a <span class="ot">-&gt;</span> <span class="dt">IO</span> (f a))</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true"></a>    <span class="ot">-&gt;</span> <span class="dt">Property</span></span></code></pre></div>
<p>All of the functions in <code>polysemy-check</code> have fun type signatures like this one. But despite the preponderance of <code>forall</code>s, it’s not as terrible as you might think. The first ten lines here are just constraints. There are only two arguments to <code>prepropEquivalent</code>, and they are the two interpreters you’d like to test.</p>
<p>This type is crazy, and it will be beneficial to understand it. There are four type variables, three of which are effect rows. We can distinguish between them:</p>
<ul>
<li><code>effs</code>: The effect(s) you’re interested in testing. In our case, our interpreter handles <code>Stack s</code>, so we let <code>effs ~ Stack s</code>.</li>
<li><code>r1</code>: The effects handled by interpreter 1. Imagine we had an interpreter for <code>Stack s</code> that ran it via <code>IO</code> instead. In that case, <code>r1 ~ '[State s, Embed   IO]</code>.</li>
<li><code>r2</code> The effects handled by interpreter 2.</li>
</ul>
<p>The relationships that must between <code>effs</code>, <code>r1</code> and <code>r2</code> are <span class="math inline">\(effs \subset r1\)</span> and <span class="math inline">\(effs \subset r2\)</span>. When running <code>prepropEquivalent</code>, you <em>must</em> type-apply <code>effs</code>, because Haskell isn’t smart enough to figure it out for itself.</p>
<p>The other type variable to <code>prepropEquivalent</code> is <code>f</code>, which allows us to capture the “resulting state” of an interpreter. In <code>runStack :: [Bug] -&gt; Sem (Stack s ': r) a -&gt; Sem r ([s], a)</code>, you’ll notice we transform a program returning <code>a</code> into one returning <code>([s], a)</code>, and thus <code>f ~ (,) [s]</code>. If your interpreter doesn’t produce any resulting state, feel free to let <code>f ~ Identity</code>.</p>
<p>We’re finally ready to test our interpreters! For any equivalence relationship, we should expect something to be equivalent to itself. And this is true regardless of which bugs we enable:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="ot">prop_reflexive ::</span> <span class="dt">Property</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>prop_reflexive <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>  bugs <span class="ot">&lt;-</span> arbitrary</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>  <span class="fu">pure</span> <span class="op">$</span></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>    prepropEquivalent <span class="op">@</span>&#39;[<span class="dt">Stack</span> <span class="dt">Int</span>]</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>      (<span class="fu">pure</span> <span class="op">.</span> run <span class="op">.</span> runStack bugs)  <span class="co">-- pure is getting us into IO</span></span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>      (<span class="fu">pure</span> <span class="op">.</span> run <span class="op">.</span> runStack bugs)</span></code></pre></div>
<p>So what’s happening here? Internally, <code>prepropEquivalent</code> is generating random programs of type <code>Sem '[Stack Int] Int</code>, and lifting that into <code>Sem r1 Int</code> and <code>Sem r2 Int</code>, and then running both interpreters and ensuring the result is the same for every program. Note that this means any fundamental non-determinism in your interpretation will break the test! Make sure to use appropriate interpreters for things like clocks and random values!</p>
<p>To strengthen our belief in <code>prepropEquivalent</code>, we can also check that <code>runStack</code> is <em>not</em> equivalent to itself if different bugs are enabled:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="ot">prop_bugsNotEquivalent ::</span> <span class="dt">Property</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>prop_bugsNotEquivalent <span class="ot">=</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>  expectFailure <span class="op">$</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>    prepropEquivalent <span class="op">@</span>&#39;[<span class="dt">Stack</span> <span class="dt">Int</span>]</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>      (<span class="fu">pure</span> <span class="op">.</span> run <span class="op">.</span> runStack [<span class="dt">PushTwice</span>])</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>      (<span class="fu">pure</span> <span class="op">.</span> run <span class="op">.</span> runStack [])</span></code></pre></div>
<p>Running this test will give us output like:</p>
<pre><code>+++ OK, failed as expected. Falsified (after 3 tests):
([0,0],1) /= ([0],1)</code></pre>
<p>The counterexample here isn’t particularly helpful (I haven’t yet figured out how to <code>show</code> the generated program that fails,) but you can get a hint here by noticing that the stack (the <code>[0,0]</code>) is twice as big in the first result as in the second.</p>
<p>Importantly, by specifying <code>@'[Stack Int]</code> when calling <code>prepropEquivalent</code>, we are guaranteed that the generated program will <em>only</em> use actions from <code>Stack Int</code>, so it’s not too hard to track down. This is another win for <code>polysemy</code> in my book — that we can isolate bugs with this level of granularity, even if we can’t yet perfectly point to them.</p>
<p>All of today’s code (and more!) is <a href="https://github.com/polysemy-research/polysemy-check/blob/master/test/ExampleSpec.hs">available</a> as a test in <code>polysemy-check</code>, if you’d like to play around with it. But that’s all for now. Next week we’ll investigate how to use <code>polysemy-check</code> to ensure that the composition of your effects <em>themselves</em> is meaningful. Until then!</p>
      ]]></content:encoded>
  </item>
  <item>
      <title>Testing Polysemy With polysemy-check</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>http://reasonablypolymorphic.com/blog/polysemy-check/index.html</link>
      <guid>http://reasonablypolymorphic.com/blog/polysemy-check/index.html</guid>
      <pubDate>2021-10-09T14:23:00Z</pubDate>
      <content:encoded><![CDATA[
        <p><a href="/blog/porting-to-polysemy/">Last week</a> we covered how to port an existing codebase to <a href="https://hackage.haskell.org/package/polysemy"><code>polysemy</code></a>. The “why you might want to do this” was left implicit, but to be more explicit about things, it’s because littering your codebase with <code>IO</code> makes things highly-coupled and hard to test. By forcing yourself to think about effects, you are forced to pull concerns apart, and use the type-system to document what’s going on. But more importantly for today, it gives us a layer of indirection inside of which we can insert testing machinery.</p>
<p>To take an extreme example from the codebase I’m currently working on, compare a function with its original (non-polysemized) type:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="ot">api ::</span> <span class="dt">Opts</span> <span class="ot">-&gt;</span> <span class="dt">ServerT</span> <span class="dt">API</span> <span class="dt">App</span></span></code></pre></div>
<p>which looks very simple, and gives the false impression that <code>api</code> is fairly uninteresting. However, there is an amazing amount of <code>IO</code> hiding inside of <code>App</code>, which becomes <em>significantly more evident</em> when we give this type explicit dependency constraints:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="ot">api ::</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>  <span class="dt">Members</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>    &#39;[ <span class="dt">AReqIDStore</span>,</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>       <span class="dt">AssIDStore</span>,</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>       <span class="dt">BindCookieStore</span>,</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>       <span class="dt">BrigAccess</span>,</span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>       <span class="dt">DefaultSsoCode</span>,</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>       <span class="dt">Error</span> <span class="dt">SparError</span>,</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a>       <span class="dt">GalleyAccess</span>,</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>       <span class="dt">IdP</span>,</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a>       <span class="dt">Input</span> <span class="dt">Opts</span>,</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a>       <span class="dt">Logger</span> (<span class="dt">Msg</span> <span class="ot">-&gt;</span> <span class="dt">Msg</span>)</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a>       <span class="dt">Logger</span> <span class="dt">String</span>,</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true"></a>       <span class="dt">Now</span>,</span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true"></a>       <span class="dt">Random</span>,</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true"></a>       <span class="dt">Reporter</span>,</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true"></a>       <span class="dt">SAML2</span>,</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true"></a>       <span class="dt">SAMLUserStore</span>,</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true"></a>       <span class="dt">SamlProtocolSettings</span>,</span>
<span id="cb2-20"><a href="#cb2-20" aria-hidden="true"></a>       <span class="dt">ScimExternalIdStore</span>,</span>
<span id="cb2-21"><a href="#cb2-21" aria-hidden="true"></a>       <span class="dt">ScimTokenStore</span>,</span>
<span id="cb2-22"><a href="#cb2-22" aria-hidden="true"></a>       <span class="dt">ScimUserTimesStore</span>,</span>
<span id="cb2-23"><a href="#cb2-23" aria-hidden="true"></a>     ]</span>
<span id="cb2-24"><a href="#cb2-24" aria-hidden="true"></a>    r <span class="ot">=&gt;</span></span>
<span id="cb2-25"><a href="#cb2-25" aria-hidden="true"></a>  <span class="dt">Opts</span> <span class="ot">-&gt;</span></span>
<span id="cb2-26"><a href="#cb2-26" aria-hidden="true"></a>  <span class="dt">ServerT</span> <span class="dt">API</span> (<span class="dt">Sem</span> r)</span></code></pre></div>
<p>Wow! Not so innocent-looking now, is it? Each <code>Member</code> constraint here is a unit of functionality that was previously smuggled in via <code>IO</code>. Not only have we made them more visible, but we’ve now exposed a big chunk of testable surface-area. You see, each one of these members provides an abstract interface, which we can implement in any way we’d like.</p>
<p>Because <code>IO</code> is so hard to test, the idea of <code>polysemy</code> is that we can give several interpretaions for our program — one that is pure, lovely, functional, and, importantly, very easy to test. Another interpretation is one that that runs fast in <code>IO</code>. The trick then is to decompose the problem of testing into two steps:</p>
<ol type="1">
<li>show that the program is correct under the model interpreter</li>
<li>show that the model interpreter is equivalent to the real interpreter</li>
</ol>
<p>This sounds great in principle, but as far as I know, it’s never been actually done in practice. My suspicion is that people using <code>polysemy</code> in the wild don’t get further than step 1 (which is OK — a good chunk of the value in effect systems is in the decomposition itself.) Doing all of the work to show equivalence of your interpreters is a significant amount of work, and until now, there have been no tools to help.</p>
<p><strong>Introducing <a href="https://hackage.haskell.org/package/polysemy-check"><code>polysemy-check</code></a>:</strong> a new library for proving all the things you’d want to prove about a <code>polysemy</code> codebase. <code>polysemy-check</code> comes with a few tools for synthesizing <a href="https://hackage.haskell.org/package/QuickCheck"><code>QuickCheck</code></a> properties, plus machinery for getting <code>Arbitrary</code> instances for effects for free.</p>
<h2 id="using-polysemy-check">Using polysemy-check</h2>
<p>To get started, you’re going to need to give two instances for every effect in your system-under-test. Let’s assume we have a stack effect:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Stack</span> s m a <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>  <span class="dt">Push</span><span class="ot"> ::</span> s <span class="ot">-&gt;</span> <span class="dt">Stack</span> s m ()</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>  <span class="dt">Pop</span><span class="ot"> ::</span> <span class="dt">Stack</span> s m (<span class="dt">Maybe</span> s)</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>  <span class="dt">RemoveAll</span><span class="ot"> ::</span> <span class="dt">Stack</span> s m ()</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>  <span class="dt">Size</span><span class="ot"> ::</span> <span class="dt">Stack</span> s m <span class="dt">Int</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>makeSem &#39;<span class="dt">&#39;Stack</span></span></code></pre></div>
<p>The instances we need are given by:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">deriving</span> <span class="kw">instance</span> (<span class="dt">Show</span> s, <span class="dt">Show</span> a) <span class="ot">=&gt;</span> <span class="dt">Show</span> (<span class="dt">Stack</span> s m a)</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>deriveGenericK &#39;<span class="dt">&#39;Stack</span></span></code></pre></div>
<p>where <code>deriveGenericK</code> is TemplateHaskell that from <a href="https://hackage.haskell.org/package/kind-generics"><code>kind-generics</code></a> (but is re-exported by <code>polysemy-check</code>.) <code>kind-generics</code> is <code>GHC.Generics</code> on steroids: it’s capable of deriving generic code for GADTs.</p>
<p>The first thing that probably comes to mind when you consider <code>QuickCheck</code> is “checking for laws.” For example, we should expect that <code>push s</code> followed by <code>pop</code> should be equal to <code>pure (Just s)</code>. Laws of this sort <em>give meaning to effects,</em> and act as <em>sanity checks on their interpreters.</em></p>
<p>Properties for laws can be created via <code>prepropLaw</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>prepropLaw</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="ot">    ::</span> <span class="kw">forall</span> effs r a f</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>     <span class="op">.</span> ( (<span class="kw">forall</span> z<span class="op">.</span> <span class="dt">Eq</span> z <span class="ot">=&gt;</span> <span class="dt">Eq</span> (f z))</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>       , (<span class="kw">forall</span> z<span class="op">.</span> <span class="dt">Show</span> z <span class="ot">=&gt;</span> <span class="dt">Show</span> (f z))</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>       )</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true"></a>    <span class="ot">=&gt;</span> ( <span class="dt">Eq</span> a</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true"></a>       , <span class="dt">Show</span> a</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true"></a>       , <span class="dt">ArbitraryEff</span> effs r</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true"></a>       )</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true"></a>    <span class="ot">=&gt;</span> <span class="dt">Gen</span> (<span class="dt">Sem</span> r a, <span class="dt">Sem</span> r a)</span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true"></a>    <span class="ot">-&gt;</span> (<span class="kw">forall</span> z<span class="op">.</span> <span class="dt">Sem</span> r (a, z) <span class="ot">-&gt;</span> <span class="dt">IO</span> (f (a, z)))</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true"></a>    <span class="ot">-&gt;</span> <span class="dt">Property</span></span></code></pre></div>
<p>Sorry for the atrocious type. If you’re looking for Boring Haskell, you’d best look elsewhere.</p>
<p>The first argument here is a <code>QuickCheck</code> generator which produces two programs that should be equivalent. The second argument is the interpreter for <code>Sem</code> under which the programs must be equivalent, or will fail the resulting <code>Property</code>. Thus, we can write the <code>push/pop</code> law above as:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>law_pushPop</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="ot">    ::</span> <span class="kw">forall</span> s r f effs res</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>     <span class="op">.</span> (</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>         <span class="co">-- The type that our generator returns</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a>         res <span class="op">~</span> (<span class="dt">Maybe</span> s)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>         <span class="co">-- The effects we want to be able to synthesize for contextualized</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>         <span class="co">-- testing</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>       , effs <span class="op">~</span> &#39;[<span class="dt">Stack</span> s]</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true"></a>         <span class="co">-- Misc constraints you don&#39;t need to care about</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true"></a>       , <span class="dt">Arbitrary</span> s</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true"></a>       , <span class="dt">Eq</span> s</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true"></a>       , <span class="dt">Show</span> s</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true"></a>       , <span class="dt">ArbitraryEff</span> effs r</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true"></a>       , <span class="dt">Members</span> effs r</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true"></a>       , (<span class="kw">forall</span> z<span class="op">.</span> <span class="dt">Eq</span> z <span class="ot">=&gt;</span> <span class="dt">Eq</span> (f z))</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true"></a>       , (<span class="kw">forall</span> z<span class="op">.</span> <span class="dt">Show</span> z <span class="ot">=&gt;</span> <span class="dt">Show</span> (f z))</span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true"></a>       )</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true"></a>    <span class="ot">=&gt;</span> (<span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Sem</span> r (res, a) <span class="ot">-&gt;</span> <span class="dt">IO</span> (f (res, a)))</span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true"></a>    <span class="ot">-&gt;</span> <span class="dt">Property</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true"></a>law_pushPop <span class="ot">=</span> prepropLaw <span class="op">@</span>effs <span class="op">$</span> <span class="kw">do</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true"></a>  s <span class="ot">&lt;-</span> arbitrary</span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true"></a>  <span class="fu">pure</span> ( push s <span class="op">&gt;&gt;</span> pop</span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true"></a>       , <span class="fu">pure</span> (<span class="dt">Just</span> s)</span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true"></a>       )</span></code></pre></div>
<p>Sorry. Writing gnarly constraints is the cost not needing to write gnarly code. If you know how to make this better, please open a PR!</p>
<p>There’s something worth paying attention to in <code>law_pushPop</code> — namely the type of the interpreter <code>(forall a. Sem r (Maybe s, a) -&gt; IO (f (Maybe s, a)))</code>. What is this <code>forall a</code> thing doing, and where does it come from? As written, our generator would merely checks the equivalence of the exact two given programs, but this is an insufficient test. We’d instead like to prove the equivalence of the <code>push/pop</code> law <em>under all circumstances.</em></p>
<p>Behind the scenes, <code>prepropLaw</code> is synthesizing a monadic action to run <em>before</em> our given law, as well as some actions to run <em>after</em> it. These actions are randomly pulled from the effects inside the <code>effs ~ '[Stack s]</code> row (and so here, they will only be random <code>Stack</code> actions.) The <code>a</code> here is actually the result of these “contextual” actions. Complicated, but you really only need to get it right once, and can copy-paste it forevermore.</p>
<p>Now we can specialize <code>law_pushPop</code> (plus any other laws we might have written) for a would-be interpreter of <code>Stack s</code>. Any interpreter that passes all the properties is therefore proven to respect the desired semantics of <code>Stack s</code>.</p>
<h2 id="wrapping-up">Wrapping Up</h2>
<p><code>polysemy-check</code> can do lots more, but this post is overwhelming already. So next week we’ll discuss how to prove the equivalence of interpreters, and how to ensure your effects are sane with respect to one another.</p>
      ]]></content:encoded>
  </item>
  <item>
      <title>Porting to Polysemy</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>http://reasonablypolymorphic.com/blog/porting-to-polysemy/index.html</link>
      <guid>http://reasonablypolymorphic.com/blog/porting-to-polysemy/index.html</guid>
      <pubDate>2021-10-02T22:46:00Z</pubDate>
      <content:encoded><![CDATA[
        <p>Many years ago, when I first started using free monads in anger, I was tasked with porting our giant codebase to something that used an effect system. While it was a noble goal, my efforts slowly imploded upon their own weight. I didn’t know how to go about doing such a dramatic refactoring on a live codebase, and unwisely tried to do the whole thing in a single PR. A month later, as you might expect, it became overwhelming obvious that we were never going to merge the thing, and it died there.</p>
<p>Several years older (and wiser), I’ve recently been contracted to port another codebase to Polysemy. Today we hit our first big milestone, and the experience has gone swimmingly. I wanted to spend some time today discussing how to actually go about Polysemizing a codebase. It’s not too onerous if you proceed cautiously. The trick is to do several passes over the codebase, each time introducing a few more effects, but at no point ever actually changing any code paths.</p>
<h2 id="getting-your-foot-in-the-door">Getting Your Foot in the Door</h2>
<p>The first step is to introduce Polysemy into your codebase. Your program is almost certainly structured around a main application monad, and that’s the right place to start. As a first step, we will swap out <code>IO</code> for <code>Sem</code>. For example, if your main monad were:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">App</span> a <span class="ot">=</span> <span class="dt">App</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>  {<span class="ot"> unApp ::</span> <span class="dt">ReaderT</span> <span class="dt">Env</span> (<span class="dt">ExceptT</span> <span class="dt">AppError</span> <span class="dt">IO</span>) a</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>  }</span></code></pre></div>
<p>we will change it to:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">App</span> r a <span class="ot">=</span> <span class="dt">App</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>  {<span class="ot"> unApp ::</span> <span class="dt">Member</span> (<span class="dt">Final</span> <span class="dt">IO</span>) r <span class="ot">=&gt;</span> <span class="dt">ReaderT</span> <span class="dt">Env</span> (<span class="dt">ExceptT</span> <span class="dt">AppError</span> (<span class="dt">Sem</span> r)) a</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>  }</span></code></pre></div>
<p>This change exposes the effect row (the <code>r</code> type variable,) and asserts that we always have a <code>Final IO</code> member in that row. Exposing <code>r</code> means we can gradually introduce <code>Member</code> constraints in application code as we begin teasing apart effects, and <code>Final IO</code> gives us a way to implement <code>MonadIO</code> for <code>App</code>. Let’s start with that:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">MonadIO</span> (<span class="dt">App</span> r) <span class="kw">where</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>  liftIO a <span class="ot">=</span> <span class="dt">App</span> <span class="op">$</span> lift <span class="op">$</span> lift <span class="op">$</span> embedFinal a</span></code></pre></div>
<p>Due to some quirks of how Haskell deals with impredicativity, this function can’t be written point-free.</p>
<p>This change of <code>App</code> to <code>App r</code> isn’t the end-goal; it’s <em>just</em> enough that we can get Polysemy into the project without it being a huge change. In the medium term, our goal is to eliminate the <code>App</code> newtype altogether, leaving a bare <code>Sem</code> in its place. But one step at a time.</p>
<p>You’ll need to rewrite any instances on <code>App</code> that you were previously newtype deriving. This sucks, but the answer is always just to <code>lift</code>. You might find that some instances used to be derived via <code>IO</code>, and thus now cannot be implemented via <code>lift</code>. In these cases, don’t be afraid to give an orphan instance for <code>Sem r</code>; orphans are bad, but we’ll be cleaning this all up very soon.</p>
<p>Take some time to get everything compiling. It’s a lot of drudgery, but all you need to do is to add the <code>r</code> type variable to every type signature in your codebase that mentions <code>App</code>.</p>
<p>You will also need an introduction function, to lift Polysemy actions into <code>App</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="ot">liftSem ::</span> <span class="dt">Sem</span> r a <span class="ot">-&gt;</span> <span class="dt">App</span> r a</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>liftSem a <span class="ot">=</span> <span class="dt">App</span> <span class="op">$</span> lift <span class="op">$</span> lift a</span></code></pre></div>
<p>as well as an elimination function which will evolve as you add effects. At some point in your (existing) program, you will need to actually run <code>App</code> down to <code>IO</code>. It probably looks something like this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="ot">runApp ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">App</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">AppError</span> a)</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>runApp env <span class="ot">=</span> runExceptT <span class="op">.</span> <span class="fu">flip</span> runReaderT env <span class="op">.</span> unApp</span></code></pre></div>
<p>instead we are going to create the <em>canonical</em> interpretation down to <code>IO</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">CanonicalEffects</span> <span class="ot">=</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>  &#39;[ <span class="dt">Final</span> <span class="dt">IO</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>   ]</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true"></a><span class="ot">canonicalAppToIO ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">App</span> <span class="dt">CanonicalEffects</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">AppError</span> a)</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true"></a>canonicalAppToIO env</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true"></a>  <span class="ot">=</span> runFinal</span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true"></a>  <span class="op">.</span> runExceptT</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true"></a>  <span class="op">.</span> <span class="fu">flip</span> runReaderT env</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true"></a>  <span class="op">.</span> unApp</span></code></pre></div>
<p>As we pull effects out of the program, we will add them to <code>CanonicalEffects</code>, and their interpreters to <code>canonicalAppToIO</code>. But for now, this function is very boring.</p>
<p>Once everything is up and compiling, all of the old tests should still pass. We haven’t changed anything, just installed some new machinery. But importantly, all of code paths are still exactly the same. Remember, this is a refactoring task! The goal is to do lots of little refactors, each one pulling out some effect machinery, but not changing any code paths. The entire porting project should be a series of no-op PRs that slowly carve your codebase into one with explicitly described effects.</p>
<h2 id="first-effects">First Effects</h2>
<p>Your medium term goal is to eliminate the <code>Final IO</code> constraint inside of <code>App</code>, which exists only to provide a <code>MonadIO</code> instance. So, our <em>real</em> goal is to systematically eliminate raw <code>IO</code> from <code>App</code>.</p>
<p>The usual culprits here are database access, HTTP requests, and logging. If your team has been disciplined, database access and HTTP requests should already be relatively isolated from the rest of the codebase. Isolated here means “database calls are in their own functions,” rather than being inlined directly in the application code whenever it wants to talk to the database. If your database accesses are not isolated, take some time to uninline them before continuing.</p>
<p>Our next step is to identify CRUD groups on the database. We generously interpret the “read” in CRUD to be any queries that exist against the logical datastructure that you’re serializing in the database. These CRUD groups might be organized by table, but they don’t necessarily need to be; by table is good enough for now if it corresponds to how the queries exist today.</p>
<p>For each CRUD group, we want to make a new Polysemy effect, and thread it through the application, replacing each direct call to the database with a call to the effect action. Finish working on each effect before starting on the next; each group makes for a good PR.</p>
<p>For example, maybe we’ve identified the following database accesses for table <code>users</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="ot">insertUser       ::</span> <span class="dt">MonadDB</span> m <span class="ot">=&gt;</span> <span class="dt">UserName</span> <span class="ot">-&gt;</span> <span class="dt">User</span> <span class="ot">-&gt;</span> m ()</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a><span class="ot">lookupUser       ::</span> <span class="dt">MonadDB</span> m <span class="ot">=&gt;</span> <span class="dt">UserName</span> <span class="ot">-&gt;</span> m (<span class="dt">Maybe</span> <span class="dt">User</span>)</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a><span class="ot">getUsersByRegion ::</span> <span class="dt">MonadDB</span> m <span class="ot">=&gt;</span> <span class="dt">Region</span> <span class="ot">-&gt;</span> m [<span class="dt">User</span>]</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a><span class="ot">setUserLapsed    ::</span> <span class="dt">MonadDB</span> m <span class="ot">=&gt;</span> <span class="dt">UserName</span> <span class="ot">-&gt;</span> m ()</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a><span class="ot">unsetUserLapsed  ::</span> <span class="dt">MonadDB</span> m <span class="ot">=&gt;</span> <span class="dt">UserName</span> <span class="ot">-&gt;</span> m ()</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a><span class="ot">purgeUser        ::</span> <span class="dt">MonadDB</span> m <span class="ot">=&gt;</span> <span class="dt">UserNamr</span> <span class="ot">-&gt;</span> m ()</span></code></pre></div>
<p>This CRUD group corresponds to an effect:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">module</span> <span class="dt">App.Sem.UserStore</span> <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">UserStore</span> m a <span class="kw">where</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>  <span class="dt">Insert</span><span class="ot">      ::</span> <span class="dt">UserName</span> <span class="ot">-&gt;</span> <span class="dt">User</span> <span class="ot">-&gt;</span> <span class="dt">UserStore</span> m ()</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>  <span class="dt">Lookup</span><span class="ot">      ::</span> <span class="dt">UserName</span> <span class="ot">-&gt;</span> <span class="dt">UserStore</span> m (<span class="dt">Maybe</span> <span class="dt">User</span>)</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>  <span class="dt">GetByRegion</span><span class="ot"> ::</span> <span class="dt">Region</span> <span class="ot">-&gt;</span> <span class="dt">UserStore</span> m [<span class="dt">User</span>]</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a>  <span class="dt">SetLapsed</span><span class="ot">   ::</span> <span class="dt">UserName</span> <span class="ot">-&gt;</span> <span class="dt">UserStore</span> m ()</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true"></a>  <span class="dt">UnsetLapsed</span><span class="ot"> ::</span> <span class="dt">UserName</span> <span class="ot">-&gt;</span> <span class="dt">UserStore</span> m ()</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true"></a>  <span class="dt">Purge</span><span class="ot">       ::</span> <span class="dt">UserName</span> <span class="ot">-&gt;</span> <span class="dt">UserStore</span> m ()</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true"></a></span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true"></a>makeSem &#39;<span class="dt">&#39;UserStore</span></span></code></pre></div>
<p>We can now replace all calls across the codebase to <code>insertUser a b</code> with <code>liftSem $ UserStore.insert a b</code>. Doing so will require you to propagate a <code>Member UserStore r</code> constraint throughout the callstack. I really like this process. It’s a bit annoying to push constraints upwards, but it really gives you a good sense for the hidden complexity in your program. As it turns out, <code>MonadIO</code> is hiding a metric ton of spaghetti code!</p>
<p>All of this replacing and constraint propagating has given you dependency injection. But remember, at this step we’d like all of our changes to be no-ops, so we still need to inject the old codepath. For this we will make an interpreter of the <code>UserStore</code> effect:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">module</span> <span class="dt">App.Sem.UserStore.IO</span> <span class="kw">where</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">TheDatabase</span> <span class="kw">as</span> <span class="dt">DB</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">App.Sem.UserStore</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>userStoreToDB</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a><span class="ot">    ::</span> <span class="kw">forall</span> m r a</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>     <span class="op">.</span> (<span class="dt">Member</span> (<span class="dt">Embed</span> m) r, <span class="dt">MonadDB</span> m)</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a>    <span class="ot">=&gt;</span> <span class="dt">Sem</span> (<span class="dt">UserStore</span> &#39;<span class="op">:</span> r) a</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true"></a>    <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true"></a>userStoreToDB <span class="ot">=</span> interpret <span class="op">$</span> embed <span class="op">@</span>m <span class="op">.</span> \<span class="kw">case</span></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true"></a>  <span class="dt">Insert</span> un u    <span class="ot">-&gt;</span> DB.insertUser un u</span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true"></a>  <span class="dt">Lookup</span> un      <span class="ot">-&gt;</span> DB.lookupUser un</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true"></a>  <span class="dt">GetByRegion</span> r  <span class="ot">-&gt;</span> DB.getUsersByRegion r</span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true"></a>  <span class="dt">SetLapsed</span> un   <span class="ot">-&gt;</span> DB.setUserLapsed un</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true"></a>  <span class="dt">UnsetLapsed</span> un <span class="ot">-&gt;</span> DB.unsetUserLapsed un</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true"></a>  <span class="dt">Purge</span> un       <span class="ot">-&gt;</span> DB.purgeUser un</span></code></pre></div>
<p>Make sure to add <code>UserStore</code> (and its dependency, <code>Embed DB</code>) to the head of <code>CanonicalEffects</code>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">CanonicalEffects</span> <span class="ot">=</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>  &#39;[ <span class="dt">UserStore</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>   , <span class="dt">Embed</span> <span class="dt">DB</span>  <span class="co">-- dependency of UserStore</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>   , <span class="dt">Embed</span> <span class="dt">IO</span>  <span class="co">-- dependency of Embed DB</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>   , <span class="dt">Final</span> <span class="dt">IO</span></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a>   ]</span></code></pre></div>
<p>and then we can update the canonical interpreter:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="ot">canonicalAppToIO ::</span> <span class="dt">Env</span> <span class="ot">-&gt;</span> <span class="dt">App</span> <span class="dt">CanonicalEffects</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> (<span class="dt">Either</span> <span class="dt">AppError</span> a)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>canonicalAppToIO env</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>  <span class="ot">=</span> runFinal</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>  <span class="op">.</span> embedToFinal</span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>  <span class="op">.</span> runEmbedded <span class="op">@</span><span class="dt">DB</span> <span class="op">@</span><span class="dt">IO</span> (however you run the <span class="dt">DB</span> <span class="kw">in</span> <span class="dt">IO</span>)</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a>  <span class="op">.</span> userStoreToDB <span class="op">@</span><span class="dt">DB</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a>  <span class="op">.</span> runExceptT</span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true"></a>  <span class="op">.</span> <span class="fu">flip</span> runReaderT env</span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true"></a>  <span class="op">.</span> unApp</span></code></pre></div>
<p>The general principle here is that you add the new effect somewhere near the top of the <code>CanonicalEffects</code> stack, making sure to add any effects that your intended interpreter requires lower in the stack. Then, add the new interpreter to <code>canonicalAppToIO</code>, in the same order (but perhaps presented “backwards”, since function application is right to left.) Make sure to add interpreters for the depended-upon effects too!</p>
<p>As you pull more and more effects out, you’ll find that often you’ll already have the depended-upon effects in <code>CanonicalEffects</code>. This is a good thing — we will probably have several effects that can all be interpreted via <code>Embed DB</code>.</p>
<p>The benefit here is that we have now separated our <em>application code</em> from the particular choice of database implementation. While we want to use <code>userStoreToDB</code> in production, it might make less sense to use in local testing environments, where we don’t want to spin up a database. Instead, we could just write a little interpreter that emulates the <code>UserStore</code> interface purely in memory! Once you’ve fully exorcised <code>IO</code> from your codebase, this approach gets extremely powerful.</p>
<h2 id="choosing-effects">Choosing Effects</h2>
<p>Carving out your effects is probably the hardest thing to do here. What’s difficult is that you need to forget your instincts! Things that would make a good MTL-style typeclass are often <em>terrible</em> choices for effects.</p>
<p>Why’s that? There’s this extremely common pattern in the Haskell ecosystem for libraries that want to expose themselves to arbitrary applications’ monad stacks. To continue with the <code>MonadDB</code> example, it’s likely something like:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="kw">class</span> (<span class="dt">MonadIO</span> m, <span class="dt">MonadThrow</span> m) <span class="ot">=&gt;</span> <span class="dt">MonadDB</span> m <span class="kw">where</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a><span class="ot">  liftDB ::</span> <span class="dt">DB</span> a <span class="ot">-&gt;</span> m a</span></code></pre></div>
<p>While this works fine for a single underlying implementation, it’s an awful effect for the same reason: there’s only one interpretation! Any meaningful interpreter for <code>MonadDB</code> is equivalent to writing your own implementation of the database! It’s the same reason we don’t like <code>IO</code> — <code>IO</code> is so big that every possible interpretation of it would necessarily need to be able to talk to the file system, to the network, to threads, and <em>everything else</em> that we can do in <code>IO</code>.</p>
<p>Instead, when you’re looking for effects to pull out, you need to <em>forget entirely about the implementation,</em> and just look at the abstract interface. Don’t use an HTTP effect to talk to a REST API — it’s too big, and would require you to implement an entire HTTP protocol. Instead, just define an effect that talks to exactly the pieces of the API that you need to talk to. Forget that it’s REST entirely! That’s an implementation detail, and implementation details are the domain of the interpreter, not the effect.</p>
<p>Furthermore, if you’re just using the standard <code>Polysemy</code> effects, pick the smallest effect that you can get away with. You’ll probably reach for <code>Reader</code> more often than you should. You don’t need to use <code>Reader</code> unless you need <code>local</code> — otherwise, prefer <code>Input</code>.</p>
<h2 id="summing-up">Summing Up</h2>
<p>That’s all I have for today, but I have a few more posts in mind for this series. One on how to actually go about testing all of this stuff, and another on how to follow up the refactoring of your new Polysemy codebase now that all of the <code>IO</code> has been removed.</p>
      ]]></content:encoded>
  </item>
  <item>
      <title>Exploring Case Law</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>http://reasonablypolymorphic.com/blog/exploring-case-law/index.html</link>
      <guid>http://reasonablypolymorphic.com/blog/exploring-case-law/index.html</guid>
      <pubDate>2021-02-08T00:14:00Z</pubDate>
      <content:encoded><![CDATA[
        <script src="https://unpkg.com/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>
<script src="https://d3js.org/d3.v6.min.js"></script>
<script src="/js/charts.js"></script>
<p><link rel="stylesheet" href="/css/law.css"></p>
<h2 id="overview">Overview</h2>
<p>In early 2021, spurred on by many discussions with my incredible, law-student (among many other fantastic characteristics) girlfriend, I decided to try my hand at analyzing Canada’s legal system. Absolutely everything I know about the law I’ve learned from TV shows and a year’s worth of hanging out with law students — which is to say, I don’t know anything.</p>
<p>Oh yeah, and also I don’t know anything about data science or visualization. I’m a computer scientist by trade, and can navigate my way around complicated mathematics better than your average Joe. This projected seemed like a good opportunity to teach myself some of the more obscure bits of graph theory, interactive web design (most of the charts on this page are interactive,) data scraping and subsequent mining.</p>
<p>Often, outsiders can bring new ideas and techniques to otherwise insular communities. Despite knowing nothing, I managed to:</p>
<ul>
<li>determine the speed at which our court of appeal system works</li>
<li>find that somewhere between 33% and 50% of all cases are completely trivial and could be easily automated away</li>
<li>reliably find decisions that are important enough to have Wikipedia articles</li>
<li>find the asymptotics of the growth rate of Canadian case law</li>
<li>determine that BC and Alberta are by far the most powerful provinces with respect to the influence of their decisions, and,</li>
<li>separate decisions automatically into 860 different “areas of law”</li>
</ul>
<p>These are not half-bad results, if I do say so myself. And if one guy who doesn’t really know how to use this technology can do this well, imagine how much damage someone with high-quality data, a budget, and knowledge could do. If you are in the legal field and aren’t yet positioning yourself for the upcoming automation wave, maybe this essay will help convince you that the system isn’t nearly as robust to automation as you might think. I did all of this in two weeks, as an outsider, with no domain knowledge. That should scare you.</p>
<p>Overall, I needed to collect and analyze all of the data myself. I spent maybe fifteen hours programming things, and roughly 336 hours collecting data. I fought with analytics tools for another ten hours, and this write-up took maybe twenty hours. It was a fun project, but I’m happy to be done with it.</p>
<h2 id="methodology">Methodology</h2>
<p>My assumption is that the citation graph of Canadian case law is sufficient to find interesting data in the law. Unfortunately, this data doesn’t seem to exist in any convenient format. <a href="https://canlii.org">CanLII</a> makes the data available on the web, but doesn’t provide any sort of downloadable database. So I needed to make my own.</p>
<p>I wired up a small web-scraper that would connect to CanLII and crawl through the millions of cases available there. My program loaded all the cases from the Supreme Court and provincial courts of appeal, then followed every cited case. And every case cited by every one of <em>those.</em> And so on and so forth, until there were no more cited cases I hadn’t yet downloaded.</p>
<p>After a few weeks of downloading, I was finished. In total, I downloaded 378,732 decisions from 269 different courts. Between these cases, there are 1,998,118 citations. Frighteningly, this is nowhere near the extent of Canadian case law; it’s maybe one tenth of the full corpus. But I feel comfortable in saying that <em>this subset is the law as it exists today.</em> If a case doesn’t lie anywhere in the transitive dependencies of the Supreme Court or a court of appeals, it’s not contentious for anyone to care about.</p>
<p>Despite the large number of cases, it’s important to discuss just how little data I’ve got <em>per</em> case. The totality of my data about cases is of this form:</p>
<figure>
<table>
<TR>
<TH>
name
</TH>
<TH>
year
</TH>
<TH>
language
</TH>
<TH>
jurisdiction
</TH>
<TH>
court
</TH>
</TR>
<TR>
<TD>
Bamba c. R.
</TD>
<TD>
2019
</TD>
<TD>
fr
</TD>
<TD>
qc
</TD>
<TD>
qcca
</TD>
</TR>
<TR>
<TD>
R. v. Leach
</TD>
<TD>
2019
</TD>
<TD>
en
</TD>
<TD>
bc
</TD>
<TD>
bcca
</TD>
</TR>
<TR>
<TD>
R. v. Pruski
</TD>
<TD>
2006
</TD>
<TD>
en
</TD>
<TD>
on
</TD>
<TD>
oncj
</TD>
</TR>
<TR>
<TD>
Regina v. Imperial Optical Co. Ltd.
</TD>
<TD>
1972
</TD>
<TD>
en
</TD>
<TD>
on
</TD>
<TD>
oncj
</TD>
</TR>
<TR>
<TD>
Windheim c. Windheim
</TD>
<TD>
2012
</TD>
<TD>
en
</TD>
<TD>
qc
</TD>
<TD>
qcca
</TD>
</TR>
</table>
<figcaption>
decision data
</figcaption>
</figure>
<p>Notice that there is no information about the <em>contents</em> of these cases. I don’t know which judge was presiding, what was said, what the case was about, keywords, or even who won.</p>
<p>In principle I could have extracted the involved parties by trying to tear apart the name, but it seemed challenging to do well, and I don’t think it would buy me much information without knowing who won.</p>
<p>On the citation front, all I know is this:</p>
<figure>
<table>
<TR>
<TH>
citing_case
</TH>
<TH>
citing_year
</TH>
<TH>
cited_case
</TH>
<TH>
cited_year
</TH>
</TR>
<TR>
<TD>
The King v. Clark
</TD>
<TD>
1901
</TD>
<TD>
Automobile and Supply Co. v. Hands, Ltd.
</TD>
<TD>
1913
</TD>
</TR>
<TR>
<TD>
The King v. Clark
</TD>
<TD>
1901
</TD>
<TD>
The Queen v. Hammond
</TD>
<TD>
1898
</TD>
</TR>
<TR>
<TD>
The King v. Clark
</TD>
<TD>
1901
</TD>
<TD>
The Queen v. Harris
</TD>
<TD>
1898
</TD>
</TR>
<TR>
<TD>
Gallagher v. Hogg
</TD>
<TD>
1993
</TD>
<TD>
Katz v. Katz
</TD>
<TD>
1990
</TD>
</TR>
<TR>
<TD>
Gallagher v. Hogg
</TD>
<TD>
1993
</TD>
<TD>
Lagimodiere v. Lagimodiere
</TD>
<TD>
1991
</TD>
</TR>
</table>
<figcaption>
citation data
</figcaption>
</figure>
<p>Again, no <em>actual</em> information here.</p>
<p>To reiterate, there’s nothing at all that we can use to learn what any particular case was <em>about.</em> In this database, the vanishing majority of the information available to us is which cases cite whom. Anything we want to figure out needs to be inferred from that.</p>
<h3 id="possible-issues">Possible Issues</h3>
<p>The Canadian legal system has existed much longer than the idea that information should be freely available. While CanLII is an excellent source of data, it explicitly states how complete its records are from each court. For example, while CanLII has the entire corpus of Supreme Court decisions, it’s only maintained continuous coverage of the BC Court of Appeal (BCCA) since 1990. Other courts have different starting dates for their continuous coverage.</p>
<p>This presents a systematic bias in our data, namely that more recent cases are more readily available. To illustrate, the database contains 6,212 cases from the BCCA before 1990, but 19,368 cases since. While we might be interested in whether the volume of law is increasing over time, we must be careful to restrict ourselves to the range of continuous coverage.</p>
<p>Looking only at citation data introduces another systematic bias in the dataset: older cases have had a longer time to accumulate citations. Because we mainly keep track of relationships between cases, it’s possible for recent cases to contradict previous decisions. Such a case is clearly very important to the law, but will fly under our radar until it becomes commonly cited.</p>
<h2 id="verifying-the-dataset">Verifying the Dataset</h2>
<p>Before getting started, let’s make sure our data is sane. For example, since case law is immutable, it’s impossible for a case to cite a decision in the future. Therefore we should never see any time-traveling citations in our dataset.</p>
<p>But in fact, there are 1197 cases on CanLII which cite decisions in the future! For example, <a href="https://www.canlii.org/en/ab/abqb/doc/1998/1998abqb476/1998abqb476.html">Molson v. Molson, 1998</a> cites <a href="https://www.canlii.org/en/sk/skqb/doc/2016/2016skqb387/2016skqb387.html">C.T.G. v R.R.G., 2016</a>. Clicking through the first link here shows that what is labeled as “Molson v. Molson, 1998” is <em>actually</em> “Richardson v. Richardson, 2019.”</p>
<p>A few other oddities show up, some of which are trial level courts citing their appeal. These seem more reasonable, and I read this as <em>whoever was doing data entry was typing in the wrong field.</em></p>
<p>This erroneous data makes up only 0.31% of our dataset, so it doesn’t seem like fixing it is worth the effort.</p>
<h2 id="average-age-of-citation">Average Age of Citation</h2>
<p>How long do decisions stay relevant for? By looking at the average age at which a decision is cited, we can get a feel.</p>
<figure>
<div id="avg-duration">
<p>select avg_age, count(*) from (select cast (avg(src_year - dst_year) as int) as avg_age from expanded_citations where src_year &gt;= dst_year group by dst_hash) group by avg_age;</p>
<script>
    lineChart(
      "#avg-duration",
      "/data/1612727565.csv",
      "Avg Age of Decision when Cited",
      d => +parseInt(d.avg_age),
      "Decisions",
      d => +parseInt(d.count))
  </script>
</div>
<figcaption>
Number of cases, by average age at time of citation
</figcaption>
</figure>
<p>It looks like cases stay relevant for about 11 years, at which point the inflection point of this graph switches, and we see the long tail. This is for the law in aggregate, but what about if we look at the average age when cited, broken down by court?</p>
<figure>
<div id="avg-duration-by-court">
<p>select dst_court, cast (avg(src_year - dst_year) as int) as avg_age from expanded_citations where src_year &gt;= dst_year and dst_court in (select court from important_courts order by max desc limit 15) group by dst_court;</p>
<script>
    barChart(
      "#avg-duration-by-court",
      "/data/1612746186.csv",
      d => d.dst_court,
      d => +parseInt(d.avg_age))
  </script>
</div>
<figcaption>
Average age at time of citation, by court
</figcaption>
</figure>
<p>This chart shows the top 15 most important courts. Among them, the <em>really big, important courts</em> hold sway longer than the smaller courts. But is the story different for the smallest courts?</p>
<figure>
<div id="avg-duration-by-smallest-court">
<p>select dst_court, cast (avg(src_year - dst_year) as int) as avg_age from expanded_citations where src_year &gt;= dst_year and dst_court in (select court from important_courts order by max asc limit 10) group by dst_court;</p>
<script>
    barChart(
      "#avg-duration-by-smallest-court",
      "/data/1612746614.csv",
      d => d.dst_court,
      d => +parseInt(d.avg_age))
  </script>
</div>
<figcaption>
Average age at time of citation, by small court
</figcaption>
</figure>
<p>Definitely a different story here. These smaller courts’ decisions fall off in relevance significantly faster than their larger counterparts.</p>
<p>A corollary to this question of law relevance is to look <em>not at the citee, but the citing case.</em> What is the average age of a case’s citations?</p>
<figure>
<div id="avg-age">
<p>select avg_age, count(*) from (select cast (avg(src_year - dst_year) as int) as avg_age from expanded_citations where src_year &gt;= dst_year group by src_hash) group by avg_age;</p>
<script>
    lineChart(
      "#avg-age",
      "/data/1612727606.csv",
      "Avg Age of Cited Decisions",
      d => +parseInt(d.avg_age),
      "Decisions",
      d => +parseInt(d.count))
  </script>
</div>
<figcaption>
Number of cases, by average age of citation
</figcaption>
</figure>
<p>The fall-off here is closer to 20 years — compared to the ten year average lifespan of a decision. The discrepancy between these numbers suggests that cases are likely to a few old cases and numerous newer ones. Maybe cases will cite an original precedent, and then many other cases that have followed the precedent?</p>
<p>When looking at average age of citation, we can look for trends over time. How has the average age of citation changed over the years?</p>
<figure>
<div id="avg-age-by-year">
<p>select src_year, avg(avg_age) as avg_age from (select src_year, avg(src_year - dst_year) as avg_age from expanded_citations where src_year &gt;= dst_year group by src_hash) group by src_year;</p>
<script>
    lineChart(
      "#avg-age-by-year",
      "/data/1612747472.csv",
      "Year",
      d => +parseInt(d.src_year),
      "Avg (Avg Age) of Cited Decisions",
      d => +parseFloat(d.avg_age).toFixed(2))
  </script>
</div>
<figcaption>
Average average age of citation, by year
</figcaption>
</figure>
<p>And again, let’s compare these average ages by big courts:</p>
<figure>
<div id="avg-age-by-court">
<p>select src_court, cast (avg(src_year - dst_year) as int) as avg_age from expanded_citations where src_year &gt;= dst_year and src_court in (select court from important_courts order by max desc limit 15) group by src_court;</p>
<script>
    barChart(
      "#avg-age-by-court",
      "/data/1612747795.csv",
      d => d.src_court,
      d => +parseInt(d.avg_age))
  </script>
</div>
<figcaption>
Average age of citation, by court
</figcaption>
</figure>
<p>Wow! Look at the big courts. There is almost no variance in the average age of citations — they’re all clustered right around 13. Seeing as these are all of the appeal-level courts, it strongly suggests that <strong>this is the speed of our legal system.</strong> It takes thirteen years on average to make it through the entire appeal process. Disgustingly slow.</p>
<p>There’s nothing interesting in the small courts graph — they show the same variances as in the duration of case relevance.</p>
<h2 id="complexity-of-the-law">Complexity of the Law</h2>
<p>Although there are nearly 400,000 cases in our dataset, I don’t think most of those can possibly be interesting. My understanding of case law is that usually a precedent has already been set, and the judge almost always defers to that precedent. To find cases like these, we can look at the number of decisions cited by a case. If a case cites only a few decisions (let’s say three or fewer,) it’s probably just agreeing with precedent.</p>
<figure>
<div id="complexity">
<p>select c, count(<em>) as count from (select count(</em>) as c from expanded_citations where src_year &gt;= (select year from coverage where court = src_court) group by src_hash) group by c; BUCKETED BY HAND</p>
<script>
    pieChart(
      "#complexity",
      "/data/1612748474.csv",
      // "Citation Count",
      d => d.c,
      // "Cases",
      d => +parseInt(d.count))
  </script>
</div>
<figcaption>
Cases by number of decisions cited
</figcaption>
</figure>
<p>The number of cases cited falls off exponentially as we’d expect, so I bucketed the higher number of citations in this chart. But take a look: roughly one third of all cases cite three or fewer decisions, and nearly a sixth cite <em>only one!</em></p>
<p>If our hypothesis is true, it means that one sixth of all cases are glaringly obvious wastes of time, and a third are trivially decided. But does this hold true across all courts? Let’s look at the breakdown for a few of the highest importance courts:</p>
<figure>
<div id="complexity-scc">
<p>select c, count(<em>) as count from (select count(</em>) as c from expanded_citations where src_year &gt;= (select year from coverage where court = src_court) and src_year &gt;= 1950 and src_court = ‘scc’ group by src_hash) group by c;</p>
<script>
    pieChart(
      "#complexity-scc",
      "/data/1612750035.csv",
      // "Citation Count",
      d => d.c,
      // "Cases",
      d => +parseInt(d.count))
  </script>
</div>
<figcaption>
Cases by number of decisions cited (SCC, 1950+)
</figcaption>
</figure>
<p>I filtered the SCC decisions to only look at cases after 1950 — earlier ones were too likely to not have their citations available on CanLII, and would thus throw off our analysis. But amazingly, even of cases that make it to the Supreme Court, still more than a third of them cite only three or fewer decisions.</p>
<p>That sounds a little crazy to me, so I went on CanLII and randomly clicked on a few supreme court cases. And sure enough, many of them <em>do</em> only cite one case! Inspecting them visually, these cases come with extraordinarily short documents — many are under 1000 words.</p>
<p>Let’s see if this holds for the AB, BC, ON and QC courts of appeal as well:</p>
<figure>
<div id="complexity-abca">
<p>select c, count(<em>) as count from (select count(</em>) as c from expanded_citations where src_year &gt;= (select year from coverage where court = src_court) and src_court = ‘abca’ group by src_hash) group by c;</p>
<script>
    pieChart(
      "#complexity-abca",
      "/data/1612750541.csv",
      // "Citation Count",
      d => d.c,
      // "Cases",
      d => +parseInt(d.count))
  </script>
</div>
<figcaption>
Cases by number of decisions cited (ABCA)
</figcaption>
</figure>
<figure>
<div id="complexity-bcca">
<p>select c, count(<em>) as count from (select count(</em>) as c from expanded_citations where src_year &gt;= (select year from coverage where court = src_court) and src_court = ‘bcca’ group by src_hash) group by c;</p>
<script>
    pieChart(
      "#complexity-bcca",
      "/data/1612750650.csv",
      // "Citation Count",
      d => d.c,
      // "Cases",
      d => +parseInt(d.count))
  </script>
</div>
<figcaption>
Cases by number of decisions cited (BCCA)
</figcaption>
</figure>
<figure>
<div id="complexity-onca">
<p>select c, count(<em>) as count from (select count(</em>) as c from expanded_citations where src_year &gt;= (select year from coverage where court = src_court) and src_court = ‘onca’ group by src_hash) group by c;</p>
<script>
    pieChart(
      "#complexity-onca",
      "/data/1612750834.csv",
      // "Citation Count",
      d => d.c,
      // "Cases",
      d => +parseInt(d.count))
  </script>
</div>
<figcaption>
Cases by number of decisions cited (ONCA)
</figcaption>
</figure>
<figure>
<div id="complexity-qcca">
<p>select c, count(<em>) as count from (select count(</em>) as c from expanded_citations where src_year &gt;= (select year from coverage where court = src_court) and src_court = ‘qcca’ group by src_hash) group by c;</p>
<script>
    pieChart(
      "#complexity-qcca",
      "/data/1612750959.csv",
      // "Citation Count",
      d => d.c,
      // "Cases",
      d => +parseInt(d.count))
  </script>
</div>
<figcaption>
Cases by number of decisions cited (QCCA)
</figcaption>
</figure>
<p>Pretty close to <em>half</em> of the cases that come through these appeal-level courts are trivial. If we could automate decisions of this sort, we should be able to make the appeal system roughly 70% faster — reducing the average time per case from 13 years to 7.5. I can’t find any numbers on how expensive the court system is to run, but this would reduce its cost by 70% as well, which is almost certainly something worth investigating.</p>
<h2 id="volume-of-law">Volume of Law</h2>
<p>What’s the rate of law being accumulated? Is it accelerating? We can look at the number of cases per year per court over the last 30 years<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> to get a sense of the acceleration of accumulation:</p>
<figure>
<div id="volume">
<p>select court, year, count(*) as count from decisions d where court in (select court from important_courts order by max desc limit 10) and year &gt;= 1990 and year &gt;= (select year from coverage c where d.court = c.court) and 2021 &gt; year group by court, year;</p>
<script>
    multiLineChart(
      "#volume",
      "/data/1612761383.csv",
      d => d.court,
      d => +parseInt(d.year),
      d => +parseInt(d.count))
  </script>
</div>
<figcaption>
Volume of decisions by top courts, starting after dates of continuing coverage
</figcaption>
</figure>
<p>Those lines all look pretty constant to me, which makes sense if you assume the courts are limited by time and that they have no gains in efficiency (lol.) So no, the volume at which law is accumulating in Canada is not accelerating. But remember that this graph is the velocity of change, which means the volume of law is growing linearly with respect to time.</p>
<figure>
<div id="total-volume">
<p>select y.year, count(*) as volume from (select distinct year from decisions order by year) y inner join decisions d on y.year &gt;= d.year where 2021 &gt; y.year group by y.year;</p>
<script>
    lineChart(
      "#total-volume",
      "/data/1612762714.csv",
      "Year",
      d => +parseInt(d.year),
      "Volume of Law",
      d => +parseInt(d.volume))
  </script>
</div>
<figcaption>
Number of cases in existence, by year
</figcaption>
</figure>
<p>No, wait, that <em>does</em> look exponential. I forgot. While the volume <em>per court</em> is staying constant, the number <em>of courts</em> grows with year:</p>
<figure>
<div id="total-volume-courts">
<p>select y.year, count(*) as volume from (select distinct year from decisions order by year) y inner join (select min(year) as year from decisions group by court) c on y.year &gt;= c.year where 2021 &gt; y.year group by y.year;</p>
<script>
    lineChart(
      "#total-volume-courts",
      "/data/1612762752.csv",
      "Year",
      d => +parseInt(d.year),
      "Number of Courts",
      d => +parseInt(d.volume))
  </script>
</div>
<figcaption>
Number of courts in existence, by year
</figcaption>
</figure>
<p>This graph estimates the number of courts in existence by the first decision we have from that court being the year it was created — which seems like a satisfactory proxy. The curve appears to have leveled off, but I think this is due to 2020 being a GLOBAL PANDEMIC. If I had to guess, I’d say the inflection point around 1997 is an artifact of the digitization of law, and that this curve will continue linearly.</p>
<h2 id="who-cites-whom">Who Cites Whom?</h2>
<p>Are certain provinces “friends?” Which provinces influence which others? Let’s look at the percentage by which one provinces’ courts cite another provinces:</p>
<figure>
<div id="juris-cite-juris">
<p>with data as (select src_jurisdiction, dst_jurisdiction, count(<em>) as count from expanded_citations where src_jurisdiction != dst_jurisdiction group by src_jurisdiction, dst_jurisdiction), totals as (select src_jurisdiction, sum(count) as total from data group by src_jurisdiction) select d.src_jurisdiction, d.dst_jurisdiction, d.count </em> 100.0 / t.total as count from data d inner join totals t on d.src_jurisdiction = t.src_jurisdiction;</p>
<script>
    heatTable(
      "#juris-cite-juris",
      "/data/1612768242.csv",
      d => d.dst_jurisdiction,
      d => d.src_jurisdiction,
      d => +parseFloat(d.count).toFixed(2))
  </script>
</div>
<figcaption>
Citing jurisdiction (left) by cited jurisdiction (top), in percent. Blue is less often.
</figcaption>
</figure>
<p>Yow! The fed is understandably white hot, and dominates this chart. Let’s remove it to look more closely at the provinces:</p>
<figure>
<div id="juris-cite-juris-no-ca">
<p>with data as (select src_jurisdiction, dst_jurisdiction, count(<em>) as count from expanded_citations where src_jurisdiction != dst_jurisdiction and src_jurisdiction != ‘ca’ and dst_jurisdiction != ‘ca’ group by src_jurisdiction, dst_jurisdiction), totals as (select src_jurisdiction, sum(count) as total from data group by src_jurisdiction) select d.src_jurisdiction, d.dst_jurisdiction, d.count </em> 100.0 / t.total as count from data d inner join totals t on d.src_jurisdiction = t.src_jurisdiction;</p>
<script>
    heatTable(
      "#juris-cite-juris-no-ca",
      "/data/1612769065.csv",
      d => d.dst_jurisdiction,
      d => d.src_jurisdiction,
      d => +parseFloat(d.count).toFixed(2))
  </script>
</div>
<figcaption>
Citing jurisdiction (left) by cited jurisdiction (top), in percent. Blue is less often.
</figcaption>
</figure>
<p>Now Ontario dominates, followed closely by BC and Alberta. Nobody cites the territories — but also, nobody cites Quebec. No wonder they feel discriminated against.</p>
<p>Let’s look at the same chart, but this time split by big courts rather than provinces.</p>
<figure>
<div id="court-cite-court">
<p>with courts as (select court from important_courts order by max desc limit 13), data as (select src_court, dst_court, count(<em>) as count from expanded_citations where src_court != dst_court and src_court in courts and dst_court in courts group by src_court, dst_court), totals as (select src_court, sum(count) as total from data group by src_court) select d.src_court, d.dst_court, d.count </em> 100.0 / t.total as count from data d inner join totals t on d.src_court = t.src_court;</p>
<script>
    heatTable(
      "#court-cite-court",
      "/data/1612769747.csv",
      d => d.dst_court,
      d => d.src_court,
      d => +parseFloat(d.count).toFixed(2))
  </script>
</div>
<figcaption>
Citing court (left) by cited court (top), in percent. Blue is less often.
</figcaption>
</figure>
<p>There’s an interesting feature of this graph, namely the “friendship pairs” that lie along the diagonal. For example, <code>bcsc</code> cites <code>bcca</code> much more than it cites anything but the <code>scc</code> — and vice versa! Thinking about it, I guess this makes sense, and is mainly showing us the hierarchical nature of such courts. Of course <code>bcsc</code> cites <code>bcca</code> more than chance, since it must defer. And vice versa also makes sense, because a case must go through <code>bcsc</code> in order to get to <code>bcca</code>.</p>
<p>Well, not every stream you pan will have gold.</p>
<h2 id="determining-important-cases">Determining Important Cases</h2>
<p>The sheer size of the case law corpus is staggering. My dataset contains roughly 400,000 decisions — a small fraction of the <em>actual law.</em> And this is a few orders of magnitude larger than any human could possibly remember.</p>
<p>Thankfully, most of this data is noise. Most cases taken to court are decided uninterestingly: the presiding judge simply defers to precedent and everyone goes on their way. It’s safe to say that decisions of this sort are unimportant. In my opinion, the desired end-state of the law is for all cases to be decided like this — at that point, we’ve got a stable, entirely-predictable system.</p>
<p>But that is not (yet!) the world we live in. Some cases <em>are</em> interesting — for example, the ones which <em>set</em> precedent, and the ones which <em>contradict</em> precedent. How can we find these cases?</p>
<p>Humans would probably look at the cases, and think about first principles, and talk to other people they think are smart, and think really hard, and maybe go consult some textbooks, in an attempt to determine which cases are important. The computer is too dumb to do any of that. It’s only good at moving numbers around ridiculous fast, and I’m very good at turning problems that don’t sound like they involve numbers into ones that do.</p>
<p>So how can we introduce numbers into this problem?</p>
<p>Rather than trying to compute importance directly, let’s instead try to approximate it. Intuitively, cases which are important will be cited more often than cases which are not important. Thus, citation count is — to a first approximation — a good model for importance. Indeed, this seems to be how most <a href="https://www.lexisnexis.com/ln-media/totg/p/lotg.aspx?mediaid=121105">law software</a> computes importance.</p>
<p>To improve our model, let’s take an intellectual detour and think about the importance of websites. Imagine the website for Reputable News Network (RNN). By virtue of being a reputable news site, it will naturally be linked to quite often. Like in the case law example, this should improve our estimate of RNN being an important site.</p>
<p>But now consider <em>the sites that RNN links to.</em> Maybe RNN is running a story on bloggers, and links to Paul Podunk’s Personal Page (PPPP). PPPP is news-worthy by definition due to being on RNN, and surely news-worthy things are more important than non-influential things. Thus, PPPP should be considered more important, sheerly by virtue of having been linked-to by an important thing.</p>
<p>Of course, this new influence that PPPP has acquired from RNN should also be accounted for — sites that PPPP links to become more important due to their relevance to PPPP. And so on, and so forth. But critically, these sites are considered <em>less</em> important than they would be if RNN linked to them directly, since RNN is significantly more influential than PPPP.</p>
<p>The key assumption of this model is that important things run in the same circles as other important things. This jives with my intuition. It’s clearly true in the news cycle. It’s why people name drop in order to raise their social standing — if they know important people, they must too be important. Of course, this is not a perfect model for importance, but it gets the broad strokes.</p>
<p>And, if you have any remaining doubts, this exact algorithm is what powers Google search. Clearly, Google (an important entity) wouldn’t be using this technique if it didn’t work. Therefore it probably does work. See? This technique works <em>everywhere.</em></p>
<p>Returning to law, let’s replace “websites” with “decisions,” and “links” with “citations.” We can compute the importance of cases by seeing which important cases they’re connected to.</p>
<h3 id="verifying-important-cases">Verifying Important Cases</h3>
<p>After crunching the numbers for a few hours, I came up with an <em>importance score</em> for each case. It’s hard to get a real intuition for <a href="https://en.wikipedia.org/wiki/Eigenvector_centrality">what these scores <em>are</em></a>, but a safe interpretation is that a higher importance score corresponds to a more-important case.</p>
<p>To verify that these importance scores actually correspond with reality, I took the names and years of the top 50 cases, and searched for a Wikipedia page on the topic. My theory is that <em>really</em> important cases will be important enough to have Wikipedia commentary about them for laypeople like me.</p>
<p>At time of writing, of the top 50 cases, 34 have Wikipedia articles. And among those, 22 are described in the first sentence as either a “landmark” or a “leading” case.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> That’s a pretty good sign.</p>
<p>Without further ado, here are the 50 most important cases by my analysis:</p>
<ol>
<li>
<a href="https://en.wikipedia.org/wiki/Dunsmuir_v_New_Brunswick">Dunsmuir v. New Brunswick</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Canada_(Minister_of_Citizenship_and_Immigration)_v_Khosa">Canada (Citizenship and Immigration) v. Khosa</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Baker_v_Canada_(Minister_of_Citizenship_and_Immigration)">Baker v. Canada (Minister of Citizenship and Immigration)</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Dunsmuir_v_New_Brunswick">Newfoundland and Labrador Nurses’ Union v. Newfoundland and Labrador (Treasury Board)</a>
</li>
<li>
Housen v. Nikolaisen, 2002
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Hunter_v_Southam_Inc">Hunter et al. v. Southam Inc.</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/R_v_Collins_(1987)">R. v. Collins</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/R_v_Oakes">R. v. Oakes</a>
</li>
<li>
Alberta (Information and Privacy Commissioner) v. Alberta Teachers’ Association, 2011
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Pushpanathan_v_Canada_(Minister_of_Citizenship_and_Immigration)">Pushpanathan v. Canada (Minister of Citizenship and Immigration)</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Re_Rizzo_%26_Rizzo_Shoes_Ltd">Rizzo &amp; Rizzo Shoes Ltd. (Re)</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Dr_Q_v_College_of_Physicians_and_Surgeons_of_British_Columbia">Dr. Q. v. College of Physicians and Surgeons of British Columbia</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Canada_(Director_of_Investigation_and_Research)_v_Southam_Inc">Canada (Director of Investigation and Research) v. Southam Inc.</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Law_Society_of_New_Brunswick_v_Ryan">Law Society of New Brunswick v. Ryan</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/R_v_Big_M_Drug_Mart_Ltd">R. v. Big M Drug Mart Ltd.</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/R_v_Grant">R. v. Grant</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Reference_Re_BC_Motor_Vehicle_Act">Re B.C. Motor Vehicle Act</a>
</li>
<li>
Agraira v. Canada (Public Safety and Emergency Preparedness), 2013
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Canadian_Union_of_Public_Employees_v_Ontario_(Minister_of_Labour)">C.U.P.E. v. Ontario (Minister of Labour)</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Suresh_v_Canada_(Minister_of_Citizenship_and_Immigration)">Suresh v. Canada (Minister of Citizenship and Immigration)</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/R_v_Stillman">R. v. Stillman</a>
</li>
<li>
R. v. M. (C.A.), 1996
</li>
<li>
<a href="https://en.wikipedia.org/wiki/R_v_O%27Connor">R. v. O’Connor</a>
</li>
<li>
Toronto (City) v. C.U.P.E., Local 79, 2003
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Andrews_v_Law_Society_of_British_Columbia">Andrews v. Law Society of British Columbia</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Irwin_Toy_Ltd_v_Quebec_(AG)">Irwin Toy Ltd. v. Quebec (Attorney General)</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Canada_(AG)_v_Mossop">Canada (Attorney General) v. Mossop</a>
</li>
<li>
Bell ExpressVu Limited Partnership v. Rex, 2002
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Canada_(Minister_of_Citizenship_and_Immigration)_v_Vavilov">Canada (Minister of Citizenship and Immigration) v. Vavilov</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Canadian_Union_of_Public_Employees,_Local_963_v_New_Brunswick_Liquor_Corp">C.U.P.E. v. N.B. Liquor Corporation</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/R_v_Edwards_Books_and_Art_Ltd">R. v. Edwards Books and Art Ltd.</a>
</li>
<li>
R. v. Lyons, 1987
</li>
<li>
McLean v. British Columbia (Securities Commission), 2013
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Union_des_Employes_de_Service,_Local_298_v_Bibeault">U.E.S., Local 298 v. Bibeault</a>
</li>
<li>
Canada (Canadian Human Rights Commission) v. Canada (Attorney General), 2011
</li>
<li>
R. v. Garofoli, 1990
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Blencoe_v_British_Columbia_(Human_Rights_Commission)">Blencoe v. British Columbia (Human Rights Commission)</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/R_v_Therens">R. v. Therens</a>
</li>
<li>
Smith v. Alliance Pipeline Ltd., 2011
</li>
<li>
<a href="https://en.wikipedia.org/wiki/R_v_W_(D)">R. v. W.(D.)</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/RJR-MacDonald_Inc_v_Canada_(AG)">RJR-MacDonald Inc. v. Canada (Attorney General)</a>
</li>
<li>
Sketchley v. Canada (Attorney General), 2005
</li>
<li>
<a href="https://en.wikipedia.org/wiki/R_v_Mann">R. v. Mann</a>
</li>
<li>
Cepeda-Gutierrez v. Canada (Minister of Citizenship and Immigration), 1998
</li>
<li>
<a href="https://en.wikipedia.org/wiki/Slaight_Communications_Inc_v_Davidson">Slaight Communications Inc. v. Davidson</a>
</li>
<li>
Committee for Justice and Liberty et al. v. National Energy Board et al., 1976
</li>
<li>
R. v. Debot, 1989
</li>
<li>
Mission Institution v. Khela, 2014
</li>
<li>
<a href="https://en.wikipedia.org/wiki/R_v_Morgentaler">R. v. Morgentaler</a>
</li>
<li>
<a href="https://en.wikipedia.org/wiki/R_v_Sharpe">R. v. Sharpe</a>
</li>
</ol>
<p>If you’re a law professional, you might disagree with this list. Maybe the ordering is wrong. Maybe there are some glaring omissions, or some strange choices. Glaring omissions are probably caused by recency bias — new important decisions simply haven’t had time to accumulate citations (and thus importance.) The wrong ordering? That’s just like, your opinion, man.</p>
<p>But of particular interest to me are the cases on this list that <em>aren’t on Wikipedia.</em> Assuming Wikipedia is a reasonable proxy for what lawyers think are important cases, the missing articles here have previously-unacknowledged importance.</p>
<p>Anyway, it seems like my calculated importance score correlates pretty well with real-world importance. But let’s try to falsify that hypothesis, and see if the bottom-ranked cases have Wikipedia articles.</p>
<p>I checked. They don’t. Not a single hit in the 50 I tried<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>. I also checked for Wikipedia articles on a randomly-selected set of 50 cases, in an attempt to find the base-rate we should expect to see. Again, there wasn’t a single hit.</p>
<p>These negative results add strong evidence that my importance score is <em>measuring something real.</em> Remember, there is absolutely no human judgment going into this analysis; <em>my program is simply crunching the numbers based on who cites whom.</em> The fact that it can identify <em>any</em> important cases whatsoever is jaw-dropping.</p>
<h3 id="statistical-biases">Statistical Biases</h3>
<p>So we’ve successfully found important cases. My first question is, how necessary was all of this fancy math? Could I just have ignored it and gone straight to number of citations? How correlated is the importance metric with the raw number of citations? Let’s see:</p>
<figure>
<div id="correlation">
<p>select dst_importance, count(*) as count from expanded_citations group by dst_hash order by dst_importance desc limit 1000 offset 1;</p>
<script>
    scatter(
      "#correlation",
      "/data/1612759421.csv",
      "Importance",
      d => parseFloat(d.dst_importance).toFixed(5),
      "Citation Count",
      d => +d.count)
  </script>
</div>
<figcaption>
Correlation between the importance metric and the number of times cited.
</figcaption>
</figure>
<p>If the two metrics were strongly correlated, we should see a nice sharp diagonal line going up and to the right. We don’t. Instead we see, well, I’ll leave the Rorschach test up to you. There’s clearly some correlation, but it’s not particularly strong. So no — we can’t just use the citation count!</p>
<p>Another thing you might be wondering is, “what courts do all these important cases come from?” Good question:</p>
<figure>
<div id="court-of-important-cases">
<p>select court, count(*) as count from (select court from decisions order by importance desc limit 1000) x group by court having count &gt; 20; THEN OTHER = 1000 -</p>
<script>
    pieChart(
      "#court-of-important-cases",
      "/data/1612753367.csv",
      d => d.court,
      d => d.count)
  </script>
</div>
<figcaption>
Courts of the top 1000 important cases
</figcaption>
</figure>
<p>Interesting. The Supreme Court takes most of the cake, but Ontario and Quebec are crowded out by BC and Alberta. Drilling down into the “other” category from the chart above:</p>
<figure>
<div id="court-of-other-cases">
<p>select court, count(*) as count from (select court from decisions order by importance desc limit 1000) x group by court having count &lt;= 20 and count &gt; 5;</p>
<script>
    pieChart(
      "#court-of-other-cases",
      "/data/1612753494.csv",
      d => d.court,
      d => d.count)
  </script>
</div>
<figcaption>
Drilling down on the “other” category
</figcaption>
</figure>
<p>It surprising to me that Ontario and Quebec are so underrepresented in their number of important cases, compared to their populations and age. I don’t know what’s going on here — please let me know if you do, gentle reader.</p>
<p>The other big question I have is to what degree this importance factor is biased by the courts’ continuous coverage. That is to say, of the most important cases identified, how many of them are from before CanLII started continuous coverage?</p>
<!--
select count(*) as count, c.year from decisions d inner join coverage c on d.court = c.court where d.hash in (select hash from decisions where court != 'scc' order by importance desc limit 1000) and d.year < c.year;
-->
<p>Only 13 of the top 1000 (1.3%) cases are from before the year of continuous coverage. This doesn’t jive with my intuition — presumably the cases which are on CanLII before the date of continuous coverage <em>are the most important ones.</em> They’re the cases that someone went in and added manually, before the system was set up to track this stuff automatically.</p>
<p>OK, so the importance metric is clearly biased against old cases. But is it also biased against <em>new</em> cases? Let’s look at the number of top important cases by year:</p>
<figure>
<div id="new-bias">
<p>select year, count(*) as count from decisions where hash in (select hash from decisions order by importance desc limit 1000) group by year;</p>
<script>
    lineChart(
      "#new-bias",
      "/data/1612754087.csv",
      "Year",
      d => +parseInt(d.year),
      "Number of Important Cases",
      d => +parseInt(d.count))
  </script>
</div>
<figcaption>
Number of top 1000 important cases, by year
</figcaption>
</figure>
<p>Rather surprisingly, it doesn’t seem to be. I’d expect newer cases to not have had time to accumulate citations, and to thus be biased-against in the importance metric. So what’s going on here? It’s that I slightly lied to you earlier; that our importance metric doesn’t take into account the direction of the citation. In essence, it means that you get the same amount of influence for citing important cases as you would for important cases citing you. This is often a better approach than the directed version for datasets in which there are no loops. In the absence of loops (where X cites Y which cites Z which cites X again,) all of the influence gets pooled at the very oldest cases, and in effect tracks progeny.</p>
<p>Switching to this directed importance metric will likely show the bias against recency that we’d expect to see. So let’s look at that same chart as before, except using the directed importance metric instead:</p>
<figure>
<div id="dimportance">
<p>select year, count(*) as count from decisions where hash in (select hash from decisions order by dimportance desc limit 1000) group by year;</p>
<script>
    lineChart(
      "#dimportance",
      "/data/1612754125.csv",
      "Year",
      d => +parseInt(d.year),
      "Number of Important Cases",
      d => +parseInt(d.count))
  </script>
</div>
<figcaption>
Number of top 1000 important cases with the directed importance metric, by year
</figcaption>
</figure>
<!-- TODO(sandy): add support for missing data to lineChart -->
<p>This metric nicely prioritizes old cases, like our previous metric emphasized newer cases. In fact, the directed importance score puts 865 of the its top 1000 (86.5%) cases before the date of continuous coverage.</p>
<p>We’d be very happy if we could somehow mix the two metrics together to get an importance score that has no time-bias. Unfortunately, it’s unclear to me how to combine the two together; we probably can’t meaningfully add eigenvalues — but let’s try it anyway.</p>
<figure>
<div id="both-importance">
<p>select year, count(*) as count from decisions where hash in (select hash from decisions order by importance + dimportance desc limit 1000) group by year;</p>
<script>
    lineChart(
      "#both-importance",
      "/data/1612754230.csv",
      "Year",
      d => +parseInt(d.year),
      "Number of Important Cases",
      d => +parseInt(d.count))
  </script>
</div>
<figcaption>
Number of top 1000 important cases with the sum importance metric, by year
</figcaption>
</figure>
<p>I don’t know if this is meaningful. It seems unlikely that there was a period of 40 years from 1940 to 1980 in which no important decisions were made — but then I realized this corresponds pretty closely when with Canada became a Commonwealth nation (1931) and when it became sovereign (1982). To quote the <a href="https://www.history.com/news/canada-independence-from-britain-france-war-of-1812">first link on Google I found</a>:</p>
<blockquote>
<p>In 1931, England put Canada on equal footing with other Commonwealth countries through the Statute of Westminster, which essentially gave its dominions full legal freedom and equal standing with England and one another. However, Britain still had the ability to amend the Canadian constitution, and <strong>Canada took time to cut its legal ties to England</strong>. Meanwhile, it adopted its own national symbols, like the Canadian flag, featuring the maple leaf, which debuted in 1965.</p>
<p>It took five decades after the Statute of Westminster for Canada to make its final step toward full sovereignty. In 1982, it adopted its own constitution and became a completely independent country.</p>
</blockquote>
<p>Emphasis mine. Maybe this “taking its time” stuff was just Canada coasting? Hopefully the law and/or history people can get in touch and let me know if this graph of mine is at all meaningful. This is flaw in the data-driven approach — your analysis can only be as good as your data is. We’re always going to need subject matter experts.</p>
<h2 id="discovering-neighborhoods">Discovering Neighborhoods</h2>
<p>Imagine I give you a map of the world’s road network, with all of the topological features like water and altitude removed, as well as all landmarks and zoning information. For example:</p>
<p><img src="/images/law/city.png" style="width: 100%"></p>
<p>There are two cities on this map. It’s not very hard to spot them, is it? The cities are exceptionally dense networks of roads, compared to the relatively spare highways that connect them.</p>
<p>Interestingly, this same phenomenon occurs within cities:</p>
<p><img src="/images/law/neighborhood.png" style="width: 100%"></p>
<p>It’s easy to find downtown on this map, and if you pay attention to what are obviously bridges, you can find the smaller cities that make up the big metropolitan area. Again, the trick is to identify areas that have tightly woven intra-road networks, but relatively sparse interconnections.</p>
<p>We can use this same trick to identify “neighborhoods” of law — that is, clusters of cases that commonly cite one another, but which rarely cite other neighborhoods. <a href="https://en.wikipedia.org/wiki/Louvain_method">Our algorithm</a> starts by putting every case in its own (very lonely) community, and then merging communities which are more interconnected than should be expected by random.</p>
<p>After crunching the numbers, the five most important decisions in each of our three most important, highly-populated communities are:</p>
<h3 id="community-249">Community 249</h3>
<ul>
<li>
<a href="https://canlii.org/en/ca/scc/doc/2008/2008scc9/2008scc9.html">Dunsmuir v. New Brunswick</a>
</li>
<li>
<a href="https://canlii.org/en/ca/scc/doc/2009/2009scc12/2009scc12.html">Canada (Citizenship and Immigration) v. Khosa</a>
</li>
<li>
<a href="https://canlii.org/en/ca/scc/doc/1999/1999canlii699/1999canlii699.html">Baker v. Canada (Minister of Citizenship and Immigration)</a>
</li>
<li>
<a href="https://canlii.org/en/ca/scc/doc/2011/2011scc62/2011scc62.html">Newfoundland and Labrador Nurses’ Union v. Newfoundland and Labrador (Treasury Board)</a>
</li>
<li>
<a href="https://canlii.org/en/ca/scc/doc/2011/2011scc61/2011scc61.html">Alberta (Information and Privacy Commissioner) v. Alberta Teachers’Association</a>
</li>
</ul>
<p>In order to try and figure out what community this is (249 isn’t a <em>great</em> name<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a>), I clicked on each CanLII link and read (with my <em>eyes,</em> like a <em>peasant</em>) the tags that whoever filed these cases wrote down. They are:</p>
<ul>
<li>Administrative law – Procedural fairness</li>
<li>Administrative law – Review of discretion – Approach to review of discretionary decision making.</li>
<li>Administrative law – Judicial review – Implied decision</li>
<li>Administrative law – Judicial review – Standard of review</li>
<li>Administrative law – Natural justice – Procedural fairness</li>
<li>Administrative law – Role and adequacy of reasons – Procedural fairness</li>
<li>Administrative law – Standard of review</li>
<li>Courts – Appellate review</li>
</ul>
<p>Looks like community 249 is really some sort of administrative review of law.</p>
<p>Remember, I only looked at these tags in order to try to give a human-appropriate name to community 249. The computer didn’t have access to these tags when it was discovering it; it was merely looking at where the roads are dense.</p>
<h3 id="community-527">Community 527</h3>
<ul>
<li>
<a href="https://canlii.org/en/ca/scc/doc/1986/1986canlii46/1986canlii46.html">R. v. Oakes</a>
</li>
<li>
<a href="https://canlii.org/en/ca/scc/doc/1985/1985canlii69/1985canlii69.html">R. v. Big M Drug Mart Ltd.</a>
</li>
<li>
<a href="https://canlii.org/en/ca/scc/doc/1985/1985canlii81/1985canlii81.html">Re B.C. Motor Vehicle Act</a>
</li>
<li>
<a href="https://canlii.org/en/ca/scc/doc/1989/1989canlii2/1989canlii2.html">Andrews v. Law Society of British Columbia</a>
</li>
<li>
<a href="https://canlii.org/en/ca/scc/doc/1989/1989canlii87/1989canlii87.html">Irwin Toy Ltd. v. Quebec (Attorney General)</a>
</li>
</ul>
<p>The tags here are:</p>
<ul>
<li>Constitutional law – Canadian Charter of Rights and Freedoms</li>
<li>Constitutional law – Charter of Rights – Application</li>
<li>Constitutional law – Charter of Rights – Freedom of expression</li>
<li>Constitutional law – Charter of Rights – Fundamental justice</li>
<li>Constitutional law – Charter of Rights – Presumption of innocence</li>
<li>Constitutional law – Charter of Rights – Reasonable limits</li>
</ul>
<p>Seems pretty cut and dried. “Charter of Rights.”</p>
<h3 id="community-192">Community 192</h3>
<ul>
<li>
<a href="https://canlii.org/en/ca/scc/doc/1984/1984canlii33/1984canlii33.html">Hunter et al. v. Southam Inc.</a>
</li>
<li>
<a href="https://canlii.org/en/ca/scc/doc/1987/1987canlii84/1987canlii84.html">R. v. Collins</a>
</li>
<li>
<a href="https://canlii.org/en/ca/scc/doc/2009/2009scc32/2009scc32.html">R. v. Grant</a>
</li>
<li>
<a href="https://canlii.org/en/ca/scc/doc/1997/1997canlii384/1997canlii384.html">R. v. Stillman</a>
</li>
<li>
<a href="https://canlii.org/en/ca/scc/doc/1990/1990canlii52/1990canlii52.html">R. v. Garofoli</a>
</li>
</ul>
<p>With tags:</p>
<ul>
<li>Constitutional law – Canadian Charter of Rights and Freedoms – Unreasonable search and seizure</li>
<li>Constitutional law – Charter of Rights – Admissibility of evidence</li>
<li>Constitutional law – Charter of Rights – Arbitrary detention</li>
<li>Constitutional law – Charter of Rights – Enforcement — Exclusion of evidence</li>
<li>Constitutional law – Charter of Rights – Search and seizure</li>
<li>Constitutional law – Charter of Rights – Security of person</li>
<li>Constitutional law – Charter of Rights – Unreasonable search and seizure</li>
<li>Criminal law – Interception of private communications – Access to sealed packet – Validity of wiretap authorizations</li>
<li>Criminal law – Interception of private communications – Admissibility of evidence</li>
<li>Criminal law – Power of search incidental to arrest</li>
</ul>
<p>This one is very clearly on the police being naughty and doing things they shouldn’t.</p>
<p>I’ve said it before but I’m going to say it again. There is <em>very clearly</em> a theme in these cases, and <em>we found it using only math, with absolutely no knowledge of the law.</em></p>
<h3 id="continuing-analysis-of-communities">Continuing Analysis of Communities</h3>
<p>Just for fun, let’s chart decisions by year and community for the six most populated communities.</p>
<figure>
<div id="chart-importance">
<p>select name, year, importance, community from decisions where community in (19, 192, 225, 249, 527, 635) order by importance desc limit 500;</p>
<script>
    dotChart(
      "#chart-importance",
      "/data/1612756205.csv",
      d => +d.year,
      d => +d.community,
      d => parseFloat(d.importance).toFixed(4),
      d => +d.community,
      d => truncateString(d.name, 80))
  </script>
</div>
<figcaption>
Important cases by year and community. Larger dots are more important. Community is on the Y axis.
</figcaption>
</figure>
<p>This gives us a sense of what sorts of things the law is focused on over time. For example, since 2010 there’s been a huge flurry of activity in community 249 (review of law.) Why? I don’t know, but clearly something is going on. The activity seems to be precipitated by <em>Dunsmuir v. New Brunswick,</em> so what we’re seeing is all the fallout from that case.</p>
<p>And we can see that community 192 (police being naughty) was very active from 1985 to 1995, but quieted down until a spike in 2009, and has been quiet since 2014. Maybe the police have been on good behavior since then?</p>
<h2 id="conclusion">Conclusion</h2>
<p>I’ve now been writing for eight hours straight, and I can no longer reliably spell “jurisdiction.” So it’s time to finish this up and then go directly to bed.</p>
<p>Personally, I find it fascinating just how much information can be gleamed from nothing but citation data and some clever choices of visualizations. The biggest takeaways in terms of policy from this project in my opinion are:</p>
<ul>
<li>The amount of case law is growing super-linearly — and, horrifyingly, the curve appears to be exponential. Despite every court generating law at a constant rate, the growth rate of courts themselves is increasing. <em>This is clearly an untenable system.</em></li>
<li>Most decisions become irrelevant after only one year; the vast majority of hem are forgotten after ten.</li>
<li>Somewhere between 33% and 50% of all decisions just follow precedent. That’s a waste of everyone’s time and the countries resources. There are huge efficiencies to be gained here if we can find a way of automating that stuff.</li>
</ul>
<p>In aggregate, this means our legal system is doing a huge amount of work churning out an ever growing number of decisions which get added to the annals of time — a good chunk of which are completely trivial, and almost all of which are forgotten soon after. This is extremely good evidence that the court system structuring itself as an <a href="https://en.wikipedia.org/wiki/Append-only">append-only datastructure</a> is a bad design. There’s no reason to continuously write down the answer you already know, and never check it again; automate that stuff, don’t add it to the corpus of law, and save the courts for more important matters.</p>
<p>While we’re talking about automating things, someone could <em>definitely</em> use the community-finding algorithm to put the poor bastard responsible for adding keywords to case summaries out of his misery.</p>
<p>Some intriguing takeaways, with no relevance to anything:</p>
<ul>
<li>There appear to be many extremely important decisions (in terms of influence) that are not well-enough recognized to be on Wikipedia. Is this a flaw in Wikipedia’s coverage, or is the importance of these cases unknown to the world of law?</li>
<li>This math stuff is actually useful for real-life things.</li>
</ul>
<p>If you’re interested in running your own analysis on this data without needing to scrape CanLII for a few weeks, <a href="https://mega.nz/file/YBomET6L#M2oBRiIRQTN_YJ4eiFiDjlkdNrEf8jbQG2a0wLkahNs">it’s available as a sqlite3 database.</a> Hidden in the HTML of this page are all of the queries I ran to produce the graphs. Feel free to get in touch if you find anything interesting, I’d be happy to update this page with, or linking to, your discoveries.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>Due to the differing dates of continuing coverage, we unfortunately can’t look at this metric over the history of Canadian law.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>In a pre-print of this essay that contained only half of the dataset, 42 of the top 50 had Wikipedia articles. Of these cases, 31 were “leading” or “landmark.” It’s not clear to me why this metric degraded when adding more data, except possibly that the inclusion of more cases has brought out connections that are harder for humans to keep track of. I’m very confident in the math here.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>I’d like to have checked a few thousand, but this is a very manual process.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>“There are only two hard things in Computer Science: cache invalidation and naming things.” –Phil Karlton<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
      ]]></content:encoded>
  </item>
  <item>
      <title>I Built a Terrible Roomba</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>http://reasonablypolymorphic.com/blog/roomba/index.html</link>
      <guid>http://reasonablypolymorphic.com/blog/roomba/index.html</guid>
      <pubDate>2021-01-23T16:10:00Z</pubDate>
      <content:encoded><![CDATA[
        <p>I spent the last few months making a roomba. I mean, sorta. I made a robot that wanders around and ostensibly vacuums as it goes. But it gets stuck on things all the time, and the floor isn’t particularly clean by the time it runs out of batteries. Nevertheless, it was an experience<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> and I learned a lot, so I though it would be a good idea to document. Consider the following a devlog, one that might be interesting for the historical record — but which I don’t suggest following to build your own roomba.</p>
<p>This all started when I googled for “fun robot projects,” and came across this <a href="https://www.youtube.com/watch?v=FUUPcwtkDQw">terrible video</a>. It goes through building a little roomba life-hack-style, which is to say, in absolutely no detail but vaguely making the whole procedure look simple. They use some cardboard and a cup-noodle container, so I thought “how hard could this be?” What I didn’t notice at the time was how the thing they build is not the thing they demo, nor how there are crucial components that are completely disconnected. As it happens, this video is completely smoke and mirrors.</p>
<p>I’d picked up some motors and a motor controller for a previous, <a href="https://sandymaguire.me/blog/mastery-skateboard/">ill-fated project</a>. And I had an old sonar module lying around in order to do the range finding. So I figured all that was left was a cup-noodles container and a fan, and I’d be on my merry way.</p>
<p>Stupidly, I decided I wasn’t going to make this thing out of cardboard. I was going to design and 3D print the chassis and all of the fiddly little bits it would require. My 3D printer’s bed is 22cm square, which meant anything I wanted to make was going to need to be smaller than that. My first prototype was shaped like a flying disc, with a hole in the middle to put the noodles container, but I learned the hard way that there simply wasn’t enough floor-space on the disc to fit all of the necessary electronics. Back to the drawing board.</p>
<p>I farted around with the base plate design for like a month, trying things. In the meantime, I picked up some CPU fans, assuming that all fans are made equally. This is not true — CPU fans are good at moving air, but not good at, uh… pressurizing air? or something? The idea is that a CPU fan won’t force air somewhere it doesn’t want to go, for example, into a vacuum bag. For that you want a blower fan, but I spent $50 buying the wrong sorts of fans on amazon before I figured this out.</p>
<p>Fans are measured in CFM, which is some sort of non-standardized measurement of “cubic feet per minute.” How much more imperial can you get? Non-standardized here means that all fan manufactures have a different procedure for measuring the CFM, so you can’t just compare numbers. That would be too easy.</p>
<p>It took many weeks of not having my roomba suck enough before I realized that fans move a constant <em>volume</em> of air, <strong>not</strong> a constant <em>mass.</em> The difference is that, unless you have really good intake to your fan, it’ll just make your vacuum chamber really low pressure, and not actually translate into sucking hard at the nozzle. I sorta worked around this by just mounting the fan directly above the vacuum bag, which had a small cut-out to pull debris through. Pipes seem to be anathema to small fans that you’re trying to use as vacuum pumps.</p>
<p>I tried using some agitators to improve my suction by getting things moving. My first attempt was via a gear train that I didn’t realize was 10RPM — way too damn slow to get anything moving. I didn’t feel like waiting around for another amazon shipment, so I just tried running my 12V 2000RPM DC motors at 3V. It sorta worked, but the handmade brushes I built dissolved themselves by still spinning too fast. Since it didn’t seem to improve the suction by much, I ended up scrapping this idea.</p>
<p>While trying to prototype something together with alligator clamps, I accidentally shorted my battery and caused no-small amount of smoke and did some unintentional welding. Thankfully it didn’t explode! I <em>was</em> doing stupid, unsafe things with the battery, but I learned the wrong lesson from this — that I should properly solder all of my connections, even when prototyping. What I should have learned instead was to make a really safe breakout connector for my battery, and then play fast and loose with crimps and connectors from there. But I didn’t yet know about crimps and connectors, so I just hand-soldered everything. It took forever and my productivity went asymptotically towards zero. Especially because I didn’t yet know what I was making, so there was a <em>lot</em> of soldering and desoldering and resoldering.</p>
<p>To make things worse, I kept 3D printing half-figured out chassis — each one of which took like nine hours to print. Inevitably some part wouldn’t fit, or the suction would be off, or some other problem would arise. Cardboard next time, my dude.</p>
<p>Oh, and did I mention that I don’t know how to connect physical things, so I just ended up hot-glueing everything together? Like, <em>everything.</em></p>
<p>One day I was hanging out on IRC, describing my project when Julia Longtin said “oh my god STOP. You’re going to burn down your house!” She had correctly noticed that I hadn’t put a battery management system in front of my battery. If you’re a hobbyist like I am, you might not know that LiPo batteries have a bad habit of catching on fire when you charge them after letting their voltage drop too low. A BMS board watches the voltage on the battery and cuts the circuit before it gets dangerously low. When testing this thing (after the BMS was installed,) it turned off quite often, so I’m pretty sure Julia saved me a ton in fire insurance claims. Thanks Julia!</p>
<p>The roomba’s only sensor is a sonar module that shoots sound waves and listens to hear when they come back. It’s essentially echo-location, like what bats have. Unfortunately for me, we also have the expression “blind as a bat,” which pretty adequately describes the robot. Sonar is a neat idea in theory, but in practice it only reliably works up to about a foot in front, and cloth-covered things like sofas muffle it. When added to the fact that DC motors offer no feedback if they’re stalled, it meant my roomba couldn’t detect if it were moving down a long hallway or stuck trying to drive into the couch. These are two scenarios you really want different behaviors for.</p>
<p>But even worse, due to my design and the limitations of my 3D printer bed, I couldn’t figure out how to fit the wheels inside the robot and still get all of the electronics and vacuum supplies on-board. As a compromise, the rubber tires jut out about two centimeters. Which is just about ideal for getting caught on chair legs and errant cables and walls and stuff like that. So if he hit the wall at a 45 degree angle, he’d just get wedged there. And at 45 degrees, sonar just bounces off of walls and doesn’t return, so again, you don’t know you’re stuck.</p>
<p>What a piece of work.</p>
<p>The software on this thing is a big state machine with things like “drive forward” and “bounce off of driving straight into the wall” and “try relocate because you’ve been stuck in the couch for too long.” I expected the software to be the easiest part of this project, since I’m an ex-professional software engineer. But not so! Even after you discount the time I accidentally melted my Arduino — by… well, I’m not sure what, but definitely related to plugging it into the computer — the software didn’t go smoothly. Arduino has this annoying forced event loop where it calls <code>loop()</code> just as fast as it can, and you can push back with a <code>delay(long milliseconds)</code> function call. But it’s all in C++ (but without the STL) and so getting any real work done is annoying. And have you ever tried to write a proper state machine without algebraic data types? I walked away with the impression that I’m going to need to do a lot of work improving the software end of things before I do another serious project with Arduino.</p>
<p>In short, I spent a few months accidentally setting stuff on fire, waiting too long for the wrong 3D shapes to print, and I all I got was this stupid T-shirt. But I guess that’s what learning feels like. But I’ve already bought a LIDAR module and some bumpers for mk 2, so maybe I’m just a glutton for punishment.</p>
<p>If you’re curious about actually building this thing, here’s all of the source materials. But please, do yourself a favor and don’t put yourself through the mental turmoil of trying to get it to work.</p>
<h2 id="building-one-for-yourself">Building One For Yourself</h2>
<p>Don’t. But if you do, you’ll need these parts:</p>
<h3 id="bill-of-materials">Bill of Materials</h3>
<ul>
<li><a href="https://www.amazon.ca/gp/product/B07DQGX369/ref=ppx_yo_dt_b_asin_title_o00_s00?ie=UTF8&amp;psc=1">Motor wheels</a></li>
<li><a href="https://www.amazon.ca/gp/product/B07D1HP3SJ/ref=ppx_yo_dt_b_asin_title_o05_s00?ie=UTF8&amp;psc=1">L298N</a></li>
<li><a href="https://www.amazon.com/SainSmart-HC-SR04-Ranging-Detector-Distance/dp/B004U8TOE6">HC-SR04</a></li>
<li><a href="https://www.amazon.ca/gp/product/B07RM573HD/ref=ppx_yo_dt_b_asin_title_o03_s00?ie=UTF8&amp;psc=1">4S BMS Board</a></li>
<li><a href="https://www.amazon.ca/gp/product/B08CMNTBB2/ref=ppx_yo_dt_b_asin_title_o00_s00?ie=UTF8&amp;psc=1">12V, 1A, 36.2CFM Blower fan</a></li>
<li><a href="https://www.amazon.ca/gp/product/B07KC9C6H5/ref=ppx_yo_dt_b_asin_title_o08_s00?ie=UTF8&amp;psc=1">Arduino Nano</a></li>
<li><a href="https://www.amazon.ca/gp/product/B07JNQFV7F/ref=ppx_yo_dt_b_asin_title_o09_s00?ie=UTF8&amp;psc=1">2x LM2596 DC to DC buck converter</a></li>
<li><a href="https://www.amazon.ca/gp/product/B072M9S2CQ/ref=ppx_yo_dt_b_asin_title_o04_s01?ie=UTF8&amp;psc=1">Ball bearing</a></li>
<li><a href="https://www.amazon.ca/gp/product/B0784BB8F5/ref=ppx_yo_dt_b_asin_title_o04_s02?ie=UTF8&amp;psc=1">14.8V RC LiPo battery</a></li>
<li><a href="https://www.amazon.ca/Gikfun-1N4007-Plastic-Rectifier-Arduino/dp/B01K77YVUA/ref=sr_1_1?dchild=1&amp;keywords=diode&amp;qid=1611443750&amp;s=electronics&amp;sr=1-1">Diode</a></li>
<li><a href="https://www.amazon.ca/gp/product/B01N2U8PK0/ref=ppx_yo_dt_b_asin_title_o09_s00?ie=UTF8&amp;psc=1">Flip switch</a></li>
<li><a href="https://www.amazon.ca/gp/product/B01N8VV78D/ref=ppx_yo_dt_b_asin_title_o01_s00?ie=UTF8&amp;psc=1">5.5mm DC jack female</a></li>
<li><a href="https://www.amazon.ca/gp/product/B07DHMGWVG/ref=ppx_yo_dt_b_asin_title_o01_s00?ie=UTF8&amp;psc=1">15V DC power supply</a></li>
</ul>
<h3 id="d-printed-parts">3D Printed Parts</h3>
<p>The whole thing is written in a Haskell DSL for 3D printing called <a href="http://www.implicitcad.org/">ImplicitCAD</a>, because of course it is. Have you met me? The source code is available <a href="https://github.com/isovector/cad-models/blob/9a4eb494690293ee5c42859da1ae96d2b99b6840/src/Roomba3.hs">here</a>, where everything definition prefixed with <code>final_</code> needs to be printed.</p>
<p>Oh yeah, and even after being very careful to model the negative space necessary for the fan’s exhaust, I forgot to connect that to the body of the roomba, so I needed to cut the exhaust hole out with my soldering iron. The resulting smoke was pretty noxious, so I just tried to not breathe too hard.</p>
<h3 id="source-code">Source Code</h3>
<p><a href="https://github.com/isovector/arduino/tree/f8fe8a7de609bbdd9264243839d29c1d854f2e73/roomba">Here’s the code</a> I wrote for this thing. It’s not beautiful, and shouldn’t be considered as evidence as to how I write real code that I care abut. Sorry not sorry.</p>
<h3 id="schematic">Schematic</h3>
<figure>
<img src="/images/roomba.png" alt="" /><figcaption>Roomba schematic</figcaption>
</figure>
<p>What’s labeled as the voltage source here should instead be the BMS. And no promises that the pins on the Arduino correspond exactly with what the source code actually does. I think it’s right, but the roomba might drive backwards.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>I’m hesitant to call it a <em>good</em> experience.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
      ]]></content:encoded>
  </item>
  <item>
      <title>Haskell in the Real World</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>http://reasonablypolymorphic.com/blog/3d-printing/index.html</link>
      <guid>http://reasonablypolymorphic.com/blog/3d-printing/index.html</guid>
      <pubDate>2020-11-25T14:00:00Z</pubDate>
      <content:encoded><![CDATA[
        <p>I had a delightful experience this morning, where I fixed a real world problem in my life with Haskell. It’s rare that I actually get to <em>use</em> this stuff I spend so much time thinking about, so thought it would make a nice and quick blog post.</p>
<h2 id="the-problem">The Problem</h2>
<p>My apartment used to have some crappy roll-down blinds, which did absolutely nothing for blocking out early morning light. As the master of my domain, I took them down and installed more traditional curtains in their place, held up by a tension rod. My tension rod is tensioned between the mounting plates for the old blinds, which are metal. Unfortunately, the rubber pads of the tension rod don’t get much of a purchase on the metal, and so my curtains fall down once a week or so.</p>
<p>They fell down yesterday, and I resolved that would be the last time.</p>
<h2 id="the-solution">The Solution</h2>
<p>I’ve recently bought a 3D printer, and like most new technology, it has taken some time to acclimatize to. Having a mini-factory in your house is probably pretty powerful, but so far I’ve just been looking for excuses to use it. There are lots of weird projects on <a href="https://www.thingiverse.com/">Thingiverse</a> that I keep trying to convince myself I need in my apartment.</p>
<p>But today was a turning point. The slippery mounting plate has some holes in it — so I realized I could manufacture a bracket that would sit in the mounting plate and prevent my tension rod from falling again.</p>
<figure>
<img src="/images/mounting-bracket.jpg" alt="" /><figcaption>The mounting plate</figcaption>
</figure>
<p>Armed with my <a href="https://www.amazon.ca/Digital-Measuring-Calipers-Conversions-Diameter/dp/B088R4XFBN">digital calipers</a>, I took some measurements of the plate, and quickly whipped up a CAD model using the <a href="https://github.com/colah/ImplicitCAD"><code>implicit</code> library</a> — a library for doing CAD modeling in Haskell:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Graphics.Implicit</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>main <span class="ot">=</span> writeSTL <span class="fl">0.25</span> <span class="st">&quot;/tmp/mount.stl&quot;</span> <span class="op">$</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>  <span class="kw">let</span> base <span class="ot">=</span> center3 <span class="op">$</span> union</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>        [ slamBack <span class="op">$</span> slamTop <span class="op">$</span> centeredBox <span class="dv">40</span> <span class="dv">40</span> <span class="dv">6</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>        , slamBack <span class="op">$</span> slamBottom <span class="op">$</span> centeredBox <span class="dv">9</span> <span class="fl">3.7</span> <span class="dv">6</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>        ]</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>   <span class="kw">in</span> difference</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a>        [ slamFront <span class="op">$</span> difference</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a>          [ slamBottom <span class="op">$</span> union</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a>            [ mirror (<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>) base</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a>            , mirror (<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>) base</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a>            , base</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true"></a>            ]</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true"></a>          , translate (mk3 <span class="dv">0</span> <span class="dv">0</span> (<span class="op">-</span><span class="dv">6</span>))</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true"></a>              <span class="op">$</span> slamBottom</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true"></a>              <span class="op">$</span> cylinder (<span class="dv">33</span> <span class="op">/</span> <span class="dv">2</span>) <span class="dv">10</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true"></a>          , translate (mk3 <span class="dv">0</span> (<span class="op">-</span><span class="dv">3</span>) (<span class="op">-</span><span class="dv">6</span>))</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true"></a>              <span class="op">$</span> slamBottom</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true"></a>              <span class="op">$</span> cylinder (<span class="dv">33</span> <span class="op">/</span> <span class="dv">2</span>) <span class="dv">10</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true"></a>          ]</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true"></a>        , slamFront <span class="op">$</span> slamBottom <span class="op">$</span> centeredBox <span class="dv">40</span> <span class="fl">14.5</span> <span class="dv">6</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true"></a>        ]</span></code></pre></div>
<p>This program isn’t going to win any awards and the magic numbers are petrifying. But it’s OK, because it saves to <code>/tmp</code> anyway. The result is a little bracket that sits inside of the holes of the mounting plate and prevents the tension bar from moving.</p>
<p>The tension of the rod pushes the pins into the holes, which prevent the bracket from falling, which in turn holds up the tension rod. Amazing, really.</p>
<figure>
<img src="/images/bracket-top.png" alt="" /><figcaption>Tension rod slot</figcaption>
</figure>
<figure>
<img src="/images/bracket-bottom.png" alt="" /><figcaption>Mounting pins</figcaption>
</figure>
<p>An hour of printing later, and my new brackets were done. They fit into the holes just fine, and I can rest soundly knowing that the darkness of my room is forever safeguarded.</p>
      ]]></content:encoded>
  </item>
  <item>
      <title>Separate Your Views; Reify Your Reasoning</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>http://reasonablypolymorphic.com/blog/separate-your-views-reify-your-reasoning/index.html</link>
      <guid>http://reasonablypolymorphic.com/blog/separate-your-views-reify-your-reasoning/index.html</guid>
      <pubDate>2020-11-09T21:45:00Z</pubDate>
      <content:encoded><![CDATA[
        <p>Continuing our discussion of tactics, today I’d like to talk about my recent diff on <a href="https://github.com/haskell/haskell-language-server/tree/master/plugins/tactics">hls-tactics-plugin</a>. I learned a deep lesson about writing software in this commit and wanted to share the insight.</p>
<p>Some background before we get started. The <code>hls-tactics-plugin</code> is capable of automatically generating small snippets of Haskell code. Like how, near the end of a proof, mathematicians will throw their hands in the air and say “the remainder is obvious,” we’d like to empower software engineers in the same way. The idea is for the computer to pick up where you left off, and fill in expressions that have a uniquely best solution (for some meaning of “best”.) In practice, it works quite well.</p>
<p>To make this happen, we need to know the desired type at the hole to be filled, as well as what’s in scope, and various other pieces of metadata — such as what’s already been used and where values came from. The record for this data is called the <code>Judgment</code>, and originally looked like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Judgment</span> <span class="ot">=</span> <span class="dt">Judgment</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>  {<span class="ot"> _jHypothesis        ::</span> <span class="dt">Map</span> <span class="dt">OccName</span> <span class="dt">Type</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>  ,<span class="ot"> _jAmbientHypothesis ::</span> <span class="dt">Map</span> <span class="dt">OccName</span> <span class="dt">Type</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>  ,<span class="ot"> _jDestructed        ::</span> <span class="dt">Set</span> <span class="dt">OccName</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>  ,<span class="ot"> _jPatternVals       ::</span> <span class="dt">Set</span> <span class="dt">OccName</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>  ,<span class="ot"> _jPositionMaps      ::</span> <span class="dt">Map</span> <span class="dt">OccName</span> [[<span class="dt">OccName</span>]]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>  ,<span class="ot"> _jAncestry          ::</span> <span class="dt">Map</span> <span class="dt">OccName</span> (<span class="dt">Set</span> <span class="dt">OccName</span>)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>  ,<span class="ot"> _jBlacklistDestruct ::</span> <span class="dt">Bool</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>  ,<span class="ot"> _jWhitelistSplit    ::</span> <span class="dt">Bool</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a>  ,<span class="ot"> _jIsTopHole         ::</span> <span class="dt">Bool</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a>  ,<span class="ot"> _jGoal              ::</span> <span class="dt">Type</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a>  }</span></code></pre></div>
<p>As you can probably tell, this data structure grew organically, one field and feature at a time. The only truly necessary fields are <code>_jHypothesis</code> and <code>_jGoal</code>, the first of which tracks what’s in scope and its type, and the second tracks the type we’re currently trying to synthesize a value of. The rest of this stuff is used exclusively for intelligently narrowing the exponentially large space of possible solutions we could generate. They’re necessary for getting fast/good results, but in essence, just track heuristics that in practice help get the right answer. There’s no <em>theoretical justification</em> for them. As such, these fields are <strong>properties of the implementation, not of the domain.</strong></p>
<p>This is an extremely important realization. Fields like <code>_jDestructed</code> and <code>_jAncestry</code> are <a href="https://www.youtube.com/watch?v=GqmsQeSzMdw">exploded views</a> on our data. They exist in a non-compositional form, serving only to the ad-hoc queries I’ve thought of today, and are likely unhelpful for whatever search heuristic I decide to implement next. To illustrate this, <code>_jPatternVals</code> tracks which values came from bindings in a pattern match (useful for generating structurally-smaller recursive terms), while <code>_jAncestry</code> tracks if a value is descendant from another in some way. And <code>_jDestructed</code> records whether or not we’ve already pattern matched on any particular values. Clearly, there is a lot of overlap in these fields. Taken in aggregate, they feel like a myopic, denormalized representation of data provenance.</p>
<p>As a general rule, I tend to have a great distrust in denormalized representations. By their very nature, they blur the notion of <em>source of truth</em> — whom should you believe if your denormalized data sources disagree with one another? Furthermore, almost no human domains are intrinsically denormalized; it simply isn’t how our brains our wired — we like to think in deep notions of identity. These concerns together suggest that denormalized representations are, again, artifacts of the implementation, rather than meaningful carved joints in reality. Worse, it’s hard to initialize a non-empty denormalized system. Making sure all of the data sources agree is a bigger source of bugs than sprinkling sugar on your kitchen floor.</p>
<p>All of this is to say: why not just model the data provenance in <code>Judgment</code> directly? With that as an explicit source of data, it’s trivial to reimplement the fields like <code>_jAncestry</code> et al. as views over the real datastructure.</p>
<p>This is a greatly under-appreciated feature of Haskell’s record system. Because field selectors are just functions whose input is the record in question, there is no syntactic difference between them and arbitrary functions over the same record. Most other languages enforce a syntactic difference between class fields and class methods, which is where the <a href="https://en.wikipedia.org/wiki/Mutator_method">mutator method pattern</a> comes from. Like most software patterns, this one too is unnecessary in Haskell.</p>
<p>Instead, we can just remove the <code>_jAncestry</code> field from <code>Judgment</code>, and then implement a function <code>_jAncestry :: Judgment -&gt; Map OccName (Set OccName)</code> which computes the desired view from the data provenance. Amazingly, <em>all calling code will just work,</em> and doesn’t need to know that the underlying datastructure has changed.</p>
<p>Of course, the usual zealots will point out that the runtime performance will have changed through this transformation. And that’s probably true, but what’s also almost certainly true is that <em>it doesn’t matter.</em> It’s extremely unlikely that this field is the linchpin of my algorithm’s asymptotics, so don’t worry about it unless it becomes a problem. And if it does, I’m sure you can find a clever way of caching this field without confusing the fact that it is a view on data, and not data itself.</p>
<p>The crux of my change was to rip out all of my data views and add provenance to the hypothesis. The diff is delightfully red:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a> data Judgment = Judgment</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="st">-  { _jHypothesis        :: Map OccName Type</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="st">-  , _jAmbientHypothesis :: Map OccName Type</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a><span class="st">-  , _jDestructed        :: Set OccName</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a><span class="st">-  , _jPatternVals       :: Set OccName</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a><span class="st">-  , _jPositionMaps      :: Map OccName [[OccName]]</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a><span class="st">-  , _jAncestry          :: Map OccName (Set OccName)</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a><span class="va">+  { _jHypothesis        :: Map OccName (HyInfo Type)</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a>   , _jBlacklistDestruct :: Bool</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>   , _jWhitelistSplit    :: Bool</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a>   , _jIsTopHole         :: Bool</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a>   , _jGoal              :: Type</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a>   }</span></code></pre></div>
<p>Six denormalized fields replaced with one normalized source. This is already a huge improvement in terms of engineering confidence. The relationship between the many maps and sets of <code>OccName</code>s in the old system is inevitably going to be under-documented and implementation-defined. Even as the guy who wrote each of those features, I doubt I’d be able to create a well-formed <code>Judgment</code> by hand.</p>
<p>The next step was to implement <code>HyInfo</code>, which tracks the type and provenance of a value in the hypothesis:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">HyInfo</span> a <span class="ot">=</span> <span class="dt">HyInfo</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>  {<span class="ot"> hi_provenance ::</span> <span class="dt">Provenance</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>  ,<span class="ot"> hi_type       ::</span> a</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>  }</span></code></pre></div>
<p>To define <code>Provenance</code>, I added a data constructor for each different sort of value that I was aware of. By explicitly tagging all of this data, we can attach the previously-denormalized data that must exist, ensuring the entire datastructure is correct by construction.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Provenance</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">TopLevelArgPrv</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>      <span class="dt">OccName</span>   <span class="co">-- ^ Binding function</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>      <span class="dt">Int</span>       <span class="co">-- ^ Argument Position</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">PatternMatchPrv</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>      <span class="dt">PatVal</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">ClassMethodPrv</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>      <span class="dt">Class</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">DisallowedPrv</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>      <span class="dt">DisallowReason</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a>      <span class="dt">Provenance</span></span></code></pre></div>
<p>The arguments to <code>PatternMatchPrv</code> have been factored out into their own type, because pattern values are especially interesting and require further processing, outside the scope of this post. Of particular interest is <code>DisallowedPrv</code>, which we’ll discuss in a moment.</p>
<p>In the <code>hls-tactics-plugin</code> codebase, we made judicious use of a helper function <code>withHypothesis :: (Map OccName Type -&gt; Map OccName Type) -&gt; Judgment -&gt; Judgment</code>. Functions which, for example, wanted to introduce new values into the hypothesis (such as after pattern matching) would call <code>withHypothesis</code> and directly insert their values. If we wanted to exclude values from the search space, we’d just <code>withHypothesis . Map.filter</code> them out. The result was lots of call-sites directly fiddling with the state in unprincipled ways. Nobody actually needed the full power of <code>Map OccName Type -&gt; Map OccName Type</code>; it just happened to be the only convenient way of manipulating the hypothesis.</p>
<p>I removed <code>withHypothesis</code>, and instead replaced it with semantically meaningful functions, like <code>introduceLambdaValues</code>, <code>introducePatVals</code> and <code>disallowUsageOf</code>. The implementations hadn’t changed, but now they were encapsulated into a function call, rather than be scattered about at call sites.</p>
<p>The <code>disallowUsageOf</code> function is particularly interesting.</p>
<p>Besides the importance of normalization, this change taught me one other thing: the necessity of reifying your reasoning. Ollie Charles presents an excellent example of this in <a href="https://ocharles.org.uk/blog/posts/2019-08-09-who-authorized-these-ghosts.html">Who Authorized These Ghosts</a>, but I’d never fully appreciated the technique until now. The gist of it is that it’s important not just to track state, but also to track why you believe the state is what it is. In Ollie’s example, he’s tracking authorization status (a boolean,) but to prevent security holes, his application internally requires a token proving the user is allowed to act. This is <a href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/">parsing, not validating</a> taken to the extreme; programmers are required to produce a token to call privileged functions, and the only way of obtaining that token is by checking the authorization state.</p>
<p>The <code>disallowUsageOf</code> function, and corresponding <code>DisallowedPrv</code> provenance constructor above fill a very similar role.</p>
<p>Attentive readers will have noticed that the <code>_jDestructed</code> field is not truly a measure of provenance. In fact, it’s tracked exclusively to prevent production of code of the form:</p>
<pre><code>case x of
  Blah -&gt; case x of
    Blah -&gt; case x of
      Blah -&gt; ...</code></pre>
<p>However, a good heuristic when writing Haskell code is that if possible, a value should be used exactly one time. To a first approximation, we can produce a view of <code>_jDestructed</code> by checking to see if any <code>PatternMatchPrv</code> is a decedent of the value in question. However, this doesn’t work for types that don’t contain product types. For example, the matches of <code>Bool</code> are <code>True</code> and <code>False</code>; neither of which would produce a <code>PatternMatchPrv</code>.</p>
<p>But because <code>_jDestructed</code> is used only to prevent pattern matching, it filled a similar role to filtering out hypotheses via <code>withHypothesis</code>. In both cases we could have simply removed the value from hypotheses, and having removed it from the source of truth of what’s in scope would certainly prevent it from ever being used. But this also wreaked havoc with tracking provenance, as removing the value would also remove its provenance, so downstream children would become orphaned and wouldn’t know where they came from.</p>
<p>On the surface, this looks like a bug, but I don’t think it’s a bug in the true sense. Instead, this is a problem of insufficient reification. Removing a value from the in-scope set is again an <em>exploded view</em> of the data. It’s again not a feature of the problem, but the implementation. What we’d instead like to track is that a particular value is <em>disallowed,</em> rather than <em>non-existent.</em> And once something is declared disallowed, if we track the reason, later code can reevaluate for themselves whether that judgment is still a reasonable means for exclusion.</p>
<p>At the end of the day, I exposed a function <code>jHypothesis :: Judgment -&gt; Map OccName (HyInfo Type)</code> (not <code>_jHypothesis</code> — note the underscore!) which pro-actively filtered out all of the <code>DisallowedPrv</code> values in the <code>_jHypothesis</code>. This means the data that the <em>entire program sees is itself a view</em> on the real datastructure. Internally we can track disallowed values, and externally we don’t show the disallowed values unless explicitly asked for.</p>
<p>The result of all this refactoring is a delightfully simplified codebase. Its core datastructure is now correct-by-construction, meaning it’s impossible to produce an inconsistent value that was so common under the old formulation. Furthermore, no call-site needs to change; appropriate views on the data exist as shunts, invisible massaging the new datastructure into the old. These call-sites can (and should) be cleaned up to use the new datastructure more directly, but that can happen incrementally in subsequent changes. And best of all, our new data representation is infinitely more useful. Because it models the problem domain rather than the peculiarities of the implementation, it can be reused for future features. While the size of the old datastructure was <code>O(n)</code> in the number of features, this new one is <code>O(1)</code>.</p>
<hr />
<p>If you enjoyed this post, please consider picking up a copy of my new book <a href="https://algebradriven.design/">Algebra-Driven Design</a>. In it, you’ll learn techniques like this one to dramatically improve the quality, maintainability, and reusability of your software.</p>
      ]]></content:encoded>
  </item>
  <item>
      <title>Towards Tactic Metaprogramming in Haskell</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>http://reasonablypolymorphic.com/blog/towards-tactics/index.html</link>
      <guid>http://reasonablypolymorphic.com/blog/towards-tactics/index.html</guid>
      <pubDate>2020-10-12T00:40:00Z</pubDate>
      <content:encoded><![CDATA[
        <center>
<img src="/images/fmaptree.gif">
</center>
<p>Isn’t it weird that we treat source code as text? That is, we have this extremely well-structured and strongly-typed object — the abstract syntax tree — that exists conceptually in our minds, and in actuality inside of our compiler, but for some reason we pretend it’s just a pile of bytes and edit it byte-by-byte rather than semantically?</p>
<p>When you stop and think about it, that’s like the stupidest idea ever. We as the authors don’t think of our code as bytes, nor does our interpreter or compiler. But instead we take the semantic understanding inside of our heads, serialize it into bytes, and then get the compiler to parse and rediscover the ideas inside our head. What a waste of effort.</p>
<p>Instead, you can use the incredible <a href="https://totbwf.github.io/">TOTBWF</a> and my new Tactics Plugin for the <a href="https://github.com/haskell/haskell-language-server">Haskell Language Server</a>, which will automatically and intelligently fill holes in your Haskell programs.</p>
<p>This blog post describes what a tactics engine is and why you want one, and is a good introduction to how in the hell we can automatically write your code for you.</p>
<h2 id="tactics">Tactics</h2>
<p>Imagine you’re pair programming with a junior engineer. In the navigator seat, you’ll be guiding your partner through the implementation, guiding them through the high-level strokes and letting them actually do the coding part. In order to implement <code>foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b</code>, for example, the guidance you give your partner might be:</p>
<ol type="1">
<li>Bind the function arguments</li>
<li>Case split on the <code>[a]</code> parameter</li>
<li>If it’s <code>[]</code>, do the obvious thing</li>
<li>Otherwise call your function and recurse.</li>
</ol>
<p>These instructions aren’t a real program by any means, but you might call them a “program sketch.” The hard part of programming (thinking about what to do) is captured here, but <em>actually doing it</em> is left as an exercise to the reader.</p>
<p>A tactics engine transforms a program sketch like the above into an actual program. Tactics free us from the tyranny of text editing and pedantic details, allowing us to work at a higher semantic level of programming.</p>
<p>Tactics correspond to semantic operations over our program. Much like how the primitive commands in text editors (delete to end of line, insert parentheses, etc) can be composed to refine the textual representation of one program into the textual representation of another, we can compose small tactics in order to build larger ideas.</p>
<p>As an example, consider how we can fill in the following hole:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Id</span> a <span class="ot">=</span> <span class="dt">Id</span> a</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Id</span> <span class="kw">where</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="ot">  fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Id</span> a <span class="ot">-&gt;</span> <span class="dt">Id</span> b</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>  <span class="fu">fmap</span> <span class="ot">=</span> _</span></code></pre></div>
<p>Rather than writing this function all at once, we can instead build it, one idea at a time. The first step is obviously to bind function arguments (the <code>intros</code> tactic), which results in the refined expression:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Id</span> a <span class="ot">-&gt;</span> <span class="dt">Id</span> b</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="fu">fmap</span> <span class="ot">=</span> \fab ida <span class="ot">-&gt;</span> _</span></code></pre></div>
<p>We’re left with a new hole, but this one is “smaller” than the old one; we’ve refined the previous hole, filling in some of its structure. As a result, the type of our new hole is <code>Id b</code>, and we now have both <code>fab :: a -&gt; b</code> and <code>ida :: Id a</code> in scope. We can simplify the hole further by now pattern matching on <code>ida</code> (the <code>destruct ida</code> tactic):</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Id</span> a <span class="ot">-&gt;</span> <span class="dt">Id</span> b</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a><span class="fu">fmap</span> <span class="ot">=</span> \fab ida <span class="ot">-&gt;</span> <span class="kw">case</span> ida <span class="kw">of</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>  <span class="dt">Id</span> a <span class="ot">-&gt;</span> _</span></code></pre></div>
<p>The resulting hole still has type <code>Id b</code>, but we’ve now introduced <code>a :: a</code> in scope. Our next step is to build an <code>Id</code> value, which we can do by producing its data constructor (the <code>split</code> tactic):</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Id</span> a <span class="ot">-&gt;</span> <span class="dt">Id</span> b</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="fu">fmap</span> <span class="ot">=</span> \fab ida <span class="ot">-&gt;</span> <span class="kw">case</span> ida <span class="kw">of</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>  <span class="dt">Id</span> a <span class="ot">-&gt;</span> <span class="dt">Id</span> _</span></code></pre></div>
<p>Again we’ve shrunk the problem — now our hole has type <code>b</code>. At this point we can call the <code>fab</code> function to produce a <code>b</code> (via the <code>apply fab</code> tactic):</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Id</span> a <span class="ot">-&gt;</span> <span class="dt">Id</span> b</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="fu">fmap</span> <span class="ot">=</span> \fab ida <span class="ot">-&gt;</span> <span class="kw">case</span> ida <span class="kw">of</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>  <span class="dt">Id</span> a <span class="ot">-&gt;</span> <span class="dt">Id</span> (fab _)</span></code></pre></div>
<p>All that’s left is a hole with type <code>a</code>. Fortunately, we have <code>a :: a</code> in scope, so we can just plop that in to the hole via the <code>assumption</code> tactic:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Id</span> a <span class="ot">-&gt;</span> <span class="dt">Id</span> b</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="fu">fmap</span> <span class="ot">=</span> \fab ida <span class="ot">-&gt;</span> <span class="kw">case</span> ida <span class="kw">of</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>  <span class="dt">Id</span> a <span class="ot">-&gt;</span> <span class="dt">Id</span> (fab a)</span></code></pre></div>
<p>And just like that, we’ve produced an implementation of our desired function! By thinking in terms of the semantic operations we’d like to perform at each hole (instead of how to manipulate the bytes of text), we’ve changed the level of abstraction at which we think about editing. The implications of this might not be immediately obvious, so let’s explore them together.</p>
<p>Let’s list the tactic steps we took to derive <code>fmap</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>intros</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>destruct ida</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>split</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>apply fab</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>assumption</span></code></pre></div>
<p>Up to alpha renaming, this composition of tactics is sufficient to derive <code>fmap</code> for any sum or product type that doesn’t do anything “exciting” with its type variable. By running the same steps, we can implement <code>fmap</code> for any of the following types:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>(a, b)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="dt">Either</span> a b</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a><span class="dt">Maybe</span> a</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a><span class="dt">Const</span> a b</span></code></pre></div>
<p>Let’s convince ourselves of this by quickly running through the derivation for <code>Maybe a</code>. We start again with <code>fmap</code> and its type:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a><span class="fu">fmap</span> <span class="ot">=</span> _</span></code></pre></div>
<p>After running <code>intros</code>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a><span class="fu">fmap</span> <span class="ot">=</span> \fab ma <span class="ot">-&gt;</span> _</span></code></pre></div>
<p>and then <code>destruct ma</code></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a><span class="fu">fmap</span> <span class="ot">=</span> \fab ma <span class="ot">-&gt;</span> <span class="kw">case</span> ma <span class="kw">of</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> _</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>  <span class="dt">Just</span> a  <span class="ot">-&gt;</span> _</span></code></pre></div>
<p>Applying <code>split</code> here is a little tricky; technically it will force us to try both <code>Nothing</code> and <code>Just _</code> at each hole in a weird sort of quantum superposition. Let’s ignore this detail for right now, and come back to it immediately after finishing the derivation. Assuming we pick the right data cons, after <code>split</code> our program looks like this:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a><span class="fu">fmap</span> <span class="ot">=</span> \fab ma <span class="ot">-&gt;</span> <span class="kw">case</span> ma <span class="kw">of</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>  <span class="dt">Just</span> a  <span class="ot">-&gt;</span> <span class="dt">Just</span> _</span></code></pre></div>
<p>Now we run <code>apply fab</code>. Because <code>Nothing</code> doesn’t take any arguments, it didn’t produce any holes, so we need look only at the <code>Just</code> case:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a><span class="fu">fmap</span> <span class="ot">=</span> \fab ma <span class="ot">-&gt;</span> <span class="kw">case</span> ma <span class="kw">of</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>  <span class="dt">Just</span> a  <span class="ot">-&gt;</span> <span class="dt">Just</span> (fab _)</span></code></pre></div>
<p>and finally we run <code>assumption</code> to fill in the hole:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a><span class="fu">fmap</span> <span class="ot">=</span> \fab ma <span class="ot">-&gt;</span> <span class="kw">case</span> ma <span class="kw">of</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a>  <span class="dt">Just</span> a  <span class="ot">-&gt;</span> <span class="dt">Just</span> (fab a)</span></code></pre></div>
<p>Look at that! Even though it would require significantly different editing commands to write the syntax of these two functor instances, they are both descried by the same composition of tactics. This is what I mean by “semantic editing,” we’re moving the algorithm for producing functor instances out of our heads and reifying it into something the computer understands. In essence, by writing <code>fmap</code> once, we can teach the computer how to write it for us in the future.</p>
<p>I mentioned earlier that <code>split</code> gives us some issues here. Reading closely, you’ll notice that there is nothing in our tactics that say we need to <code>split</code> the same data constructor that we just <code>destruct</code>ed. In actuality there are four different, valid programs that can be produced by the above set of tactics:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="fu">fmap</span> <span class="ot">=</span> \fab ma <span class="ot">-&gt;</span> <span class="kw">case</span> ma <span class="kw">of</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>  <span class="dt">Just</span> a  <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a><span class="fu">fmap</span> <span class="ot">=</span> \fab ma <span class="ot">-&gt;</span> <span class="kw">case</span> ma <span class="kw">of</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true"></a>  <span class="dt">Just</span> a  <span class="ot">-&gt;</span> <span class="dt">Just</span> (fab a)</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true"></a></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true"></a><span class="fu">fmap</span> <span class="ot">=</span> \fab ma <span class="ot">-&gt;</span> <span class="kw">case</span> ma <span class="kw">of</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> _</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true"></a>  <span class="dt">Just</span> a  <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true"></a></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true"></a><span class="fu">fmap</span> <span class="ot">=</span> \fab ma <span class="ot">-&gt;</span> <span class="kw">case</span> ma <span class="kw">of</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> _</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true"></a>  <span class="dt">Just</span> a  <span class="ot">-&gt;</span> <span class="dt">Just</span> (fab a)</span></code></pre></div>
<p>Choosing the “best” implementation of these possibilities is largely a matter of heuristics, which I plan to describe in a later post. For now, let’s just assume our tactics engine is smart enough to come up with the one you had in mind.</p>
<p>Of course, the real issue here is that nothing forces our <code>destruct</code> and <code>split</code> tactics to use the same data constructor. We can eliminate this ambiguity by noticing that in <code>fmap</code>, we’re not actually trying to destruct and then split, but instead we’re trying to implement a homomorphism (a structure-preserving function.) In order to preserve structure, we’d better map a data constructor to itself. So instead, let’s use the <code>homo</code> tactic instead of <code>destruct</code> and <code>split</code>. Our new tactics metaprogram for writing functor instances is thus:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a>intros</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>homo ida</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>apply fab</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>assumption</span></code></pre></div>
<p>This new version now can no longer generate any of the pathological <code>fmap</code> implementations for <code>Maybe</code>, as they are not structure preserving. We’re left only with the good implementation. Let’s do one more derivation, this time for <code>Either c a</code>. After <code>intros</code> and <code>homo eca</code>, we’re left with:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Either</span> c a <span class="ot">-&gt;</span> <span class="dt">Either</span> c b</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a><span class="fu">fmap</span> <span class="ot">=</span> \fab ma <span class="ot">-&gt;</span> <span class="kw">case</span> eca <span class="kw">of</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>  <span class="dt">Left</span>  c <span class="ot">-&gt;</span> <span class="dt">Left</span> _</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a>  <span class="dt">Right</span> a <span class="ot">-&gt;</span> <span class="dt">Right</span> _</span></code></pre></div>
<p>For the first time, we’re now left with <em>two</em> holes. The default behavior is for a tactic to apply to all holes (although there are combinators for “zipping” holes), meaning that the <code>apply fab</code> tactic will be run on both holes. For the <code>Left</code> case, our hole has type <code>c</code>, but <code>fab _</code> has type <code>b</code>, so this tactic <em>fails to apply here.</em> Tactic failure is per-hole, so we can still apply it to the other hole, resulting in:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Either</span> c a <span class="ot">-&gt;</span> <span class="dt">Either</span> c b</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a><span class="fu">fmap</span> <span class="ot">=</span> \fab ma <span class="ot">-&gt;</span> <span class="kw">case</span> eca <span class="kw">of</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a>  <span class="dt">Left</span>  c <span class="ot">-&gt;</span> <span class="dt">Left</span> _</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a>  <span class="dt">Right</span> a <span class="ot">-&gt;</span> <span class="dt">Right</span> (fab _)</span></code></pre></div>
<p>And finally, <code>assumption</code> fills the hole with whatever would typecheck. In the first hole that’s <code>c</code>, and in the second it’s <code>a</code> as before.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Either</span> c a <span class="ot">-&gt;</span> <span class="dt">Either</span> c b</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a><span class="fu">fmap</span> <span class="ot">=</span> \fab ma <span class="ot">-&gt;</span> <span class="kw">case</span> eca <span class="kw">of</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a>  <span class="dt">Left</span>  c <span class="ot">-&gt;</span> <span class="dt">Left</span> c</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a>  <span class="dt">Right</span> a <span class="ot">-&gt;</span> <span class="dt">Right</span> (fab a)</span></code></pre></div>
<p>Amazing! Three different functor implementations, with different numbers of data constructors, type variables, and cardinalities. By programming at the level of tactics rather than bytes, we can ignore the superficial differences between these implementations, focusing instead on the fact that they’re all derived the same way.</p>
<p>Hopefully this post has given you some insight into what tactics are and why they’re valuable. In the next post we’ll look at how this stuff is implemented behind the scenes, and the difficulties we’ve had integrating it into the language server. Stay tuned!</p>
      ]]></content:encoded>
  </item>
  <item>
      <title>Algebra-Driven Design</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>http://reasonablypolymorphic.com/blog/algebra-driven-design/index.html</link>
      <guid>http://reasonablypolymorphic.com/blog/algebra-driven-design/index.html</guid>
      <pubDate>2020-09-10T16:55:00Z</pubDate>
      <content:encoded><![CDATA[
        <p>After almost a year of work, I’m <em>thrilled</em> to announce the completion my new book, <a href="https://algebradriven.design">Algebra-Driven Design</a>. It’s the culmination of two rewrites, and comes with a beautiful foreword written by John Hughes, the inventor of QuickCheck.</p>
<p>In the book, we take a fundamentally different approach to the software design process, focusing on deriving libraries from equations, algebraic manipulation and well-studied mathematical objects. The resulting code is guaranteed to be free of abstraction leaks, and in many cases, actually writes itself.</p>
<p>If that sounds like the sort of software you’d like to write, I’d highly encourage you to <a href="https://algebradriven.design">give it a read</a>.</p>
<center>
<a href="https://algebradriven.design"><img src="/images/add.png" alt="Algebra-Driven Design"></a>
</center>
      ]]></content:encoded>
  </item>
  <item>
      <title>Polysemy: Mea Culpa</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>http://reasonablypolymorphic.com/blog/mea-culpa/index.html</link>
      <guid>http://reasonablypolymorphic.com/blog/mea-culpa/index.html</guid>
      <pubDate>2020-06-14T22:36:00Z</pubDate>
      <content:encoded><![CDATA[
        <p><a href="https://lexi-lambda.github.io/">Alexis King</a> gave an <a href="https://www.youtube.com/watch?v=0jI-AlWEwYI">utterly fantastic talk</a> today on the deep inner workings of Haskell programs’ performance profiles. It’s really very excellent and you should go watch it if you haven’t already. I’ve been extremely <a href="https://sandymaguire.me/blog/burnout/">burned out</a> on Polysemy and effect-system-related topics lately, but it seems like as good a time as any to discuss what’s going on with the library. Why do Alexis’ benchmarks clearly show something other than my claim that Polysemy was “zero cost?” In short:</p>
<p>I screwed up.</p>
<p>The core Haskell that’s being run in Alexis’ benchmark probably looks <a href="https://gist.github.com/isovector/e4832512ec9c73bff94432a7a58470f9#file-t16473-dump-simpl">like this</a>, though at one point I did indeed get the countdown benchmark to completely <a href="https://gist.github.com/isovector/e4832512ec9c73bff94432a7a58470f9#gistcomment-2883147">optimize away.</a> My claim to being zero-cost was based on this result, which was possible, but required <a href="https://gitlab.haskell.org/ghc/ghc/merge_requests/668">patching GHC</a>, enabling <code>-flate-specialise -O2 -fstatic-argument-transformation -fmax-simplifier-iterations=10</code> as well as a <a href="https://gist.github.com/isovector/e4832512ec9c73bff94432a7a58470f9#gistcomment-2872671">GHC patch cajoling the optimizer into running extra hard.</a></p>
<p>My patch to GHC just barely missed the 8.8 deadline, which meant it wouldn’t be publicly available until GHC 8.10, roughly a year away. And until then, Polysemy had no chance of being fast.</p>
<p>The result of all this: fast code, relying on a house of cards of optimization, only on a compiler that didn’t exist yet. It worked, but was a huge hassle to test, and because of that, I didn’t do it very often, nor did I make it easy for others to verify my claims.</p>
<p>My mindset has always been that the “free monads are too slow” argument is overblown and irrelevant to 99% of programs, and my original goal with Polysemy was to show that there was nothing fundamentally wrong with the approach; that if we tried hard enough, we really could pull amazing performance out of free monads.</p>
<p>It’s been about a year now, so my recollection is hazy, but I think I must have somehow conflated “fast programs are possible in Polysemy” with “Polysemy is zero-cost.” There was absolutely no deception intended, but it appears I deceived myself, and the community because of that. I’m sorry.</p>
<p>Sometime near the end of 2019, Lexi showed me her research into why the effect system benchmarks were extremely misleading (as mentioned in her talk.) Her research made it very evident that all effect systems were “cheating” in the benchmark shootout, and I attributed Polysemy’s pre-super-optimized terrible benchmark numbers to “not cheating as much.” If the optimizer was what was making other effect systems fast, but only in single-module programs, presumably they would also perform badly in real-world, multiple-module programs, and would see the same performance characteristics as Polysemy. I didn’t confirm this experimentally.</p>
<p>Plus, I figured, if performance <em>truly is</em> a problem, and not the overactive fear I thought it was, surely someone would have filed a bug complaining that Polysemy wasn’t as fast as it claimed. To date, nobody has filed that bug, and I continue to believe it’s an overblown issue — though that isn’t to say we shouldn’t fix it if we can. Lexi’s package <a href="https://github.com/hasura/eff">eff</a> seems to be working towards that solution, and I applaud her for all of the work she’s been putting into this problem.</p>
<p>So that’s more or less the story. But there are a few loose ends; such as why Lexi and I are seeing different benchmarking results. I realize this doesn’t actually matter, and I agree with her that Polysemy <em>is in fact slow.</em> That being said, I feel like enough of my reputation is on the line that I’d like to put towards some more evidence that I didn’t fabricate the whole thing. Also, the investigation will unearth some more systematic problems.</p>
<p>First and foremost, the last time I looked at the source of Lexi’s benchmarks, I noted that they don’t use <code>polysemy-plugin</code>, which <a href="https://github.com/polysemy-research/polysemy#stellar-engineering---aligning-the-stars-to-optimize-polysemy-away">the documentation states is necessary for the good performance</a>. I don’t remember where these benchmarks actually are, but it doesn’t matter, because even if she had enabled the plugin, Polysemy <em>would still not optimize away.</em></p>
<p>Why not? Polysemy’s performance was extremely reliant on unfolding of its recursive bind operation. As <a href="https://reasonablypolymorphic.com/blog/writing-custom-optimizations/#inlining-recursive-calls">described here</a>, you could trick GHC into unfolding a recursive call once by explicitly giving a loop-breaker. In essence, it required transforming the following recursive call:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="ot">factorial ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>factorial <span class="dv">0</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>factorial n <span class="ot">=</span> n <span class="op">*</span> factorial (n <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="ot">{-# INLINE factorial #-}</span></span></code></pre></div>
<p>Into this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="ot">factorial ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>factorial <span class="dv">0</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>factorial n <span class="ot">=</span> n <span class="op">*</span> factorial&#39; (n <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a><span class="ot">{-# INLINE factorial #-}</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a><span class="ot">factorial&#39; ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>factorial&#39; <span class="ot">=</span> factorial</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a><span class="ot">{-# NOINLINE factorial&#39; #-}</span></span></code></pre></div>
<p>For whatever reason, this trick exposes enough of Polysemy’s bind so that the simplifier could inline away the expensive bits. But this was tedious! Every recursive call needed an explicit loop-breaker, and missing one would silently jeopardize your performance! Doing this by hand seemed antithetical to Polysemy’s other goal of no-boilerplate, and so at some point we factored out this logic into a GHC plugin, and then <a href="https://github.com/polysemy-research/polysemy/commit/8bbd9dc7d6ff1d55c9f8ea5f7f160ecf337d0e6e#diff-a6a5069006aaf9c213df8bfcf538bda8">removed our hand-written loop-breakers.</a>. The initial implementation of that plugin is described <a href="https://reasonablypolymorphic.com/blog/writing-custom-optimizations/">in this blog post</a>.</p>
<p>In retrospect, this explicit breaking-of-loops doesn’t seem to be required in the benchmark — only in Polysemy — but that escaped my attention at the time and believing that user-code required this optimization was the main motivation in turning it into a GHC plugin. Anyway…</p>
<p>As it turns out, this plugin <em>didn’t actually work!</em> It was successfully rewriting the core into the explicitly loop-broken version, but for whatever reason, <a href="https://github.com/polysemy-research/polysemy/pull/90#issuecomment-500090395">the simplifier wasn’t picking up where we left off.</a> To this day I don’t know why it doesn’t work, but it doesn’t. Instead we proposed to implement this plugin as a renamer pass, but that presents serious implementation problems. Since there was no way in hell Polysemy could possibly be fast before GHC 8.10 (to be released roughly a year in the future) motivation to find a solution to this problem was understandably low, and it fell by the wayside. It has never been fixed, and remains disabled and half-worked around in Polysemy to this day.</p>
<p>Hopefully this is the only reason why Polysemy doesn’t show the excellent (though, admittedly unrepresentative) countdown benchmark results I claimed it did. I’m not invested enough to check for myself, but if you’re interested, I suspect you’ll see excellent core produced by <a href="https://gist.github.com/isovector/e4832512ec9c73bff94432a7a58470f9#gistcomment-2883144">my single-file repro</a> if you compile it on GHC 8.10 under <code>-O2</code> with the <code>polysemy-plugin</code> and the above flags enabled. If so, I suspect rolling back <a href="https://github.com/polysemy-research/polysemy/commit/8bbd9dc7d6ff1d55c9f8ea5f7f160ecf337d0e6e">#8bbd9dc</a> would get the real Polysemy library also doing well on the benchmark. But again, <em>the benchmark performance is meaningless!</em></p>
<hr />
<p>Enough history for today. Before ending this post, I’d like to do a tiny <a href="https://www.hillelwayne.com/post/stamping-on-eventstream/">STAMP</a> on what went wrong, in the hope that we can all learn something. The goal here is not to pass the buck, but to get a sense of just how much went wrong, how, and why.</p>
<p>By my analysis, the following issues all contributed to Polysemy’s colossal failure:</p>
<ul>
<li>Haskell’s performance is not well understood
<ul>
<li>The effect system benchmarks were meaningless, and if anyone knew that, it was not common knowledge.</li>
<li>MTL is widely believed to be more performant than it is.</li>
<li>Existing effect systems’ performance is tied largely to GHC’s optimizer firing.</li>
<li>Because of lack of understanding, I was tackling bad-performance symptoms rather than causes.</li>
</ul></li>
<li>Polysemy’s performance was unreliable
<ul>
<li>Required several interlocking pieces to work: a patched compiler, a core plugin, explicit loop-breakers, obscure GHC options.</li>
<li>Because the performance was hard to test, we didn’t notice when these pieces didn’t work.
<ul>
<li>Upon noticing the loop-breaking plugin didn’t work, it was unclear how to fix it.
<ul>
<li>Because of requiring a patched GHC, it was not a priority to fix.
<ul>
<li>Not being a priority meant it wasn’t motivating, and so it didn’t get done.</li>
</ul></li>
</ul></li>
</ul></li>
<li>Debugging the simplifier is hard work. I was looking at thousands of lines of generated core by eye. <a href="https://github.com/yav/dump-core">Tooling exists</a>, but it is more helpful for navigating core than diffing it.</li>
</ul></li>
<li>Polysemy’s performance was too hard to test.
<ul>
<li>I missed the GHC deadline
<ul>
<li>My patch lingered for weeks in a finished state
<ul>
<li>Only reviewable by one person, who was on vacation.</li>
<li>Stuck doing drive-by improvements that were only suggestions, and not blockers to being merged. This was not made clear to me.</li>
<li>The simplifier is really hairy. It’s under-documented, and the function I was touching was over 150 lines of code.</li>
</ul></li>
</ul></li>
<li>I use Stack for my development, Stack doesn’t easily support custom-built GHCs. Therefore I couldn’t use my usual tools to test.</li>
<li>I don’t know how to use cabal
<ul>
<li>The documentation is notoriously lacking. As best I can tell, there are no “quick start” tutorials, and the relevant parts of the user manual are mentioned only under a heading that mentions “Nix”.</li>
</ul></li>
<li>Because of the above two points, I only tested on the single module, and never on the library itself.</li>
</ul></li>
<li>I had too much ego in the project.
<ul>
<li>I wanted to believe I had accomplished something “impossible.”</li>
<li>I had invested several engineering-months of my time working on this problem.</li>
<li>I had invested a large chunk of my reputation into free monads.</li>
</ul></li>
</ul>
<p>This post is long enough without diving into those points in more detail, but I’m happy to expand on individual points. Let me know in the comments if you’re interested.</p>
<p>All in all, this is has been the embarrassing affair. But then again, <em>if you haven’t failed in recent memory, you’re not trying hard enough.</em> I’ll strive to do better in the future.</p>
      ]]></content:encoded>
  </item>
</channel>
</rss>
