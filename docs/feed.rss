<?xml version="1.0" encoding="UTF-8" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:media="http://search.yahoo.com/mrss/">
<channel>
  <title>Reasonably Polymorphic</title>
  <link>http://reasonablypolymorphic.com</link>
  <atom:link href="http://reasonablypolymorphic.com/feed.rss" rel="self" type="application/rss+xml" />
  <description>There will be math and Haskell and it will be in ya face.</description>
  <category>Life</category>
  <copyright>2018 Sandy Maguire</copyright>
  <pubDate>2021-01-23T16:10:00Z</pubDate>
  <language>en-us</language>
  <image>
      <url>http://reasonablypolymorphic.com/images/favicon.png</url>
    <title>Sandy Maguire</title>
    <link>http://reasonablypolymorphic.com</link>
  </image>
  <item>
      <title>I Built a Terrible Roomba</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>http://reasonablypolymorphic.com/blog/roomba/index.html</link>
      <guid>http://reasonablypolymorphic.com/blog/roomba/index.html</guid>
      <pubDate>2021-01-23T16:10:00Z</pubDate>
      <content:encoded><![CDATA[
        <p>I spent the last few months making a roomba. I mean, sorta. I made a robot that wanders around and ostensibly vacuums as it goes. But it gets stuck on things all the time, and the floor isn’t particularly clean by the time it runs out of batteries. Nevertheless, it was an experience<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> and I learned a lot, so I though it would be a good idea to document. Consider the following a devlog, one that might be interesting for the historical record — but which I don’t suggest following to build your own roomba.</p>
<p>This all started when I googled for “fun robot projects,” and came across this <a href="https://www.youtube.com/watch?v=FUUPcwtkDQw">terrible video</a>. It goes through building a little roomba life-hack-style, which is to say, in absolutely no detail but vaguely making the whole procedure look simple. They use some cardboard and a cup-noodle container, so I thought “how hard could this be?” What I didn’t notice at the time was how the thing they build is not the thing they demo, nor how there are crucial components that are completely disconnected. As it happens, this video is completely smoke and mirrors.</p>
<p>I’d picked up some motors and a motor controller for a previous, <a href="https://sandymaguire.me/blog/mastery-skateboard/">ill-fated project</a>. And I had an old sonar module lying around in order to do the range finding. So I figured all that was left was a cup-noodles container and a fan, and I’d be on my merry way.</p>
<p>Stupidly, I decided I wasn’t going to make this thing out of cardboard. I was going to design and 3D print the chassis and all of the fiddly little bits it would require. My 3D printer’s bed is 22cm square, which meant anything I wanted to make was going to need to be smaller than that. My first prototype was shaped like a flying disc, with a hole in the middle to put the noodles container, but I learned the hard way that there simply wasn’t enough floor-space on the disc to fit all of the necessary electronics. Back to the drawing board.</p>
<p>I farted around with the base plate design for like a month, trying things. In the meantime, I picked up some CPU fans, assuming that all fans are made equally. This is not true — CPU fans are good at moving air, but not good at, uh… pressurizing air? or something? The idea is that a CPU fan won’t force air somewhere it doesn’t want to go, for example, into a vacuum bag. For that you want a blower fan, but I spent $50 buying the wrong sorts of fans on amazon before I figured this out.</p>
<p>Fans are measured in CFM, which is some sort of non-standardized measurement of “cubic feet per minute.” How much more imperial can you get? Non-standardized here means that all fan manufactures have a different procedure for measuring the CFM, so you can’t just compare numbers. That would be too easy.</p>
<p>It took many weeks of not having my roomba suck enough before I realized that fans move a constant <em>volume</em> of air, <strong>not</strong> a constant <em>mass.</em> The difference is that, unless you have really good intake to your fan, it’ll just make your vacuum chamber really low pressure, and not actually translate into sucking hard at the nozzle. I sorta worked around this by just mounting the fan directly above the vacuum bag, which had a small cut-out to pull debris through. Pipes seem to be anathema to small fans that you’re trying to use as vacuum pumps.</p>
<p>I tried using some agitators to improve my suction by getting things moving. My first attempt was via a gear train that I didn’t realize was 10RPM — way too damn slow to get anything moving. I didn’t feel like waiting around for another amazon shipment, so I just tried running my 12V 2000RPM DC motors at 3V. It sorta worked, but the handmade brushes I built dissolved themselves by still spinning too fast. Since it didn’t seem to improve the suction by much, I ended up scrapping this idea.</p>
<p>While trying to prototype something together with alligator clamps, I accidentally shorted my battery and caused no-small amount of smoke and did some unintentional welding. Thankfully it didn’t explode! I <em>was</em> doing stupid, unsafe things with the battery, but I learned the wrong lesson from this — that I should properly solder all of my connections, even when prototyping. What I should have learned instead was to make a really safe breakout connector for my battery, and then play fast and loose with crimps and connectors from there. But I didn’t yet know about crimps and connectors, so I just hand-soldered everything. It took forever and my productivity went asymptotically towards zero. Especially because I didn’t yet know what I was making, so there was a <em>lot</em> of soldering and desoldering and resoldering.</p>
<p>To make things worse, I kept 3D printing half-figured out chassis — each one of which took like nine hours to print. Inevitably some part wouldn’t fit, or the suction would be off, or some other problem would arise. Cardboard next time, my dude.</p>
<p>Oh, and did I mention that I don’t know how to connect physical things, so I just ended up hot-glueing everything together? Like, <em>everything.</em></p>
<p>One day I was hanging out on IRC, describing my project when Julia Longtin said “oh my god STOP. You’re going to burn down your house!” She had correctly noticed that I hadn’t put a battery management system in front of my battery. If you’re a hobbyist like I am, you might not know that LiPo batteries have a bad habit of catching on fire when you charge them after letting their voltage drop too low. A BMS board watches the voltage on the battery and cuts the circuit before it gets dangerously low. When testing this thing (after the BMS was installed,) it turned off quite often, so I’m pretty sure Julia saved me a ton in fire insurance claims. Thanks Julia!</p>
<p>The roomba’s only sensor is a sonar module that shoots sound waves and listens to hear when they come back. It’s essentially echo-location, like what bats have. Unfortunately for me, we also have the expression “blind as a bat,” which pretty adequately describes the robot. Sonar is a neat idea in theory, but in practice it only reliably works up to about a foot in front, and cloth-covered things like sofas muffle it. When added to the fact that DC motors offer no feedback if they’re stalled, it meant my roomba couldn’t detect if it were moving down a long hallway or stuck trying to drive into the couch. These are two scenarios you really want different behaviors for.</p>
<p>But even worse, due to my design and the limitations of my 3D printer bed, I couldn’t figure out how to fit the wheels inside the robot and still get all of the electronics and vacuum supplies on-board. As a compromise, the rubber tires jut out about two centimeters. Which is just about ideal for getting caught on chair legs and errant cables and walls and stuff like that. So if he hit the wall at a 45 degree angle, he’d just get wedged there. And at 45 degrees, sonar just bounces off of walls and doesn’t return, so again, you don’t know you’re stuck.</p>
<p>What a piece of work.</p>
<p>The software on this thing is a big state machine with things like “drive forward” and “bounce off of driving straight into the wall” and “try relocate because you’ve been stuck in the couch for too long.” I expected the software to be the easiest part of this project, since I’m an ex-professional software engineer. But not so! Even after you discount the time I accidentally melted my Arduino — by… well, I’m not sure what, but definitely related to plugging it into the computer — the software didn’t go smoothly. Arduino has this annoying forced event loop where it calls <code>loop()</code> just as fast as it can, and you can push back with a <code>delay(long milliseconds)</code> function call. But it’s all in C++ (but without the STL) and so getting any real work done is annoying. And have you ever tried to write a proper state machine without algebraic data types? I walked away with the impression that I’m going to need to do a lot of work improving the software end of things before I do another serious project with Arduino.</p>
<p>In short, I spent a few months accidentally setting stuff on fire, waiting too long for the wrong 3D shapes to print, and I all I got was this stupid T-shirt. But I guess that’s what learning feels like. But I’ve already bought a LIDAR module and some bumpers for mk 2, so maybe I’m just a glutton for punishment.</p>
<p>If you’re curious about actually building this thing, here’s all of the source materials. But please, do yourself a favor and don’t put yourself through the mental turmoil of trying to get it to work.</p>
<h2 id="building-one-for-yourself">Building One For Yourself</h2>
<p>Don’t. But if you do, you’ll need these parts:</p>
<h3 id="bill-of-materials">Bill of Materials</h3>
<ul>
<li><a href="https://www.amazon.ca/gp/product/B07DQGX369/ref=ppx_yo_dt_b_asin_title_o00_s00?ie=UTF8&amp;psc=1">Motor wheels</a></li>
<li><a href="https://www.amazon.ca/gp/product/B07D1HP3SJ/ref=ppx_yo_dt_b_asin_title_o05_s00?ie=UTF8&amp;psc=1">L298N</a></li>
<li><a href="https://www.amazon.com/SainSmart-HC-SR04-Ranging-Detector-Distance/dp/B004U8TOE6">HC-SR04</a></li>
<li><a href="https://www.amazon.ca/gp/product/B07RM573HD/ref=ppx_yo_dt_b_asin_title_o03_s00?ie=UTF8&amp;psc=1">4S BMS Board</a></li>
<li><a href="https://www.amazon.ca/gp/product/B08CMNTBB2/ref=ppx_yo_dt_b_asin_title_o00_s00?ie=UTF8&amp;psc=1">12V, 1A, 36.2CFM Blower fan</a></li>
<li><a href="https://www.amazon.ca/gp/product/B07KC9C6H5/ref=ppx_yo_dt_b_asin_title_o08_s00?ie=UTF8&amp;psc=1">Arduino Nano</a></li>
<li><a href="https://www.amazon.ca/gp/product/B07JNQFV7F/ref=ppx_yo_dt_b_asin_title_o09_s00?ie=UTF8&amp;psc=1">2x LM2596 DC to DC buck converter</a></li>
<li><a href="https://www.amazon.ca/gp/product/B072M9S2CQ/ref=ppx_yo_dt_b_asin_title_o04_s01?ie=UTF8&amp;psc=1">Ball bearing</a></li>
<li><a href="https://www.amazon.ca/gp/product/B0784BB8F5/ref=ppx_yo_dt_b_asin_title_o04_s02?ie=UTF8&amp;psc=1">14.8V RC LiPo battery</a></li>
<li><a href="https://www.amazon.ca/Gikfun-1N4007-Plastic-Rectifier-Arduino/dp/B01K77YVUA/ref=sr_1_1?dchild=1&amp;keywords=diode&amp;qid=1611443750&amp;s=electronics&amp;sr=1-1">Diode</a></li>
<li><a href="https://www.amazon.ca/gp/product/B01N2U8PK0/ref=ppx_yo_dt_b_asin_title_o09_s00?ie=UTF8&amp;psc=1">Flip switch</a></li>
<li><a href="https://www.amazon.ca/gp/product/B01N8VV78D/ref=ppx_yo_dt_b_asin_title_o01_s00?ie=UTF8&amp;psc=1">5.5mm DC jack female</a></li>
<li><a href="https://www.amazon.ca/gp/product/B07DHMGWVG/ref=ppx_yo_dt_b_asin_title_o01_s00?ie=UTF8&amp;psc=1">15V DC power supply</a></li>
</ul>
<h3 id="d-printed-parts">3D Printed Parts</h3>
<p>The whole thing is written in a Haskell DSL for 3D printing called <a href="http://www.implicitcad.org/">ImplicitCAD</a>, because of course it is. Have you met me? The source code is available <a href="https://github.com/isovector/cad-models/blob/9a4eb494690293ee5c42859da1ae96d2b99b6840/src/Roomba3.hs">here</a>, where everything definition prefixed with <code>final_</code> needs to be printed.</p>
<p>Oh yeah, and even after being very careful to model the negative space necessary for the fan’s exhaust, I forgot to connect that to the body of the roomba, so I needed to cut the exhaust hole out with my soldering iron. The resulting smoke was pretty noxious, so I just tried to not breathe too hard.</p>
<h3 id="source-code">Source Code</h3>
<p><a href="https://github.com/isovector/arduino/tree/f8fe8a7de609bbdd9264243839d29c1d854f2e73/roomba">Here’s the code</a> I wrote for this thing. It’s not beautiful, and shouldn’t be considered as evidence as to how I write real code that I care abut. Sorry not sorry.</p>
<h3 id="schematic">Schematic</h3>
<figure>
<img src="/images/roomba.png" alt="" /><figcaption>Roomba schematic</figcaption>
</figure>
<p>What’s labeled as the voltage source here should instead be the BMS. And no promises that the pins on the Arduino correspond exactly with what the source code actually does. I think it’s right, but the roomba might drive backwards.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>I’m hesitant to call it a <em>good</em> experience.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
      ]]></content:encoded>
  </item>
  <item>
      <title>Haskell in the Real World</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>http://reasonablypolymorphic.com/blog/3d-printing/index.html</link>
      <guid>http://reasonablypolymorphic.com/blog/3d-printing/index.html</guid>
      <pubDate>2020-11-25T14:00:00Z</pubDate>
      <content:encoded><![CDATA[
        <p>I had a delightful experience this morning, where I fixed a real world problem in my life with Haskell. It’s rare that I actually get to <em>use</em> this stuff I spend so much time thinking about, so thought it would make a nice and quick blog post.</p>
<h2 id="the-problem">The Problem</h2>
<p>My apartment used to have some crappy roll-down blinds, which did absolutely nothing for blocking out early morning light. As the master of my domain, I took them down and installed more traditional curtains in their place, held up by a tension rod. My tension rod is tensioned between the mounting plates for the old blinds, which are metal. Unfortunately, the rubber pads of the tension rod don’t get much of a purchase on the metal, and so my curtains fall down once a week or so.</p>
<p>They fell down yesterday, and I resolved that would be the last time.</p>
<h2 id="the-solution">The Solution</h2>
<p>I’ve recently bought a 3D printer, and like most new technology, it has taken some time to acclimatize to. Having a mini-factory in your house is probably pretty powerful, but so far I’ve just been looking for excuses to use it. There are lots of weird projects on <a href="https://www.thingiverse.com/">Thingiverse</a> that I keep trying to convince myself I need in my apartment.</p>
<p>But today was a turning point. The slippery mounting plate has some holes in it — so I realized I could manufacture a bracket that would sit in the mounting plate and prevent my tension rod from falling again.</p>
<figure>
<img src="/images/mounting-bracket.jpg" alt="" /><figcaption>The mounting plate</figcaption>
</figure>
<p>Armed with my <a href="https://www.amazon.ca/Digital-Measuring-Calipers-Conversions-Diameter/dp/B088R4XFBN">digital calipers</a>, I took some measurements of the plate, and quickly whipped up a CAD model using the <a href="https://github.com/colah/ImplicitCAD"><code>implicit</code> library</a> — a library for doing CAD modeling in Haskell:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">import</span> <span class="dt">Graphics.Implicit</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>main <span class="ot">=</span> writeSTL <span class="fl">0.25</span> <span class="st">&quot;/tmp/mount.stl&quot;</span> <span class="op">$</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>  <span class="kw">let</span> base <span class="ot">=</span> center3 <span class="op">$</span> union</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>        [ slamBack <span class="op">$</span> slamTop <span class="op">$</span> centeredBox <span class="dv">40</span> <span class="dv">40</span> <span class="dv">6</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>        , slamBack <span class="op">$</span> slamBottom <span class="op">$</span> centeredBox <span class="dv">9</span> <span class="fl">3.7</span> <span class="dv">6</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>        ]</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>   <span class="kw">in</span> difference</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a>        [ slamFront <span class="op">$</span> difference</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a>          [ slamBottom <span class="op">$</span> union</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a>            [ mirror (<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>) base</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a>            , mirror (<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>) base</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a>            , base</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true"></a>            ]</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true"></a>          , translate (mk3 <span class="dv">0</span> <span class="dv">0</span> (<span class="op">-</span><span class="dv">6</span>))</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true"></a>              <span class="op">$</span> slamBottom</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true"></a>              <span class="op">$</span> cylinder (<span class="dv">33</span> <span class="op">/</span> <span class="dv">2</span>) <span class="dv">10</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true"></a>          , translate (mk3 <span class="dv">0</span> (<span class="op">-</span><span class="dv">3</span>) (<span class="op">-</span><span class="dv">6</span>))</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true"></a>              <span class="op">$</span> slamBottom</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true"></a>              <span class="op">$</span> cylinder (<span class="dv">33</span> <span class="op">/</span> <span class="dv">2</span>) <span class="dv">10</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true"></a>          ]</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true"></a>        , slamFront <span class="op">$</span> slamBottom <span class="op">$</span> centeredBox <span class="dv">40</span> <span class="fl">14.5</span> <span class="dv">6</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true"></a>        ]</span></code></pre></div>
<p>This program isn’t going to win any awards and the magic numbers are petrifying. But it’s OK, because it saves to <code>/tmp</code> anyway. The result is a little bracket that sits inside of the holes of the mounting plate and prevents the tension bar from moving.</p>
<p>The tension of the rod pushes the pins into the holes, which prevent the bracket from falling, which in turn holds up the tension rod. Amazing, really.</p>
<figure>
<img src="/images/bracket-top.png" alt="" /><figcaption>Tension rod slot</figcaption>
</figure>
<figure>
<img src="/images/bracket-bottom.png" alt="" /><figcaption>Mounting pins</figcaption>
</figure>
<p>An hour of printing later, and my new brackets were done. They fit into the holes just fine, and I can rest soundly knowing that the darkness of my room is forever safeguarded.</p>
      ]]></content:encoded>
  </item>
  <item>
      <title>Separate Your Views; Reify Your Reasoning</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>http://reasonablypolymorphic.com/blog/separate-your-views-reify-your-reasoning/index.html</link>
      <guid>http://reasonablypolymorphic.com/blog/separate-your-views-reify-your-reasoning/index.html</guid>
      <pubDate>2020-11-09T21:45:00Z</pubDate>
      <content:encoded><![CDATA[
        <p>Continuing our discussion of tactics, today I’d like to talk about my recent diff on <a href="https://github.com/haskell/haskell-language-server/tree/master/plugins/tactics">hls-tactics-plugin</a>. I learned a deep lesson about writing software in this commit and wanted to share the insight.</p>
<p>Some background before we get started. The <code>hls-tactics-plugin</code> is capable of automatically generating small snippets of Haskell code. Like how, near the end of a proof, mathematicians will throw their hands in the air and say “the remainder is obvious,” we’d like to empower software engineers in the same way. The idea is for the computer to pick up where you left off, and fill in expressions that have a uniquely best solution (for some meaning of “best”.) In practice, it works quite well.</p>
<p>To make this happen, we need to know the desired type at the hole to be filled, as well as what’s in scope, and various other pieces of metadata — such as what’s already been used and where values came from. The record for this data is called the <code>Judgment</code>, and originally looked like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Judgment</span> <span class="ot">=</span> <span class="dt">Judgment</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>  {<span class="ot"> _jHypothesis        ::</span> <span class="dt">Map</span> <span class="dt">OccName</span> <span class="dt">Type</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>  ,<span class="ot"> _jAmbientHypothesis ::</span> <span class="dt">Map</span> <span class="dt">OccName</span> <span class="dt">Type</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>  ,<span class="ot"> _jDestructed        ::</span> <span class="dt">Set</span> <span class="dt">OccName</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>  ,<span class="ot"> _jPatternVals       ::</span> <span class="dt">Set</span> <span class="dt">OccName</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>  ,<span class="ot"> _jPositionMaps      ::</span> <span class="dt">Map</span> <span class="dt">OccName</span> [[<span class="dt">OccName</span>]]</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>  ,<span class="ot"> _jAncestry          ::</span> <span class="dt">Map</span> <span class="dt">OccName</span> (<span class="dt">Set</span> <span class="dt">OccName</span>)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>  ,<span class="ot"> _jBlacklistDestruct ::</span> <span class="dt">Bool</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>  ,<span class="ot"> _jWhitelistSplit    ::</span> <span class="dt">Bool</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a>  ,<span class="ot"> _jIsTopHole         ::</span> <span class="dt">Bool</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a>  ,<span class="ot"> _jGoal              ::</span> <span class="dt">Type</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a>  }</span></code></pre></div>
<p>As you can probably tell, this data structure grew organically, one field and feature at a time. The only truly necessary fields are <code>_jHypothesis</code> and <code>_jGoal</code>, the first of which tracks what’s in scope and its type, and the second tracks the type we’re currently trying to synthesize a value of. The rest of this stuff is used exclusively for intelligently narrowing the exponentially large space of possible solutions we could generate. They’re necessary for getting fast/good results, but in essence, just track heuristics that in practice help get the right answer. There’s no <em>theoretical justification</em> for them. As such, these fields are <strong>properties of the implementation, not of the domain.</strong></p>
<p>This is an extremely important realization. Fields like <code>_jDestructed</code> and <code>_jAncestry</code> are <a href="https://www.youtube.com/watch?v=GqmsQeSzMdw">exploded views</a> on our data. They exist in a non-compositional form, serving only to the ad-hoc queries I’ve thought of today, and are likely unhelpful for whatever search heuristic I decide to implement next. To illustrate this, <code>_jPatternVals</code> tracks which values came from bindings in a pattern match (useful for generating structurally-smaller recursive terms), while <code>_jAncestry</code> tracks if a value is descendant from another in some way. And <code>_jDestructed</code> records whether or not we’ve already pattern matched on any particular values. Clearly, there is a lot of overlap in these fields. Taken in aggregate, they feel like a myopic, denormalized representation of data provenance.</p>
<p>As a general rule, I tend to have a great distrust in denormalized representations. By their very nature, they blur the notion of <em>source of truth</em> — whom should you believe if your denormalized data sources disagree with one another? Furthermore, almost no human domains are intrinsically denormalized; it simply isn’t how our brains our wired — we like to think in deep notions of identity. These concerns together suggest that denormalized representations are, again, artifacts of the implementation, rather than meaningful carved joints in reality. Worse, it’s hard to initialize a non-empty denormalized system. Making sure all of the data sources agree is a bigger source of bugs than sprinkling sugar on your kitchen floor.</p>
<p>All of this is to say: why not just model the data provenance in <code>Judgment</code> directly? With that as an explicit source of data, it’s trivial to reimplement the fields like <code>_jAncestry</code> et al. as views over the real datastructure.</p>
<p>This is a greatly under-appreciated feature of Haskell’s record system. Because field selectors are just functions whose input is the record in question, there is no syntactic difference between them and arbitrary functions over the same record. Most other languages enforce a syntactic difference between class fields and class methods, which is where the <a href="https://en.wikipedia.org/wiki/Mutator_method">mutator method pattern</a> comes from. Like most software patterns, this one too is unnecessary in Haskell.</p>
<p>Instead, we can just remove the <code>_jAncestry</code> field from <code>Judgment</code>, and then implement a function <code>_jAncestry :: Judgment -&gt; Map OccName (Set OccName)</code> which computes the desired view from the data provenance. Amazingly, <em>all calling code will just work,</em> and doesn’t need to know that the underlying datastructure has changed.</p>
<p>Of course, the usual zealots will point out that the runtime performance will have changed through this transformation. And that’s probably true, but what’s also almost certainly true is that <em>it doesn’t matter.</em> It’s extremely unlikely that this field is the linchpin of my algorithm’s asymptotics, so don’t worry about it unless it becomes a problem. And if it does, I’m sure you can find a clever way of caching this field without confusing the fact that it is a view on data, and not data itself.</p>
<p>The crux of my change was to rip out all of my data views and add provenance to the hypothesis. The diff is delightfully red:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a> data Judgment = Judgment</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="st">-  { _jHypothesis        :: Map OccName Type</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="st">-  , _jAmbientHypothesis :: Map OccName Type</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a><span class="st">-  , _jDestructed        :: Set OccName</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a><span class="st">-  , _jPatternVals       :: Set OccName</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a><span class="st">-  , _jPositionMaps      :: Map OccName [[OccName]]</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a><span class="st">-  , _jAncestry          :: Map OccName (Set OccName)</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a><span class="va">+  { _jHypothesis        :: Map OccName (HyInfo Type)</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a>   , _jBlacklistDestruct :: Bool</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>   , _jWhitelistSplit    :: Bool</span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a>   , _jIsTopHole         :: Bool</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a>   , _jGoal              :: Type</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a>   }</span></code></pre></div>
<p>Six denormalized fields replaced with one normalized source. This is already a huge improvement in terms of engineering confidence. The relationship between the many maps and sets of <code>OccName</code>s in the old system is inevitably going to be under-documented and implementation-defined. Even as the guy who wrote each of those features, I doubt I’d be able to create a well-formed <code>Judgment</code> by hand.</p>
<p>The next step was to implement <code>HyInfo</code>, which tracks the type and provenance of a value in the hypothesis:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">HyInfo</span> a <span class="ot">=</span> <span class="dt">HyInfo</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>  {<span class="ot"> hi_provenance ::</span> <span class="dt">Provenance</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>  ,<span class="ot"> hi_type       ::</span> a</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>  }</span></code></pre></div>
<p>To define <code>Provenance</code>, I added a data constructor for each different sort of value that I was aware of. By explicitly tagging all of this data, we can attach the previously-denormalized data that must exist, ensuring the entire datastructure is correct by construction.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Provenance</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">TopLevelArgPrv</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>      <span class="dt">OccName</span>   <span class="co">-- ^ Binding function</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>      <span class="dt">Int</span>       <span class="co">-- ^ Argument Position</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">PatternMatchPrv</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true"></a>      <span class="dt">PatVal</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">ClassMethodPrv</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true"></a>      <span class="dt">Class</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">DisallowedPrv</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true"></a>      <span class="dt">DisallowReason</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true"></a>      <span class="dt">Provenance</span></span></code></pre></div>
<p>The arguments to <code>PatternMatchPrv</code> have been factored out into their own type, because pattern values are especially interesting and require further processing, outside the scope of this post. Of particular interest is <code>DisallowedPrv</code>, which we’ll discuss in a moment.</p>
<p>In the <code>hls-tactics-plugin</code> codebase, we made judicious use of a helper function <code>withHypothesis :: (Map OccName Type -&gt; Map OccName Type) -&gt; Judgment -&gt; Judgment</code>. Functions which, for example, wanted to introduce new values into the hypothesis (such as after pattern matching) would call <code>withHypothesis</code> and directly insert their values. If we wanted to exclude values from the search space, we’d just <code>withHypothesis . Map.filter</code> them out. The result was lots of call-sites directly fiddling with the state in unprincipled ways. Nobody actually needed the full power of <code>Map OccName Type -&gt; Map OccName Type</code>; it just happened to be the only convenient way of manipulating the hypothesis.</p>
<p>I removed <code>withHypothesis</code>, and instead replaced it with semantically meaningful functions, like <code>introduceLambdaValues</code>, <code>introducePatVals</code> and <code>disallowUsageOf</code>. The implementations hadn’t changed, but now they were encapsulated into a function call, rather than be scattered about at call sites.</p>
<p>The <code>disallowUsageOf</code> function is particularly interesting.</p>
<p>Besides the importance of normalization, this change taught me one other thing: the necessity of reifying your reasoning. Ollie Charles presents an excellent example of this in <a href="https://ocharles.org.uk/blog/posts/2019-08-09-who-authorized-these-ghosts.html">Who Authorized These Ghosts</a>, but I’d never fully appreciated the technique until now. The gist of it is that it’s important not just to track state, but also to track why you believe the state is what it is. In Ollie’s example, he’s tracking authorization status (a boolean,) but to prevent security holes, his application internally requires a token proving the user is allowed to act. This is <a href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/">parsing, not validating</a> taken to the extreme; programmers are required to produce a token to call privileged functions, and the only way of obtaining that token is by checking the authorization state.</p>
<p>The <code>disallowUsageOf</code> function, and corresponding <code>DisallowedPrv</code> provenance constructor above fill a very similar role.</p>
<p>Attentive readers will have noticed that the <code>_jDestructed</code> field is not truly a measure of provenance. In fact, it’s tracked exclusively to prevent production of code of the form:</p>
<pre><code>case x of
  Blah -&gt; case x of
    Blah -&gt; case x of
      Blah -&gt; ...</code></pre>
<p>However, a good heuristic when writing Haskell code is that if possible, a value should be used exactly one time. To a first approximation, we can produce a view of <code>_jDestructed</code> by checking to see if any <code>PatternMatchPrv</code> is a decedent of the value in question. However, this doesn’t work for types that don’t contain product types. For example, the matches of <code>Bool</code> are <code>True</code> and <code>False</code>; neither of which would produce a <code>PatternMatchPrv</code>.</p>
<p>But because <code>_jDestructed</code> is used only to prevent pattern matching, it filled a similar role to filtering out hypotheses via <code>withHypothesis</code>. In both cases we could have simply removed the value from hypotheses, and having removed it from the source of truth of what’s in scope would certainly prevent it from ever being used. But this also wreaked havoc with tracking provenance, as removing the value would also remove its provenance, so downstream children would become orphaned and wouldn’t know where they came from.</p>
<p>On the surface, this looks like a bug, but I don’t think it’s a bug in the true sense. Instead, this is a problem of insufficient reification. Removing a value from the in-scope set is again an <em>exploded view</em> of the data. It’s again not a feature of the problem, but the implementation. What we’d instead like to track is that a particular value is <em>disallowed,</em> rather than <em>non-existent.</em> And once something is declared disallowed, if we track the reason, later code can reevaluate for themselves whether that judgment is still a reasonable means for exclusion.</p>
<p>At the end of the day, I exposed a function <code>jHypothesis :: Judgment -&gt; Map OccName (HyInfo Type)</code> (not <code>_jHypothesis</code> — note the underscore!) which pro-actively filtered out all of the <code>DisallowedPrv</code> values in the <code>_jHypothesis</code>. This means the data that the <em>entire program sees is itself a view</em> on the real datastructure. Internally we can track disallowed values, and externally we don’t show the disallowed values unless explicitly asked for.</p>
<p>The result of all this refactoring is a delightfully simplified codebase. Its core datastructure is now correct-by-construction, meaning it’s impossible to produce an inconsistent value that was so common under the old formulation. Furthermore, no call-site needs to change; appropriate views on the data exist as shunts, invisible massaging the new datastructure into the old. These call-sites can (and should) be cleaned up to use the new datastructure more directly, but that can happen incrementally in subsequent changes. And best of all, our new data representation is infinitely more useful. Because it models the problem domain rather than the peculiarities of the implementation, it can be reused for future features. While the size of the old datastructure was <code>O(n)</code> in the number of features, this new one is <code>O(1)</code>.</p>
<hr />
<p>If you enjoyed this post, please consider picking up a copy of my new book <a href="https://algebradriven.design/">Algebra-Driven Design</a>. In it, you’ll learn techniques like this one to dramatically improve the quality, maintainability, and reusability of your software.</p>
      ]]></content:encoded>
  </item>
  <item>
      <title>Towards Tactic Metaprogramming in Haskell</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>http://reasonablypolymorphic.com/blog/towards-tactics/index.html</link>
      <guid>http://reasonablypolymorphic.com/blog/towards-tactics/index.html</guid>
      <pubDate>2020-10-12T00:40:00Z</pubDate>
      <content:encoded><![CDATA[
        <center>
<img src="/images/fmaptree.gif">
</center>
<p>Isn’t it weird that we treat source code as text? That is, we have this extremely well-structured and strongly-typed object — the abstract syntax tree — that exists conceptually in our minds, and in actuality inside of our compiler, but for some reason we pretend it’s just a pile of bytes and edit it byte-by-byte rather than semantically?</p>
<p>When you stop and think about it, that’s like the stupidest idea ever. We as the authors don’t think of our code as bytes, nor does our interpreter or compiler. But instead we take the semantic understanding inside of our heads, serialize it into bytes, and then get the compiler to parse and rediscover the ideas inside our head. What a waste of effort.</p>
<p>Instead, you can use the incredible <a href="https://totbwf.github.io/">TOTBWF</a> and my new Tactics Plugin for the <a href="https://github.com/haskell/haskell-language-server">Haskell Language Server</a>, which will automatically and intelligently fill holes in your Haskell programs.</p>
<p>This blog post describes what a tactics engine is and why you want one, and is a good introduction to how in the hell we can automatically write your code for you.</p>
<h2 id="tactics">Tactics</h2>
<p>Imagine you’re pair programming with a junior engineer. In the navigator seat, you’ll be guiding your partner through the implementation, guiding them through the high-level strokes and letting them actually do the coding part. In order to implement <code>foldr :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b</code>, for example, the guidance you give your partner might be:</p>
<ol type="1">
<li>Bind the function arguments</li>
<li>Case split on the <code>[a]</code> parameter</li>
<li>If it’s <code>[]</code>, do the obvious thing</li>
<li>Otherwise call your function and recurse.</li>
</ol>
<p>These instructions aren’t a real program by any means, but you might call them a “program sketch.” The hard part of programming (thinking about what to do) is captured here, but <em>actually doing it</em> is left as an exercise to the reader.</p>
<p>A tactics engine transforms a program sketch like the above into an actual program. Tactics free us from the tyranny of text editing and pedantic details, allowing us to work at a higher semantic level of programming.</p>
<p>Tactics correspond to semantic operations over our program. Much like how the primitive commands in text editors (delete to end of line, insert parentheses, etc) can be composed to refine the textual representation of one program into the textual representation of another, we can compose small tactics in order to build larger ideas.</p>
<p>As an example, consider how we can fill in the following hole:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Id</span> a <span class="ot">=</span> <span class="dt">Id</span> a</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">Id</span> <span class="kw">where</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="ot">  fmap ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Id</span> a <span class="ot">-&gt;</span> <span class="dt">Id</span> b</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>  <span class="fu">fmap</span> <span class="ot">=</span> _</span></code></pre></div>
<p>Rather than writing this function all at once, we can instead build it, one idea at a time. The first step is obviously to bind function arguments (the <code>intros</code> tactic), which results in the refined expression:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Id</span> a <span class="ot">-&gt;</span> <span class="dt">Id</span> b</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="fu">fmap</span> <span class="ot">=</span> \fab ida <span class="ot">-&gt;</span> _</span></code></pre></div>
<p>We’re left with a new hole, but this one is “smaller” than the old one; we’ve refined the previous hole, filling in some of its structure. As a result, the type of our new hole is <code>Id b</code>, and we now have both <code>fab :: a -&gt; b</code> and <code>ida :: Id a</code> in scope. We can simplify the hole further by now pattern matching on <code>ida</code> (the <code>destruct ida</code> tactic):</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Id</span> a <span class="ot">-&gt;</span> <span class="dt">Id</span> b</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a><span class="fu">fmap</span> <span class="ot">=</span> \fab ida <span class="ot">-&gt;</span> <span class="kw">case</span> ida <span class="kw">of</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>  <span class="dt">Id</span> a <span class="ot">-&gt;</span> _</span></code></pre></div>
<p>The resulting hole still has type <code>Id b</code>, but we’ve now introduced <code>a :: a</code> in scope. Our next step is to build an <code>Id</code> value, which we can do by producing its data constructor (the <code>split</code> tactic):</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Id</span> a <span class="ot">-&gt;</span> <span class="dt">Id</span> b</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="fu">fmap</span> <span class="ot">=</span> \fab ida <span class="ot">-&gt;</span> <span class="kw">case</span> ida <span class="kw">of</span></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>  <span class="dt">Id</span> a <span class="ot">-&gt;</span> <span class="dt">Id</span> _</span></code></pre></div>
<p>Again we’ve shrunk the problem — now our hole has type <code>b</code>. At this point we can call the <code>fab</code> function to produce a <code>b</code> (via the <code>apply fab</code> tactic):</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Id</span> a <span class="ot">-&gt;</span> <span class="dt">Id</span> b</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="fu">fmap</span> <span class="ot">=</span> \fab ida <span class="ot">-&gt;</span> <span class="kw">case</span> ida <span class="kw">of</span></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>  <span class="dt">Id</span> a <span class="ot">-&gt;</span> <span class="dt">Id</span> (fab _)</span></code></pre></div>
<p>All that’s left is a hole with type <code>a</code>. Fortunately, we have <code>a :: a</code> in scope, so we can just plop that in to the hole via the <code>assumption</code> tactic:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Id</span> a <span class="ot">-&gt;</span> <span class="dt">Id</span> b</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="fu">fmap</span> <span class="ot">=</span> \fab ida <span class="ot">-&gt;</span> <span class="kw">case</span> ida <span class="kw">of</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>  <span class="dt">Id</span> a <span class="ot">-&gt;</span> <span class="dt">Id</span> (fab a)</span></code></pre></div>
<p>And just like that, we’ve produced an implementation of our desired function! By thinking in terms of the semantic operations we’d like to perform at each hole (instead of how to manipulate the bytes of text), we’ve changed the level of abstraction at which we think about editing. The implications of this might not be immediately obvious, so let’s explore them together.</p>
<p>Let’s list the tactic steps we took to derive <code>fmap</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>intros</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>destruct ida</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>split</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>apply fab</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>assumption</span></code></pre></div>
<p>Up to alpha renaming, this composition of tactics is sufficient to derive <code>fmap</code> for any sum or product type that doesn’t do anything “exciting” with its type variable. By running the same steps, we can implement <code>fmap</code> for any of the following types:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>(a, b)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a><span class="dt">Either</span> a b</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a><span class="dt">Maybe</span> a</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a><span class="dt">Const</span> a b</span></code></pre></div>
<p>Let’s convince ourselves of this by quickly running through the derivation for <code>Maybe a</code>. We start again with <code>fmap</code> and its type:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a><span class="fu">fmap</span> <span class="ot">=</span> _</span></code></pre></div>
<p>After running <code>intros</code>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a><span class="fu">fmap</span> <span class="ot">=</span> \fab ma <span class="ot">-&gt;</span> _</span></code></pre></div>
<p>and then <code>destruct ma</code></p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a><span class="fu">fmap</span> <span class="ot">=</span> \fab ma <span class="ot">-&gt;</span> <span class="kw">case</span> ma <span class="kw">of</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> _</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>  <span class="dt">Just</span> a  <span class="ot">-&gt;</span> _</span></code></pre></div>
<p>Applying <code>split</code> here is a little tricky; technically it will force us to try both <code>Nothing</code> and <code>Just _</code> at each hole in a weird sort of quantum superposition. Let’s ignore this detail for right now, and come back to it immediately after finishing the derivation. Assuming we pick the right data cons, after <code>split</code> our program looks like this:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a><span class="fu">fmap</span> <span class="ot">=</span> \fab ma <span class="ot">-&gt;</span> <span class="kw">case</span> ma <span class="kw">of</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>  <span class="dt">Just</span> a  <span class="ot">-&gt;</span> <span class="dt">Just</span> _</span></code></pre></div>
<p>Now we run <code>apply fab</code>. Because <code>Nothing</code> doesn’t take any arguments, it didn’t produce any holes, so we need look only at the <code>Just</code> case:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a><span class="fu">fmap</span> <span class="ot">=</span> \fab ma <span class="ot">-&gt;</span> <span class="kw">case</span> ma <span class="kw">of</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>  <span class="dt">Just</span> a  <span class="ot">-&gt;</span> <span class="dt">Just</span> (fab _)</span></code></pre></div>
<p>and finally we run <code>assumption</code> to fill in the hole:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a <span class="ot">-&gt;</span> <span class="dt">Maybe</span> b</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a><span class="fu">fmap</span> <span class="ot">=</span> \fab ma <span class="ot">-&gt;</span> <span class="kw">case</span> ma <span class="kw">of</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a>  <span class="dt">Just</span> a  <span class="ot">-&gt;</span> <span class="dt">Just</span> (fab a)</span></code></pre></div>
<p>Look at that! Even though it would require significantly different editing commands to write the syntax of these two functor instances, they are both descried by the same composition of tactics. This is what I mean by “semantic editing,” we’re moving the algorithm for producing functor instances out of our heads and reifying it into something the computer understands. In essence, by writing <code>fmap</code> once, we can teach the computer how to write it for us in the future.</p>
<p>I mentioned earlier that <code>split</code> gives us some issues here. Reading closely, you’ll notice that there is nothing in our tactics that say we need to <code>split</code> the same data constructor that we just <code>destruct</code>ed. In actuality there are four different, valid programs that can be produced by the above set of tactics:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="fu">fmap</span> <span class="ot">=</span> \fab ma <span class="ot">-&gt;</span> <span class="kw">case</span> ma <span class="kw">of</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a>  <span class="dt">Just</span> a  <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a></span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a><span class="fu">fmap</span> <span class="ot">=</span> \fab ma <span class="ot">-&gt;</span> <span class="kw">case</span> ma <span class="kw">of</span></span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true"></a>  <span class="dt">Just</span> a  <span class="ot">-&gt;</span> <span class="dt">Just</span> (fab a)</span>
<span id="cb15-8"><a href="#cb15-8" aria-hidden="true"></a></span>
<span id="cb15-9"><a href="#cb15-9" aria-hidden="true"></a><span class="fu">fmap</span> <span class="ot">=</span> \fab ma <span class="ot">-&gt;</span> <span class="kw">case</span> ma <span class="kw">of</span></span>
<span id="cb15-10"><a href="#cb15-10" aria-hidden="true"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> _</span>
<span id="cb15-11"><a href="#cb15-11" aria-hidden="true"></a>  <span class="dt">Just</span> a  <span class="ot">-&gt;</span> <span class="dt">Nothing</span></span>
<span id="cb15-12"><a href="#cb15-12" aria-hidden="true"></a></span>
<span id="cb15-13"><a href="#cb15-13" aria-hidden="true"></a><span class="fu">fmap</span> <span class="ot">=</span> \fab ma <span class="ot">-&gt;</span> <span class="kw">case</span> ma <span class="kw">of</span></span>
<span id="cb15-14"><a href="#cb15-14" aria-hidden="true"></a>  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="dt">Just</span> _</span>
<span id="cb15-15"><a href="#cb15-15" aria-hidden="true"></a>  <span class="dt">Just</span> a  <span class="ot">-&gt;</span> <span class="dt">Just</span> (fab a)</span></code></pre></div>
<p>Choosing the “best” implementation of these possibilities is largely a matter of heuristics, which I plan to describe in a later post. For now, let’s just assume our tactics engine is smart enough to come up with the one you had in mind.</p>
<p>Of course, the real issue here is that nothing forces our <code>destruct</code> and <code>split</code> tactics to use the same data constructor. We can eliminate this ambiguity by noticing that in <code>fmap</code>, we’re not actually trying to destruct and then split, but instead we’re trying to implement a homomorphism (a structure-preserving function.) In order to preserve structure, we’d better map a data constructor to itself. So instead, let’s use the <code>homo</code> tactic instead of <code>destruct</code> and <code>split</code>. Our new tactics metaprogram for writing functor instances is thus:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a>intros</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>homo ida</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>apply fab</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>assumption</span></code></pre></div>
<p>This new version now can no longer generate any of the pathological <code>fmap</code> implementations for <code>Maybe</code>, as they are not structure preserving. We’re left only with the good implementation. Let’s do one more derivation, this time for <code>Either c a</code>. After <code>intros</code> and <code>homo eca</code>, we’re left with:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Either</span> c a <span class="ot">-&gt;</span> <span class="dt">Either</span> c b</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a><span class="fu">fmap</span> <span class="ot">=</span> \fab ma <span class="ot">-&gt;</span> <span class="kw">case</span> eca <span class="kw">of</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>  <span class="dt">Left</span>  c <span class="ot">-&gt;</span> <span class="dt">Left</span> _</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a>  <span class="dt">Right</span> a <span class="ot">-&gt;</span> <span class="dt">Right</span> _</span></code></pre></div>
<p>For the first time, we’re now left with <em>two</em> holes. The default behavior is for a tactic to apply to all holes (although there are combinators for “zipping” holes), meaning that the <code>apply fab</code> tactic will be run on both holes. For the <code>Left</code> case, our hole has type <code>c</code>, but <code>fab _</code> has type <code>b</code>, so this tactic <em>fails to apply here.</em> Tactic failure is per-hole, so we can still apply it to the other hole, resulting in:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Either</span> c a <span class="ot">-&gt;</span> <span class="dt">Either</span> c b</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a><span class="fu">fmap</span> <span class="ot">=</span> \fab ma <span class="ot">-&gt;</span> <span class="kw">case</span> eca <span class="kw">of</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a>  <span class="dt">Left</span>  c <span class="ot">-&gt;</span> <span class="dt">Left</span> _</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a>  <span class="dt">Right</span> a <span class="ot">-&gt;</span> <span class="dt">Right</span> (fab _)</span></code></pre></div>
<p>And finally, <code>assumption</code> fills the hole with whatever would typecheck. In the first hole that’s <code>c</code>, and in the second it’s <code>a</code> as before.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="fu">fmap</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Either</span> c a <span class="ot">-&gt;</span> <span class="dt">Either</span> c b</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a><span class="fu">fmap</span> <span class="ot">=</span> \fab ma <span class="ot">-&gt;</span> <span class="kw">case</span> eca <span class="kw">of</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a>  <span class="dt">Left</span>  c <span class="ot">-&gt;</span> <span class="dt">Left</span> c</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a>  <span class="dt">Right</span> a <span class="ot">-&gt;</span> <span class="dt">Right</span> (fab a)</span></code></pre></div>
<p>Amazing! Three different functor implementations, with different numbers of data constructors, type variables, and cardinalities. By programming at the level of tactics rather than bytes, we can ignore the superficial differences between these implementations, focusing instead on the fact that they’re all derived the same way.</p>
<p>Hopefully this post has given you some insight into what tactics are and why they’re valuable. In the next post we’ll look at how this stuff is implemented behind the scenes, and the difficulties we’ve had integrating it into the language server. Stay tuned!</p>
      ]]></content:encoded>
  </item>
  <item>
      <title>Algebra-Driven Design</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>http://reasonablypolymorphic.com/blog/algebra-driven-design/index.html</link>
      <guid>http://reasonablypolymorphic.com/blog/algebra-driven-design/index.html</guid>
      <pubDate>2020-09-10T16:55:00Z</pubDate>
      <content:encoded><![CDATA[
        <p>After almost a year of work, I’m <em>thrilled</em> to announce the completion my new book, <a href="https://algebradriven.design">Algebra-Driven Design</a>. It’s the culmination of two rewrites, and comes with a beautiful foreword written by John Hughes, the inventor of QuickCheck.</p>
<p>In the book, we take a fundamentally different approach to the software design process, focusing on deriving libraries from equations, algebraic manipulation and well-studied mathematical objects. The resulting code is guaranteed to be free of abstraction leaks, and in many cases, actually writes itself.</p>
<p>If that sounds like the sort of software you’d like to write, I’d highly encourage you to <a href="https://algebradriven.design">give it a read</a>.</p>
<center>
<a href="https://algebradriven.design"><img src="/images/add.png" alt="Algebra-Driven Design"></a>
</center>
      ]]></content:encoded>
  </item>
  <item>
      <title>Polysemy: Mea Culpa</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>http://reasonablypolymorphic.com/blog/mea-culpa/index.html</link>
      <guid>http://reasonablypolymorphic.com/blog/mea-culpa/index.html</guid>
      <pubDate>2020-06-14T22:36:00Z</pubDate>
      <content:encoded><![CDATA[
        <p><a href="https://lexi-lambda.github.io/">Alexis King</a> gave an <a href="https://www.youtube.com/watch?v=0jI-AlWEwYI">utterly fantastic talk</a> today on the deep inner workings of Haskell programs’ performance profiles. It’s really very excellent and you should go watch it if you haven’t already. I’ve been extremely <a href="https://sandymaguire.me/blog/burnout/">burned out</a> on Polysemy and effect-system-related topics lately, but it seems like as good a time as any to discuss what’s going on with the library. Why do Alexis’ benchmarks clearly show something other than my claim that Polysemy was “zero cost?” In short:</p>
<p>I screwed up.</p>
<p>The core Haskell that’s being run in Alexis’ benchmark probably looks <a href="https://gist.github.com/isovector/e4832512ec9c73bff94432a7a58470f9#file-t16473-dump-simpl">like this</a>, though at one point I did indeed get the countdown benchmark to completely <a href="https://gist.github.com/isovector/e4832512ec9c73bff94432a7a58470f9#gistcomment-2883147">optimize away.</a> My claim to being zero-cost was based on this result, which was possible, but required <a href="https://gitlab.haskell.org/ghc/ghc/merge_requests/668">patching GHC</a>, enabling <code>-flate-specialise -O2 -fstatic-argument-transformation -fmax-simplifier-iterations=10</code> as well as a <a href="https://gist.github.com/isovector/e4832512ec9c73bff94432a7a58470f9#gistcomment-2872671">GHC patch cajoling the optimizer into running extra hard.</a></p>
<p>My patch to GHC just barely missed the 8.8 deadline, which meant it wouldn’t be publicly available until GHC 8.10, roughly a year away. And until then, Polysemy had no chance of being fast.</p>
<p>The result of all this: fast code, relying on a house of cards of optimization, only on a compiler that didn’t exist yet. It worked, but was a huge hassle to test, and because of that, I didn’t do it very often, nor did I make it easy for others to verify my claims.</p>
<p>My mindset has always been that the “free monads are too slow” argument is overblown and irrelevant to 99% of programs, and my original goal with Polysemy was to show that there was nothing fundamentally wrong with the approach; that if we tried hard enough, we really could pull amazing performance out of free monads.</p>
<p>It’s been about a year now, so my recollection is hazy, but I think I must have somehow conflated “fast programs are possible in Polysemy” with “Polysemy is zero-cost.” There was absolutely no deception intended, but it appears I deceived myself, and the community because of that. I’m sorry.</p>
<p>Sometime near the end of 2019, Lexi showed me her research into why the effect system benchmarks were extremely misleading (as mentioned in her talk.) Her research made it very evident that all effect systems were “cheating” in the benchmark shootout, and I attributed Polysemy’s pre-super-optimized terrible benchmark numbers to “not cheating as much.” If the optimizer was what was making other effect systems fast, but only in single-module programs, presumably they would also perform badly in real-world, multiple-module programs, and would see the same performance characteristics as Polysemy. I didn’t confirm this experimentally.</p>
<p>Plus, I figured, if performance <em>truly is</em> a problem, and not the overactive fear I thought it was, surely someone would have filed a bug complaining that Polysemy wasn’t as fast as it claimed. To date, nobody has filed that bug, and I continue to believe it’s an overblown issue — though that isn’t to say we shouldn’t fix it if we can. Lexi’s package <a href="https://github.com/hasura/eff">eff</a> seems to be working towards that solution, and I applaud her for all of the work she’s been putting into this problem.</p>
<p>So that’s more or less the story. But there are a few loose ends; such as why Lexi and I are seeing different benchmarking results. I realize this doesn’t actually matter, and I agree with her that Polysemy <em>is in fact slow.</em> That being said, I feel like enough of my reputation is on the line that I’d like to put towards some more evidence that I didn’t fabricate the whole thing. Also, the investigation will unearth some more systematic problems.</p>
<p>First and foremost, the last time I looked at the source of Lexi’s benchmarks, I noted that they don’t use <code>polysemy-plugin</code>, which <a href="https://github.com/polysemy-research/polysemy#stellar-engineering---aligning-the-stars-to-optimize-polysemy-away">the documentation states is necessary for the good performance</a>. I don’t remember where these benchmarks actually are, but it doesn’t matter, because even if she had enabled the plugin, Polysemy <em>would still not optimize away.</em></p>
<p>Why not? Polysemy’s performance was extremely reliant on unfolding of its recursive bind operation. As <a href="https://reasonablypolymorphic.com/blog/writing-custom-optimizations/#inlining-recursive-calls">described here</a>, you could trick GHC into unfolding a recursive call once by explicitly giving a loop-breaker. In essence, it required transforming the following recursive call:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="ot">factorial ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>factorial <span class="dv">0</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>factorial n <span class="ot">=</span> n <span class="op">*</span> factorial (n <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="ot">{-# INLINE factorial #-}</span></span></code></pre></div>
<p>Into this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="ot">factorial ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>factorial <span class="dv">0</span> <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>factorial n <span class="ot">=</span> n <span class="op">*</span> factorial&#39; (n <span class="op">-</span> <span class="dv">1</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a><span class="ot">{-# INLINE factorial #-}</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a><span class="ot">factorial&#39; ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>factorial&#39; <span class="ot">=</span> factorial</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a><span class="ot">{-# NOINLINE factorial&#39; #-}</span></span></code></pre></div>
<p>For whatever reason, this trick exposes enough of Polysemy’s bind so that the simplifier could inline away the expensive bits. But this was tedious! Every recursive call needed an explicit loop-breaker, and missing one would silently jeopardize your performance! Doing this by hand seemed antithetical to Polysemy’s other goal of no-boilerplate, and so at some point we factored out this logic into a GHC plugin, and then <a href="https://github.com/polysemy-research/polysemy/commit/8bbd9dc7d6ff1d55c9f8ea5f7f160ecf337d0e6e#diff-a6a5069006aaf9c213df8bfcf538bda8">removed our hand-written loop-breakers.</a>. The initial implementation of that plugin is described <a href="https://reasonablypolymorphic.com/blog/writing-custom-optimizations/">in this blog post</a>.</p>
<p>In retrospect, this explicit breaking-of-loops doesn’t seem to be required in the benchmark — only in Polysemy — but that escaped my attention at the time and believing that user-code required this optimization was the main motivation in turning it into a GHC plugin. Anyway…</p>
<p>As it turns out, this plugin <em>didn’t actually work!</em> It was successfully rewriting the core into the explicitly loop-broken version, but for whatever reason, <a href="https://github.com/polysemy-research/polysemy/pull/90#issuecomment-500090395">the simplifier wasn’t picking up where we left off.</a> To this day I don’t know why it doesn’t work, but it doesn’t. Instead we proposed to implement this plugin as a renamer pass, but that presents serious implementation problems. Since there was no way in hell Polysemy could possibly be fast before GHC 8.10 (to be released roughly a year in the future) motivation to find a solution to this problem was understandably low, and it fell by the wayside. It has never been fixed, and remains disabled and half-worked around in Polysemy to this day.</p>
<p>Hopefully this is the only reason why Polysemy doesn’t show the excellent (though, admittedly unrepresentative) countdown benchmark results I claimed it did. I’m not invested enough to check for myself, but if you’re interested, I suspect you’ll see excellent core produced by <a href="https://gist.github.com/isovector/e4832512ec9c73bff94432a7a58470f9#gistcomment-2883144">my single-file repro</a> if you compile it on GHC 8.10 under <code>-O2</code> with the <code>polysemy-plugin</code> and the above flags enabled. If so, I suspect rolling back <a href="https://github.com/polysemy-research/polysemy/commit/8bbd9dc7d6ff1d55c9f8ea5f7f160ecf337d0e6e">#8bbd9dc</a> would get the real Polysemy library also doing well on the benchmark. But again, <em>the benchmark performance is meaningless!</em></p>
<hr />
<p>Enough history for today. Before ending this post, I’d like to do a tiny <a href="https://www.hillelwayne.com/post/stamping-on-eventstream/">STAMP</a> on what went wrong, in the hope that we can all learn something. The goal here is not to pass the buck, but to get a sense of just how much went wrong, how, and why.</p>
<p>By my analysis, the following issues all contributed to Polysemy’s colossal failure:</p>
<ul>
<li>Haskell’s performance is not well understood
<ul>
<li>The effect system benchmarks were meaningless, and if anyone knew that, it was not common knowledge.</li>
<li>MTL is widely believed to be more performant than it is.</li>
<li>Existing effect systems’ performance is tied largely to GHC’s optimizer firing.</li>
<li>Because of lack of understanding, I was tackling bad-performance symptoms rather than causes.</li>
</ul></li>
<li>Polysemy’s performance was unreliable
<ul>
<li>Required several interlocking pieces to work: a patched compiler, a core plugin, explicit loop-breakers, obscure GHC options.</li>
<li>Because the performance was hard to test, we didn’t notice when these pieces didn’t work.
<ul>
<li>Upon noticing the loop-breaking plugin didn’t work, it was unclear how to fix it.
<ul>
<li>Because of requiring a patched GHC, it was not a priority to fix.
<ul>
<li>Not being a priority meant it wasn’t motivating, and so it didn’t get done.</li>
</ul></li>
</ul></li>
</ul></li>
<li>Debugging the simplifier is hard work. I was looking at thousands of lines of generated core by eye. <a href="https://github.com/yav/dump-core">Tooling exists</a>, but it is more helpful for navigating core than diffing it.</li>
</ul></li>
<li>Polysemy’s performance was too hard to test.
<ul>
<li>I missed the GHC deadline
<ul>
<li>My patch lingered for weeks in a finished state
<ul>
<li>Only reviewable by one person, who was on vacation.</li>
<li>Stuck doing drive-by improvements that were only suggestions, and not blockers to being merged. This was not made clear to me.</li>
<li>The simplifier is really hairy. It’s under-documented, and the function I was touching was over 150 lines of code.</li>
</ul></li>
</ul></li>
<li>I use Stack for my development, Stack doesn’t easily support custom-built GHCs. Therefore I couldn’t use my usual tools to test.</li>
<li>I don’t know how to use cabal
<ul>
<li>The documentation is notoriously lacking. As best I can tell, there are no “quick start” tutorials, and the relevant parts of the user manual are mentioned only under a heading that mentions “Nix”.</li>
</ul></li>
<li>Because of the above two points, I only tested on the single module, and never on the library itself.</li>
</ul></li>
<li>I had too much ego in the project.
<ul>
<li>I wanted to believe I had accomplished something “impossible.”</li>
<li>I had invested several engineering-months of my time working on this problem.</li>
<li>I had invested a large chunk of my reputation into free monads.</li>
</ul></li>
</ul>
<p>This post is long enough without diving into those points in more detail, but I’m happy to expand on individual points. Let me know in the comments if you’re interested.</p>
<p>All in all, this is has been the embarrassing affair. But then again, <em>if you haven’t failed in recent memory, you’re not trying hard enough.</em> I’ll strive to do better in the future.</p>
      ]]></content:encoded>
  </item>
  <item>
      <title>A Working Linux DAW</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>http://reasonablypolymorphic.com/blog/linux-daw/index.html</link>
      <guid>http://reasonablypolymorphic.com/blog/linux-daw/index.html</guid>
      <pubDate>2020-02-13T00:30:00Z</pubDate>
      <content:encoded><![CDATA[
        <p>I’ve recently been watching <a href="https://www.youtube.com/channel/UCMHG0rJtVF1LohiP63FJakw">Guy Michelmore’s youtube videos on composing music</a>. “That looks pretty easy” I thought to myself, which led to accidentally buying a <a href="https://www.native-instruments.com/en/products/komplete/keyboards/komplete-kontrol-m32/">Native Instruments M32</a> and attempting to compose music for myself.</p>
<p>As it happens, writing music is much harder than I gave it credit for. But an overwhelming amount of that difficulty is for bullshit reasons. You see, for whatever reason, the world of digital music production is a world awash in stupid <a href="https://i0.wp.com/www.macosaudio.com/wp-content/uploads/2018/06/Klevgrand-DAW-LP.jpg?resize=700%2C349&amp;ssl=1">dial UIs</a> and proprietary software.</p>
<p>When I say proprietary software, I don’t just mean the mixing software itself. I also mean all of the drivers for the peripherals. I also also mean all of the digital instruments. Extremely frustratingly, I also also <em>also</em> mean even the software to <em>download this stuff.</em> EVEN THOUGH IT’S ALL JUST OVER HTTP ANYWAY!</p>
<p>Anyway, I thought I should probably write down the things I’ve learned to hopefully help keep future linux musicians sane.</p>
<h2 id="digital-audio-workstation-daw">Digital Audio Workstation (DAW)</h2>
<p><strong>Go with <a href="">REAPER DAW</a>.</strong></p>
<p>I started with LMMS because a quick search for “linux daw” suggested I use it. After a few days of learning it, this turned out to be a bad idea. The UI is frustrating, and instrument plugins don’t work very well.</p>
<p>REAPER, on the other hand, feels really good. Once you get it working. I had a few issues getting sound working. I had to choose the “ALSA” backend, and turn off the “auto-disable PulseAudio” setting. Unfortunately the PulseAudio backend was introducing ~200ms of latency between hitting notes and hearing them. <strong>Try using the ALSA backend if you are experiencing sound latency.</strong></p>
<p>You can use the <code>ReaSynth</code> virtual instrument to try testing your audio.</p>
<h2 id="audio-plugins-vsts">Audio Plugins (VSTs)</h2>
<p>Out of the box, REAPER is pretty shit. It doesn’t come with anything good, and so we’ll need to add some before we can get to making music. There are lots of great VSTs out there, but almost all of them are Windows-only. But fear not!</p>
<p>If you install <a href="https://wiki.winehq.org/Wine-Staging">wine-staging</a>, you can use it to download some good, free instruments from <a href="https://www.spitfireaudio.com/labs/">Spitfire LABS</a>. You’ll need to sign up for an account, install the (ahem) propriety software, and then press the “GET” button on the LABS website. That… somehow authorizes your account, and then the proprietary software will let you download your files.</p>
<p>Particularly resourceful readers can also probably find copies of <a href="https://www.native-instruments.com/en/products/komplete/synths/massive/">Massive</a> and <a href="https://www.native-instruments.com/en/products/komplete/samplers/kontakt-6/">Kontakt</a> too.</p>
<p><strong>Make sure you get the 32bit Windows editions of any VSTs you find.</strong></p>
<p>Now, none of these VSTs actually work in REAPER, but thankfully, <strong>there’s a program called <a href="https://github.com/psycha0s/airwave">Airwave</a> that can convert Windows VSTs into Linux ones.</strong> Move your 32bit VST .dlls into <code>~/.wine/drive_c</code>, then ask Airwave to install them into <code>~/.vst</code> for you. Make sure this is the VST path for REAPER.</p>
<p>Back in REAPER, press <code>CTRL+P</code> and then <code>Plugins &gt; VST</code>. Make sure the VST plugin path says <code>~/.vst</code>, and then hit the <strong>Re-scan</strong> button. If you’re lucky, you should now be able to right-click in the main window and click “Insert virtual instrument on new track” and find your new VSTs under <code>All Plugins &gt; New</code>.</p>
<h2 id="midi-controller">MIDI Controller</h2>
<p>My M32 keyboard worked out of the box, sorta. The keys play keys in REAPER, and the dials are successfully recognized as inputs. But none of the useful “DAW control” buttons work. More proprietary software, hidden behind enough bullshit that I couldn’t even find it to test if it worked under wine.</p>
<p><strong>I would not recommend the NI M32 due to the amount of bullshit their lack of Linux support put me through.</strong></p>
<p>But if you’re stuck with one… I decided to <a href="https://github.com/isovector/free-m32">reverse engineer the protocol and write a little driver</a>. This program requires <code>xdotool</code>, and maps button presses on the M32 into keypresses. At time of writing, it just types regular English characters — unfortunate because they’re likely to conflict with other bindings, but REAPER doesn’t recognize most linux keysyms. Also, it only intermittently recognizes high-ASCII characters. What a piece of shit. I spent four hours today fighting with this.</p>
<hr />
<p>This is the critical path I took from not knowing anything about music production to having a mostly-working setup. Knowing what I do now, it would only take 30 minutes to setup, but this blog post is the culmination of about a week of pain! Not all of it was bad though — I got to learn a lot about reverse engineering, and expect a blog post on that in the near future!</p>
      ]]></content:encoded>
  </item>
  <item>
      <title>Low-Tech AST Extensibility with Extension Patterns</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>http://reasonablypolymorphic.com/blog/extension-patterns/index.html</link>
      <guid>http://reasonablypolymorphic.com/blog/extension-patterns/index.html</guid>
      <pubDate>2019-11-27T22:15:00Z</pubDate>
      <content:encoded><![CDATA[
        <p>Today I want to share a common pattern I’ve been using for extending AST-like data structures that I don’t own. It’s an extremely low-tech solution to the problem (as opposed to something like the dreaded <a href="https://www.microsoft.com/en-us/research/uploads/prod/2016/11/trees-that-grow.pdf">Trees That Grow</a>, which is more far complicated than any problem is worth.)</p>
<p>A common problem I run into is wanting to add custom annotations to abstract syntax trees. As one example, a while back I was writing a Haskell editor that would <em>write Haskell code for you.</em> The idea was to get rid of the text representation of code entirely, and work directly with the Haskell AST. However, it’s often useful to insert metadata into the AST — for example, which bit of the tree you’re currently editing.</p>
<p>As another example, I’m currently writing a book in markdown, and want to express high-level concepts that markdown doesn’t have any primitives for — things like <em>exercises</em> or <em>inline this snippet of code from a real codebase</em> or <em>this thing is like a footnote, but should have a special graphic.</em> If I were a pleb, I’d just manually write the low-level markdown necessary to achieve the visual goal I want.</p>
<p>But: two problems. Firstly, I did that on the last book, and it turned out to be the biggest mistake I’ve made in quite a long time. The issue is that while this works for the representation you’re currently looking at, it all falls apart when you want to change the representation. My book looked great as a PDF, but it took me weeks and literal tears to turn that thing into an e-book.</p>
<p>Secondly, this book I’m writing is <em>all about</em> how the root of all evil is a premature loss of precision — which is to say, it’s about designing and using abstractions. The irony would be too salty if I didn’t take my own advice here and build my book out of the abstractions I claim are so valuable.</p>
<p>So this is the question: how can we add new abstraction primitives to a datatype that we don’t control?</p>
<p>Let’s take a particular example that I implemented today. In <a href="http://journal.stuffwithstuff.com/2015/09/08/the-hardest-program-ive-ever-written/">The Hardest Program I’ve Ever Written</a>, Bob Nystrom walks through the implementation of an interesting program. Throughout the prose, there are little skulls which are footnotes describing a wrong path he took during the implementation. These mistakes are, in my opinion, more interesting than the essay itself.</p>
<p>My book has a few case studies in which I work through building a real program using the techniques I’m advocating. The idea is to give readers an actual taste of how it works in practice, and to show that often times the journey is more valuable than the destination. As such, I thought Bob’s skull footnotes would make an excellent addition to these chapters.</p>
<p>I dug in to see how Bob had implement his, and I was amazed! <a href="https://raw.githubusercontent.com/munificent/journal/master/_posts/2015-09-08-the-hardest-program-ive-ever-written.md">The poor bastard had done it all by hand!</a> My god, if that’s not commitment, I don’t know what is. There are like seventeen footnotes in that blog post. Someone should probably make Bob a saint for just how how patient he must be.</p>
<p>While this is commendable, it is antithetical to our purposes. This is clearly an abstraction leak; markdown is supposed to be human-readable format that eschews 15th-century technology like HTML. As soon as you have an abstraction leak, your abstraction is worth nothing. At this point it will only bring you pain.</p>
<p>But what can we do instead?</p>
<p>Well, my book is being authored in markdown, and then processed via <a href="https://pandoc.org/">pandoc</a> to turn it into pretty PDFs. I’ve separated the semantic bits from the presentation bits, in an act of forward thinking for when I make an e-book copy. What this means is that, <em>even though I’m writing markdown,</em> my book is actually a Pandoc document. Which is to say, there is a <a href="https://hackage.haskell.org/package/pandoc-types-1.17.6.1/docs/Text-Pandoc-Definition.html#t:Block">Text.Pandoc.Definition.Block</a> somewhere in the platonic realm that describes my book.</p>
<p>And so we return to the question of how to annotate ASTs. The <a href="https://hackage.haskell.org/package/pandoc-types-1.17.6.1/docs/Text-Pandoc-Definition.html#t:Block">Pandoc AST</a> is a rather expressive format, but it primarily describes basic typographic elements. It primarily captures meaning as to how to layout a document, rather than capturing the meaning of <em>what is being expressed.</em></p>
<p>While Pandoc already has the option to <a href="https://hackage.haskell.org/package/pandoc-types-1.17.6.1/docs/Text-Pandoc-Definition.html#t:Inline">annotate a Footnote</a>, I don’t want to replace all footnotes with deathnotes (as I’ve taken to calling these little skull things.)</p>
<p>The trick is a rather stupid one. While usual footnotes are written in markdown like this:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode markdown"><code class="sourceCode markdown"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>This is some prose<span class="ot">[^1]</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="ot">[^1]: </span>This is a footnote.</span></code></pre></div>
<p>I’ve decided to annotate my deathnotes like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode markdown"><code class="sourceCode markdown"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>This is some prose<span class="ot">[^1]</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="ot">[^1]: </span>death This is a deathnote.</span></code></pre></div>
<p>The only difference is that the text of a deathnote starts with the word <code>death</code>. That’s it. There is nothing clever going on here. When parsed into a <code>Block</code>, the above has this structure:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="dt">Para</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>  [ <span class="dt">Str</span> <span class="st">&quot;This&quot;</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>  , <span class="dt">Space</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>  , <span class="dt">Str</span> <span class="st">&quot;is&quot;</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>  , <span class="dt">Space</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true"></a>  , <span class="dt">Str</span> <span class="st">&quot;some&quot;</span></span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true"></a>  , <span class="dt">Space</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true"></a>  , <span class="dt">Str</span> <span class="st">&quot;prose&quot;</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true"></a>  , <span class="dt">Note</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true"></a>    [ <span class="dt">Para</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true"></a>      [ <span class="dt">Str</span> <span class="st">&quot;death&quot;</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true"></a>      , <span class="dt">Space</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true"></a>      , <span class="dt">Str</span> <span class="st">&quot;This&quot;</span></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true"></a>      , <span class="dt">Space</span></span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true"></a>      , <span class="dt">Str</span> <span class="st">&quot;is&quot;</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true"></a>      , <span class="dt">Space</span></span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true"></a>      , <span class="dt">Str</span> <span class="st">&quot;a&quot;</span></span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true"></a>      , <span class="dt">Space</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true"></a>      , <span class="dt">Str</span> <span class="st">&quot;deathnote.&quot;</span></span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true"></a>      ]</span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true"></a>    ]</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true"></a>  ]</span></code></pre></div>
<p>The bit of interest to us is the part of the AST that begins <code>Note [ Para [ Str "death"</code>. Because this is an easy thing to annotate directly in markdown, and because it won’t happen by accident, we can decide that this is the canonical representation for annotating a deathnote.</p>
<p>Here’s the trick: we can reify that decision in Haskell via a pattern synonym. If you’re unfamiliar with pattern synonyms, they allow you to “create” “new” data constructors, which are just synonyms for arbitrary patterns you’d like to pick out. In our case, we want to pick out that <code>Note [ Para [ Str "death"</code> structure.</p>
<p>We begin by writing a little function that will pattern match on the part we want, and remove the word <code>"death"</code> from the first paragraph.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="ot">splitDeathNote ::</span> [<span class="dt">Block</span>] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> [<span class="dt">Block</span>]</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>splitDeathNote (<span class="dt">Para</span> (<span class="dt">Str</span> <span class="st">&quot;death&quot;</span> <span class="op">:</span> ps) <span class="op">:</span> bs)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">Just</span> (<span class="dt">Para</span> (<span class="fu">dropWhile</span> (<span class="op">==</span> <span class="dt">Space</span>) ps) <span class="op">:</span> bs)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a>splitDeathNote _ <span class="ot">=</span> <span class="dt">Nothing</span></span></code></pre></div>
<p>The function <code>splitDeathNote</code> will try to match our deathnote pattern, and if it succeeds, give back the rest of the content. As a second step, we enable <code>-XViewPatterns</code> and <code>-XPatternSynonyms</code> and write a pattern:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">pattern</span> <span class="dt">DeathNote</span><span class="ot"> ::</span> [<span class="dt">Block</span>] <span class="ot">-&gt;</span> <span class="dt">Inline</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a><span class="kw">pattern</span> <span class="dt">DeathNote</span> bs <span class="ot">&lt;-</span> <span class="dt">Note</span> (splitDeathNote <span class="ot">-&gt;</span> <span class="dt">Just</span> bs)</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a>    <span class="dt">DeathNote</span> (<span class="dt">Para</span> ps <span class="op">:</span> bs) <span class="ot">=</span> <span class="dt">Note</span> <span class="op">$</span> <span class="dt">Para</span> (<span class="dt">Str</span> <span class="st">&quot;death&quot;</span> <span class="op">:</span> <span class="dt">Space</span> <span class="op">:</span> ps) <span class="op">:</span> bs</span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a>    <span class="dt">DeathNote</span> bs             <span class="ot">=</span> <span class="dt">Note</span> <span class="op">$</span> <span class="dt">Para</span> [<span class="dt">Str</span> <span class="st">&quot;death&quot;</span>] <span class="op">:</span> bs</span></code></pre></div>
<p>Patterns have egregious syntax, but it can be read in two parts. The first bit is the <code>pattern DeathNote bs &lt;- Note ...</code> bit, which is used for defining a <em>pattern match.</em> It says, “if you do a pattern match on the thing left of the <code>&lt;-</code>, instead replace it with the pattern match on the right. This weird <code>-&gt;</code> thing is a <em>view pattern,</em> which says”run the <code>splitDeathNote</code> function, and only match if it returns a <code>Just</code>."</p>
<p>The other part of the pattern synonym, the part after the <code>where</code>, allows us to <em>build an <code>Inline</code> out of a <a href="https://hackage.haskell.org/package/pandoc-types-1.17.6.1/docs/Text-Pandoc-Definition.html#t:Block">Block</a>.</em> Which is to say, it works like a data constructor; we can write something like <code>let foo = DeathNote blah</code>.</p>
<p>In other words, after defining the <code>DeathNote</code> pattern synonym, for all intents and purposes it’s like we’ve added a new data constructor to the pandoc <code>Inline</code> type. For example, we can write a function that pattern matches on it:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="ot">isDeathNote ::</span> <span class="dt">Inline</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>isDeathNote (<span class="dt">DeathNote</span> _) <span class="ot">=</span> <span class="dt">True</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>isDeathNote _ <span class="ot">=</span> <span class="dt">False</span></span></code></pre></div>
<p>GHC will happily compile this thing, and it will work as expected! Cool!</p>
<p>The final step to actually getting these things working is to walk the pandoc AST, and transform our nice, newly-annotated deathnotes into something more amenable for a PDF. But! We want to do this <em>as part of generating a PDF.</em> That way we hold onto our semantic annotations until the <em>very last moment,</em> i.e., when we send our document to the printers.</p>
<p>We can get this transformation for free via <a href="https://www.stackage.org/lts-14.16/package/syb-0.7.1">Scrap Your Boilerplate</a>(SYB for short.) SYB lets us write tiny transformations that operate only on a piece of data that we care about, and then lift that into a leaf-first transformation over arbitrarily large data structures.</p>
<p>In our case, we can write a function like this:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="ot">renderDeathNoteForLatex ::</span> <span class="dt">Inline</span> <span class="ot">-&gt;</span> <span class="dt">Inline</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>renderDeathNoteForLatex (<span class="dt">DeathNote</span> bs) <span class="ot">=</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>  <span class="dt">RawInline</span> <span class="st">&quot;latex&quot;</span> <span class="op">$</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>    <span class="fu">mconcat</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>      [ <span class="st">&quot;\\deathnote{&quot;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true"></a>      , <span class="fu">show</span> bs  <span class="co">-- the real implementation doesn&#39;t use show</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true"></a>      , <span class="st">&quot;}&quot;</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true"></a>      ]</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true"></a>renderDeathNoteForLatex x <span class="ot">=</span> x  <span class="co">-- just id for all other nodes</span></span></code></pre></div>
<p>And then use SYB to lift it over the entire <code>Pandoc</code> structure</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="ot">latexPreProcess ::</span> <span class="dt">Pandoc</span> <span class="ot">-&gt;</span> <span class="dt">Pandoc</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>latexPreProcess <span class="ot">=</span> everywhere (mkT renderDeathNoteForLatex)</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>  <span class="co">-- we can potentially run other transformations here at the same time</span></span></code></pre></div>
<p>And just like that, we’ve added a custom annotation to markdown, and separately given a presentation strategy for it. We can use <a href="http://hackage.haskell.org/package/pandoc-types-1.20/docs/Text-Pandoc-JSON.html#v:toJSONFilter"><code>toJSONFilter</code></a> to connect our little <code>latePreProcess</code> transformation to <code>pandoc</code>, and no one is any the wiser.</p>
      ]]></content:encoded>
  </item>
  <item>
      <title>Haskell2020 Is Dead, but All Hope Is Not Lost</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>http://reasonablypolymorphic.com/blog/haskell202x/index.html</link>
      <guid>http://reasonablypolymorphic.com/blog/haskell202x/index.html</guid>
      <pubDate>2019-11-01T10:39:00Z</pubDate>
      <content:encoded><![CDATA[
        <p>Haskell2020 is the long-awaited sequel to Haskell2010 — a formal, prescriptive standard of the Haskell language, that all implementations should adhere to. Today we have two previous standards, Haskell2010 and Haskell98, but neither is particularly in-line with the language as it’s written in this day and age. The aim of Haskell2020 is to bring these older standards in line with the way the language is actually practiced.</p>
<p>Today, there is only one real implementation of Haskell: the Glasgow Haskell Compiler (GHC). GHC is a Haskell2010-compliant compiler, but extends Haskell via <em>language extensions</em> — explicitly opt-in features that deviate from the standard. In GHC 8.6.5, there are 125 different language extensions, and <a href="https://gist.github.com/atondwal/ee869b951b5cf9b6653f7deda0b7dbd8">an analysis</a> shows that 10% of Haskell files in the wild enable 10 or more extensions.</p>
<p>All of this is to say that a good chunk of the Haskell being written in the real world <em>is not Haskell2010 compatible.</em> And the situation is only going to get worse.</p>
<p>It might not be immediately evident to you why this is a bad thing. As excellent a piece of software as GHC is, tying our language to a single implementation is unwise and shortsighted. As long as Haskell is defined implicitly by its implementation in GHC, no other implementation has a chance — they will always be forever playing catch-up.</p>
<p>C++ was in a similar situation in the early naughties; the de facto C++ compiler GCC was the only heavy-hitter in town. While it got the job done, it had some pretty terrible ergonomics — so bad that it spun up a cottage industry of attempting to <a href="https://codegolf.stackexchange.com/questions/1956/generate-the-longest-error-message-in-c">generate the worst error messages</a>. In 2007, Clang — an alternative industrial-strength compiler — was released, which strove to be compatible with GCC, but also to dramatically improve the ergonomics. This friendly competition has spurred both projects to become significantly better.</p>
<p>And we have seen similar beneficial competition (albeit certainly less friendly) in the Haskell world. Five years ago, Cabal sort-of got the job done for building Haskell projects, but there was this thing called “Cabal Hell” that bit <em>everyone.</em> It got the job done if you knew how it worked, which all the developers did, but the pain was felt by everyone else. Then Stack was released, which elegantly solved Cabal Hell, and <em>just worked.</em> It wasn’t perfect, but my god was it an improvement on the state of the world. In recent memory, Cabal has seen unparalleled improvements in its usability, after languishing for <em>years</em> with respect to usability complaints.</p>
<p>My point? Competition is a good thing, not just for users, but for the health of the ecosystem at large. And by extension, we should look at the status quo of today’s Haskell world with suspicion. And getting a good, prescriptive specification of what Haskell <em>is</em> would go a long way towards alleviating this issue.</p>
<p>So why do I bring all of this up? It’s my impression that the current Haskell2020 efforts are dead in all but name. The <a href="https://mail.haskell.org/pipermail/haskell-prime/">official mailing list</a> didn’t see any activity for 12 of the last 24 months. Of the months that did see activity, several of their volumes are measured in <em>bytes.</em> At time of writing, the official Haskell2020 website’s certificates are expired, and have been for two weeks.</p>
<p>None of this is meant to demonize the standards committee. But for whatever reason, it’s pretty clear that Haskell2020 is not going to happen in its current incarnation. After all, 2020 is coming up pretty dang soon!</p>
<p>Forgive the melodrama, but I truly believe that this situation is an existential risk for our beloved language and community. There are already well-founded <a href="https://www.reddit.com/r/haskell/comments/dpr276/what_is_the_status_of_ghc_linear_types/f5yjg67/">murmurings of dissatisfaction</a>, and <em>lots</em> of complaints about the lack of good tooling (though regrettably I can’t find any links right now.)</p>
<p>So what’s the real problem here? As a complete outsider — reading between the lines of discussions I’ve had with a few of the Haskell2020 committee members — my guess is this: <strong>a lack of leadership.</strong> It’s not that the committee members don’t care, it’s that nobody cares <em>sufficiently</em> to overcome the momentum and push the thing through to completion. Furthermore, these people are busy with their own cool projects, and committee work is always a thankless job.</p>
<p>The good news: a lack of leadership is a <em>very easy problem to solve.</em> If you care about this problem, <strong>just take the reigns.</strong> That’s all there is to it. <em>Anyone can do it.</em> Yes, even you, gentle reader! Nobody needs to elevate you to a position of power. There’s no admissions process. You don’t need to be given any <em>authority</em> in order to take the lead here. This is a thing that everybody wants, but there’s a coordination problem, and the only reason it hasn’t been done yet is that nobody has done it.</p>
<p>If you want more assurance about that: as a member of the GHC Steering Committee, <strong>I will personally ratify any reasonable draft standard of Haskell 202x</strong> and vote in favor that GHC adheres to that standard. I have confirmation from at least two other members of the committee that they will also do so.</p>
<p>As a rough estimate, the effort involved in Haskel202x is about half a person-year. Most of that will be spent doing unsexy, administrative things like setting deadlines, cajoling the right people for opinions, and writing a big, boring document. Not a lot of fun, to be sure, but <em>very doable.</em> The only challenge here is to not lose motivation for six months.</p>
<p>Should you still have doubts, I’d like to give another example: the GHC Steering Committee. Despite some (fair) criticisms, all things considered, the Steering Committee is a pretty successful organization. But <em>literally the only reason</em> for that success is Joachim’s unyielding desire for it to succeed. Without his monthly emails reminding everyone of the work to be done, and who is responsible for what, the Committee would collapse in three months. Nobody gave Joachim this responsibility, he just took it and owned it. In my opinion, the entire Haskell community is deeply indebted to Joachim on this front.</p>
<p>If all of this sounds inspiring to you, I urge you to take up the mantle and <em>make this thing happen.</em> It’s the first step towards a much better Haskell world, and it’s an amazingly actionable one. You can help change the world for the better, and we will all be indebted to you when you pull it off.</p>
      ]]></content:encoded>
  </item>
  <item>
      <title>New Book: Design and Interpretation of Haskell Programs</title>
      <author>sandy@sandymaguire.me (Sandy Maguire)</author>
      <link>http://reasonablypolymorphic.com/blog/design-and-interpretation/index.html</link>
      <guid>http://reasonablypolymorphic.com/blog/design-and-interpretation/index.html</guid>
      <pubDate>2019-10-13T14:14:00Z</pubDate>
      <content:encoded><![CDATA[
        <p><a href="https://www.patreon.com/designandinterpretation">I’m writing a new book</a>, on how to write good, real-world Haskell applications! The announcement copy is below.</p>
<hr />
<p>Hi there! My name is Sandy Maguire — you might know me from my work on Polysemy and Thinking with Types.</p>
<p>One of purely functional programming’s greatest strengths is its powerful abstraction capabilities. We proudly exclaim that our functions are referentially transparent, and because of that, our bugs will always be shallow. And this is often true.</p>
<p>10x is often cited as the magic number beyond which technology is good enough to overcome network effects. I’m personally convinced that writing Haskell is 10x better than any other popular programming language I’ve tried. But if functional programming is so good, why hasn’t it yet taken over the world?</p>
<p>This is a very serious question. If we’re right about this, why haven’t we won?</p>
<p>Design and Interpretation of Haskell Programs is my answer to this question. Haskell hasn’t taken market share because we collectively don’t yet know how to write real applications with it. Abstraction is our language’s greatest strength, but all of our “best practices” evangelize doing everything directly in IO. Is it really any wonder that nonbelievers aren’t convinced when we show them an imperative C program that just happens to be compiled with GHC?</p>
<p>Instead of giving up, this book encourages us to take a heavy focus on designing leak-free abstractions, on building programs that can be reasoned about algebraically, and on completely separating business logic from interpretation details.</p>
<p>But I can’t do it all by myself. Writing a book is a hard, gruelling process, that’s made much easier by knowing that people care about the end result. If you’re a conscientious engineer, unhappy with the status-quo of large, unmaintainable, “production-grade” Haskell, then this book is for you. By pledging, you let me know that this book is worth writing. In addition, your early feedback will help make this book the best it can possibly be.</p>
<p>Not sure if this is the book for you? Take a look at the sample before committing to anything!</p>
<p>With your help, together we can tame software complexity and write codebases we’re proud of.</p>
<p>One love, Sandy</p>
      ]]></content:encoded>
  </item>
</channel>
</rss>
