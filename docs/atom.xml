<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns='http://www.w3.org/2005/Atom' xmlns:g='http://base.google.com/ns/1.0'>
  <title>Reasonably Polymorphic</title>
  <updated>2019-10-13T14:14:00Z</updated>
  <author><name>Sandy Maguire</name></author>
  <id>http://reasonablypolymorphic.com</id>
  <link rel='self' href='atom.xml'/>

    <entry>
      <title>New Book: Design and Interpretation of Haskell Programs</title>
      <id>blog/design-and-interpretation/index.html</id>
      <link href='blog/design-and-interpretation/index.html'/>
      <published>2019-10-13T14:14:00Z</published>
      <updated>2019-10-13T14:14:00Z</updated>

      <content type="html">
        <![CDATA[
        <p><a href="https://www.patreon.com/designandinterpretation">I’m writing a new book</a>, on how to write good, real-world Haskell applications! The announcement copy is below.</p>
<hr />
<p>Hi there! My name is Sandy Maguire — you might know me from my work on Polysemy and Thinking with Types.</p>
<p>One of purely functional programming’s greatest strengths is its powerful abstraction capabilities. We proudly exclaim that our functions are referentially transparent, and because of that, our bugs will always be shallow. And this is often true.</p>
<p>10x is often cited as the magic number beyond which technology is good enough to overcome network effects. I’m personally convinced that writing Haskell is 10x better than any other popular programming language I’ve tried. But if functional programming is so good, why hasn’t it yet taken over the world?</p>
<p>This is a very serious question. If we’re right about this, why haven’t we won?</p>
<p>Design and Interpretation of Haskell Programs is my answer to this question. Haskell hasn’t taken market share because we collectively don’t yet know how to write real applications with it. Abstraction is our language’s greatest strength, but all of our “best practices” evangelize doing everything directly in IO. Is it really any wonder that nonbelievers aren’t convinced when we show them an imperative C program that just happens to be compiled with GHC?</p>
<p>Instead of giving up, this book encourages us to take a heavy focus on designing leak-free abstractions, on building programs that can be reasoned about algebraically, and on completely separating business logic from interpretation details.</p>
<p>But I can’t do it all by myself. Writing a book is a hard, gruelling process, that’s made much easier by knowing that people care about the end result. If you’re a conscientious engineer, unhappy with the status-quo of large, unmaintainable, “production-grade” Haskell, then this book is for you. By pledging, you let me know that this book is worth writing. In addition, your early feedback will help make this book the best it can possibly be.</p>
<p>Not sure if this is the book for you? Take a look at the sample before committing to anything!</p>
<p>With your help, together we can tame software complexity and write codebases we’re proud of.</p>
<p>One love, Sandy</p>
        ]]>
      </content>
    </entry>
    <entry>
      <title>Nimic: A language about nothing</title>
      <id>blog/nimic/index.html</id>
      <link href='blog/nimic/index.html'/>
      <published>2019-07-15T13:44:00Z</published>
      <updated>2019-07-15T13:44:00Z</updated>

      <content type="html">
        <![CDATA[
        <p>If you haven’t heard, <a href="https://isovector.github.io/erdos/">I recently solicited couches to stay on</a>. The idea is to cruise around the globe, meeting cool programmers, and collaborating with them on whatever project they’re most excited about.</p>
<p>This weekend I spent time with the inimitable <a href="https://github.com/davidrusu">David Rusu</a>. The bar for my trip has been set extremely high; not only is David an amazing host, but we hashed out a particularly interesting project in a couple of days. We call it <a href="https://github.com/isovector/nimic">nimic</a>.</p>
<p>Nimic is a free-form macro language, without any real syntax, or operational semantics. We have a super bare bones parser that groups parenthetical expressions, and otherwise admits any tokens, separated by whitespace. The language will attempt to run each of its macros on the deepest, leftmost part of this grouping structure. If nothing matches, the program is stuck and we just leave it.</p>
<p>Therefore, hello world in nimic is just the stuck program:</p>
<pre><code>hello world</code></pre>
<p>which you have to admit is about as small as you can get it. The core language installs four built-in macros; the most interesting of which is <code>macro</code> — allowing you to define new macros. The syntax is <code>macro pattern rewrite</code>, which itself will be rewritten as the stuck term <code>defined</code>.</p>
<p>As a first program, we can use <code>macro</code> to rewrite the <code>defined</code> term:</p>
<pre><code>macro defined (nimic is weird)</code></pre>
<p>which will step to <code>defined</code> via the definition of <code>macro</code>, and then step to <code>nimic is weird</code> via the new <code>defined</code> rule. Here it gets stuck and does no more work.</p>
<p>You can use the special tokens <code>#foo</code> to perform pattern matching in a macro. These forms are available in the rewrite rule. For example,</p>
<pre><code>macro (nimic is #adjective) (nimic is very #adjective)</code></pre>
<p>will replace our <code>nimic is weird</code> term with <code>nimic is very weird</code>. You can bind as many subterms in a macro as you’d like.</p>
<p>Because nimic attempts to run all of its macros on the deepest, leftmost part of the tree it can, we can exploit this fact to create statements. Consider the program:</p>
<pre><code>(macro (#a ; #b) #b)
; ( (macro (what is happening?) magic)
  ; (what is happening?)
  )</code></pre>
<p>Here we’ve built a cons list of the form <code>(head ; tail)</code>. Our default evaluation order will dive into the leftmost leaf of this tree, and evaluate the <code>(macro (#a ; #b) #b)</code> term there, replacing it with <code>defined</code>. Our tree now looks like this:</p>
<pre><code>(defined
; ( (macro (what is happening?) magic)
  ; (what is happening?)
  )</code></pre>
<p>where our new <code>#a : #b</code> rule now matches, binding <code>#a</code> to <code>defined</code>, and <code>#b</code> to the tail of this cons cell. This rule will drop the <code>defined</code>, and give us the new tree:</p>
<pre><code>( (macro (what is happening?) magic)
; (what is happening?)
)</code></pre>
<p>whereby we now can match on the leftmost macro again. After a few more steps, our program gets stuck with the term <code>magic</code>. We’ve defined sequential evaluation!</p>
<p>But writing cons cells by hand is tedious. This brings us to the second of our built-in macros, which is <code>rassoc #prec #symbol</code>. The evaluation of this will also result in <code>defined</code>, but modifies the parser so that it will make <code>#symbol</code> be right-associative with precedence <code>#prec</code>. As a result, we can use <code>rassoc 1 ;</code> to modify the parser in order to turn <code>a ; b ; c</code> into <code>a ; (b ; (c))</code>.</p>
<p>Therefore, the following program will correctly get stuck on the term <code>finished</code>:</p>
<pre><code>(macro (#a ; #b) #b)
; ((rassoc 1 ;)
;
( this is now
; parsed correctly as a cons cell
; finished
)))</code></pre>
<p>The final primitive macro defined in <code>nimic</code> is <code>bash #cmd</code>, which evaluates <code>#cmd</code> in bash, and replaces itself with the resulting output. To illustrate, the following program is another way of writing hello world:</p>
<pre><code>bash (echo &quot;hellozworld&quot; | tr &quot;z&quot; &quot; &quot;)</code></pre>
<p>Note that the <code>bash</code> command isn’t doing any sort of bash parsing here. It just takes the symbols <code>echo</code> <code>"hellozworld"</code> <code>|</code> <code>tr</code> <code>"z"</code> <code>"</code> and <code>"</code>, and dumps them out pretty printed into bash. There are no string literals.</p>
<p>We can use the <code>bash</code> command to do more interesting things. For example, we can use it to define an <code>import</code> statement:</p>
<pre><code>macro (import #file) (bash (cat #file))</code></pre>
<p>which when you evaluate <code>import some/file.nim</code>, will be replaced with <code>(bash (cat some/file.nim))</code>, which in turn with the contents of <code>some/file.nim</code>. You have to admit, there’s something appealing about <em>even the module system</em> being defined in library code.</p>
<p>But we can go further. We can push our math runtime into bash!</p>
<pre><code>macro (math #m) (bash (bc &lt;&lt;&lt; &quot; #m &quot;))</code></pre>
<p>which will correctly evaluate any math expressions you shoot its way.</p>
<p>Personally, I’m not a big fan of the <code>macro #a #b</code> notation. So instead I defined my own sequent notation:</p>
<pre><code>  rassoc 2 ----------
; macro (#a ---------- #b) (macro #a #b)</code></pre>
<p>This thing defines a macro, which, when expanded, will itself define a macro. Now David and I don’t need to have any discussions bikeshedding over syntax. We can just define whatever we want!</p>
<p>For a longer example, I wanted to implement pattern matching a la Haskell.</p>
<p>My first step was to define a lazy <code>if</code> statement. Because macros are tried most-recently-defined first, I can define my operational semantics first. The rule is to force the condition:</p>
<pre><code>; if #cond then #a else #b
  ----------
  if !#cond then #a else #b</code></pre>
<p>(the exclamation marks here are magic inside of the <code>macro</code> macro, which will force macro expansion at whatever it’s attached to) Next, I give two more expansion rules for what to do if my condition is true and false:</p>
<pre><code>; if True then #a else #b
  ----------
  #a

; if False then #a else #b
  ----------
  #b</code></pre>
<p>Great! We can define syntactic equality of stuck terms by forcing two subterms, and then checking them in bash for string equality:</p>
<pre><code>; judge #a #b
  ----------
  is zero !(bash ([[ &quot; !#a &quot; == &quot; !#b &quot; ]]; echo $?))

; is zero #n
  ----------
  False

; is zero 0
  ----------
  True</code></pre>
<p>We can try this out. <code>judge hello hello</code> and <code>judge (macro (a a a) b) defined</code> both step to <code>True</code>, but <code>judge foo bar</code> steps to <code>False</code>.</p>
<p>Finally, we’re ready to define pattern matching. We start with the base case in which there is only one pattern we can match on:</p>
<pre><code>; match #a of (#m1 -&gt; #r1)
  ----------
  if !(judge #a #m1) then #r1 else (failed match)</code></pre>
<p>We replace our match statement with an equality test, and produce <code>failed match</code> if the two things aren’t identical.</p>
<p>There’s also an induction case, where we want to match on several possibilities.</p>
<pre><code>; match #a of (#m1 -&gt; #r1 ; #z)
  ----------
  if !(judge #a #m1) then #r1 else (match !#a of #z)</code></pre>
<p>Here we’d like to perform the same rewrite, but the else case should pop off the failed match.</p>
<p>Amazingly, this all <em>just works</em>. Let’s try it:</p>
<pre><code>; rassoc 3 =

; #a = #b
  ----------
  #a
  ----------
  #b

; not #t =
    match #t of
      ( True -&gt; False
      ; False -&gt; True
      )

; match (not True) of
    ( True -&gt; hello
    ; False -&gt; it works!
    )</code></pre>
<p>This program will get stuck at <code>it works!</code>. Pretty sweet!</p>
<hr />
<p>The core nimic implementation is 420 lines of Haskell code, including a hand-rolled parser and macro engine. But wait, there’s more! There’s also an additional 291 line interactive debugger, which allows you to step through the macro expansion of your program. It’s even smart enough to colorize the variables in your source tree that are being matched by the current macro.</p>
<figure>
<img src="/images/nimic.png" alt="The Glorious Nimic Stepper" /><figcaption>The Glorious Nimic Stepper</figcaption>
</figure>
<p>Not bad for a weekend of work. I can barely contain my excitement for what other cool projects are on the horizon.</p>
        ]]>
      </content>
    </entry>
    <entry>
      <title>How I Intend to Help Steer GHC</title>
      <id>blog/steering/index.html</id>
      <link href='blog/steering/index.html'/>
      <published>2019-07-11T17:40:00Z</published>
      <updated>2019-07-11T17:40:00Z</updated>

      <content type="html">
        <![CDATA[
        <p>Yesterday I was (somewhat surprisingly) brought on as a new member of the GHC steering committee. I believe transparency is very important in situations like these, and so I’d like to outline my intentions for my tenure in the committee.</p>
<p>I nominated myself because of problems I perceived in the status-quo. Lately, there have been a few notable cases of dissatisfaction in the community with the proposal process. I have certainly had my qualms with it in the past, but I decided that rather than complain about it, I should just get involved and try my best to help.</p>
<p>Which takes us to today.</p>
<p>I’m extremely humbled to be included with such a group of incredible individuals as my co-committee members are. I don’t claim to know everything about writing industrial-grade compilers, nor about the intricacies of cutting-edge type system research. Most of the time I’m only barely smart enough to keep up with the conversation, let alone have a strongly informed opinion on the topic. WIth that in mind…</p>
<hr />
<p><strong>I don’t intend to be a gatekeeper.</strong> Instead, I intend to be a facilitator; someone whose job it is is to know the right people to bring into the discussion. Nobody in this community is an expert at everything, but everyone has a niche in which they are an expert. I want to make sure that those people are involved in the process in which their expertise can be used.</p>
<p>That’s not to say I’m not going to do everything in my power to understand each and every proposal under my stewardship. Just that I’ll be the first to admit that I don’t know everything, and I don’t want <em>my</em> understanding to get in the way of good ideas!</p>
<hr />
<p><strong>I intend to inspire the committee to <em>move faster.</em></strong> I think any process which can take upwards of two years is too slow — it’s a waste of everyone’s time, energy and attention. My preference is fast responses to proposals, whether it be yea or nay. I don’t want to railroad any decisions, but I also don’t want to sit on the fence out of fear of making the wrong move.</p>
<p>Along those lines, I intend to enthusiastically support any quality-of-life improvements to the language that are small in scope, compose well, and don’t get in the way of <em>active</em>, longer-term goals. Delaying a decision on the basis of “there’s probably a more general solution here that nobody has time to think about, nor do they plan to actually propose” seems like a bad strategy for me. I don’t want to let perfect be the enemy of the <em>much better.</em></p>
<hr />
<p><strong>I intend to preemptively shut down discussions around bikeshedding.</strong> Too often bikeshedding completely derails the conversation. It’s an enormous waste of time. Feelings get hurt, and everyone just talks past one another anyway. I intend to give the proposal author and the Simons the only say on bikeshedding matters. They can canvas for opinions if they’d like, but in my opinion, should do so outside the official proposal channels.</p>
<p>To be clear, I am <em>not</em> saying you shouldn’t offer suggestions if they improve a proposals’ composability, type-safety, elegance or parsimony. But let’s agree as a community that opinions of style are just opinions, and are never going to convince anyone anyway.</p>
<hr />
<p><strong>I intend to remove as many barriers to entry as humanly possible.</strong> The Haskell community is by far the smartest, kindest, most incredible group of people I’ve ever had the good fortune to be a part of. I firmly believe that each and every one of us has great things to contribute to this community, and I suspect the world would be a better place if more of us felt like we had some ownership over the language.</p>
<p>Please take a moment to remember that Haskell is only as great as we make it. There is no “community,” nor is there a “GHCHQ.” There are just people who step up to solve the problems that they see. I encourage you to be one of those people. You don’t need permission. You just need to be kind, genuine and hard-working. Remember that nobody involved in our community is stupid, and if they “just don’t get it,” maybe your argument wasn’t as persuasive as you thought.</p>
<p>All of this goes beyond making proposals to the compiler. Be the community you want to see. Don’t assume somebody else is going to do it for you.</p>
<hr />
<p>Last but not least, <strong>I intend to be a good addition to this committee.</strong> <a href="https://whatiswrongwith.me/isovector">I solicit anonymous feedback</a>, so please don’t hesitate to call me out if you’re ever unhappy with my behavior. I promise to not be offended by any constructive feedback you send my way.</p>
<p>I will do my best to stay honest to these intentions, but help keep me in tow when I slip up.</p>
<hr />
<p>The GHC steering committee is a thankless job. I’d like to take a moment to explicitly call out every member of the committee, past and present, for their selfless commitments to the community. These are people who are taking time out of their own research and projects in order to make our fantastic language much more transparent than it would be otherwise. Really and truly, these people are heroes, even if we don’t always agree with their decisions. <em>Thank you,</em> from the very bottom of my heart.</p>
<p>Finally, <strong>I intend to live up to everyone’s expectations.</strong> Thanks for your time.</p>
        ]]>
      </content>
    </entry>
    <entry>
      <title>Polysemy Internals: The Effect-Interpreter Effect</title>
      <id>blog/tactics/index.html</id>
      <link href='blog/tactics/index.html'/>
      <published>2019-06-26T17:26:00Z</published>
      <updated>2019-06-26T17:26:00Z</updated>

      <content type="html">
        <![CDATA[
        <blockquote>
<p>aka “what the hell is that <code>Tactics</code> stuff?”</p>
</blockquote>
<p>This is the second post in a series of implementation details in <a href="https://github.com/polysemy-research/polysemy">polysemy</a> — a fast, powerful and low-boilerplate effect-system library.</p>
<hr />
<p>In the <a href="/blog/freer-higher-order-effects/">last post</a> we discussed the <code>Yo</code> type, which accumulates weaving functions of the form <code>Functor f =&gt; f () -&gt; (∀ x. f (m x) -&gt; n (f x)) -&gt; e m a -&gt; e n (f a)</code>. As a quick reminder, the <code>f</code> functor corresponds to some piece of (possibly trivial) state, and the <code>∀ x. f (m x) -&gt; n (f x)</code> is a distribution function, roughly analogous to a function like <code>runStateT</code>.</p>
<p>Where our story left off, we had accumulated all of our desired <code>weave</code>s into <code>Yo</code>, but hadn’t yet used them for anything. The developer experience around <code>Yo</code> is fraught with peril, and even as the guy who implemented it, I’m often stymied about how to get all the types to line up. Such a detail is not the sort of thing you can expose in a library that you expect people to actually use.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">data</span> <span class="dt">Yo</span> e m a <span class="kw">where</span></a>
<a class="sourceLine" id="cb1-2" title="2">  <span class="dt">Yo</span><span class="ot"> ::</span> <span class="dt">Functor</span> f</a>
<a class="sourceLine" id="cb1-3" title="3">     <span class="ot">=&gt;</span> e m a</a>
<a class="sourceLine" id="cb1-4" title="4">     <span class="ot">-&gt;</span> f ()</a>
<a class="sourceLine" id="cb1-5" title="5">     <span class="ot">-&gt;</span> (<span class="ot">∀</span> x<span class="fu">.</span> f (m x) <span class="ot">-&gt;</span> n (f x))</a>
<a class="sourceLine" id="cb1-6" title="6">     <span class="ot">-&gt;</span> (f a <span class="ot">-&gt;</span> b)</a>
<a class="sourceLine" id="cb1-7" title="7">     <span class="ot">-&gt;</span> <span class="dt">Yo</span> e n b</a></code></pre></div>
<p>At the types <code>Yo</code> usually gets instantiated, it looks something like <code>Yo (State s) (Sem r) Int</code>. Which looks easy enough, until you realize that packed inside of this thing is an existential <code>m</code> (which was originally a <code>Sem r0</code> for some unknown effect row <code>r0</code>), and an existential functor <code>f</code> which is all of the initial state we’re carrying around from other effects who have already run.</p>
<p><code>Yo</code> is the free <code>Effect</code>, which means that like all free structures, it provides dependency injection so you can later decide what that <code>Effect</code> means. It’s not a magic bullet — you still need to actually write code somewhere. <em>Somebody</em> needs to actually use that <code>f ()</code> and <code>∀ x. f (m x) -&gt; n (f x)</code> to actually do something!</p>
<p>As a first attempt, let’s see what happens if we just expose them in the interpretation API. We’ll write a quick <code>interpret</code> function which can handle an effect <code>e m x</code> by producing a <code>Sem r (f x)</code>. The implementation is given below. Don’t worry too much about its body; but pay attention to just how gruesome the type is.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1">interpret</a>
<a class="sourceLine" id="cb2-2" title="2"><span class="ot">    ::</span> (<span class="ot">∀</span> x m f</a>
<a class="sourceLine" id="cb2-3" title="3">           <span class="fu">.</span> <span class="dt">Functor</span> f</a>
<a class="sourceLine" id="cb2-4" title="4">          <span class="ot">=&gt;</span> f ()                                  <span class="co">-- initial state</span></a>
<a class="sourceLine" id="cb2-5" title="5">          <span class="ot">-&gt;</span> (<span class="ot">∀</span> y<span class="fu">.</span> f (m y) <span class="ot">-&gt;</span> <span class="dt">Sem</span> (e &#39;<span class="fu">:</span> r) (f y))  <span class="co">-- distrib function</span></a>
<a class="sourceLine" id="cb2-6" title="6">          <span class="ot">-&gt;</span> e m x                                 <span class="co">-- effect constructor</span></a>
<a class="sourceLine" id="cb2-7" title="7">          <span class="ot">-&gt;</span> <span class="dt">Sem</span> r (f x)</a>
<a class="sourceLine" id="cb2-8" title="8">       )</a>
<a class="sourceLine" id="cb2-9" title="9">    <span class="ot">-&gt;</span> <span class="dt">Sem</span> (e &#39;<span class="fu">:</span> r) a</a>
<a class="sourceLine" id="cb2-10" title="10">    <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</a>
<a class="sourceLine" id="cb2-11" title="11">interpret f (<span class="dt">Sem</span> m) <span class="fu">=</span> m <span class="fu">$</span> \u <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb2-12" title="12">  <span class="kw">case</span> decomp u <span class="kw">of</span></a>
<a class="sourceLine" id="cb2-13" title="13">    <span class="dt">Right</span> (<span class="dt">Yo</span> eff state distrib y) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb2-14" title="14">      <span class="fu">fmap</span> y <span class="fu">$</span> f state distrib eff</a>
<a class="sourceLine" id="cb2-15" title="15">    <span class="dt">Left</span>  another_effect <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb2-16" title="16">      liftSem <span class="fu">$</span> hoist (interpret f) another_effect</a></code></pre></div>
<p>For example, we can use it to implement an interpretation of the <code>Reader</code> effect:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">data</span> <span class="dt">Reader</span> i m a <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" title="2">  <span class="dt">Ask</span><span class="ot"> ::</span> <span class="dt">Reader</span> i m i</a>
<a class="sourceLine" id="cb3-3" title="3">  <span class="dt">Local</span><span class="ot"> ::</span> (i <span class="ot">-&gt;</span> i) <span class="ot">-&gt;</span> m a <span class="ot">-&gt;</span> <span class="dt">Reader</span> i m a</a>
<a class="sourceLine" id="cb3-4" title="4"></a>
<a class="sourceLine" id="cb3-5" title="5"></a>
<a class="sourceLine" id="cb3-6" title="6"><span class="ot">runReader ::</span> i <span class="ot">-&gt;</span> <span class="dt">Sem</span> (<span class="dt">Reader</span> i &#39;<span class="fu">:</span> r) a <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</a>
<a class="sourceLine" id="cb3-7" title="7">runReader i <span class="fu">=</span> interpret <span class="fu">$</span> \state distrib <span class="ot">-&gt;</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb3-8" title="8">  <span class="dt">Ask</span>        <span class="ot">-&gt;</span> <span class="fu">pure</span> <span class="fu">$</span> i <span class="fu">&lt;$</span> state</a>
<a class="sourceLine" id="cb3-9" title="9">  <span class="dt">Local</span> f ma <span class="ot">-&gt;</span> runReader (f i) <span class="fu">$</span> distrib <span class="fu">$</span> ma <span class="fu">&lt;$</span> state</a></code></pre></div>
<p>Because <code>Ask</code> doesn’t have any embedded computations, it doesn’t need to do anything fancy. It can just ice-cream cone to put <code>i</code> inside of the state it was given, and return that. But <code>Local</code> is a more complicated beast! It must ice-cream cone its <code>ma</code> computation into the state, and then <code>distrib</code> that thing into a <code>Sem (Reader i '; r)</code>, and then run the <code>Reader</code> effect off of that!</p>
<p>It’s not the end of the world, but it’s a nontrivial amount of boilerplate <em>that needs to be duplicated for every interpreter.</em> Combined with the terrifying types, this feels like a no-go.</p>
<p>Let’s look at an interpretation for the <code>Resource</code> effect (which gives <code>bracket</code> semantics.) <code>Resource</code> is more complicated than <code>Reader</code>, and this complexity serves to illustrate some common patterns that come up and up again when writing interpreters.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">data</span> <span class="dt">Resource</span> m a <span class="kw">where</span></a>
<a class="sourceLine" id="cb4-2" title="2">  <span class="dt">Bracket</span></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="ot">      ::</span> m a         <span class="co">-- allocate</span></a>
<a class="sourceLine" id="cb4-4" title="4">      <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b)  <span class="co">-- finalize</span></a>
<a class="sourceLine" id="cb4-5" title="5">      <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m c)  <span class="co">-- use</span></a>
<a class="sourceLine" id="cb4-6" title="6">      <span class="ot">-&gt;</span> <span class="dt">Resource</span> m c</a>
<a class="sourceLine" id="cb4-7" title="7"></a>
<a class="sourceLine" id="cb4-8" title="8"></a>
<a class="sourceLine" id="cb4-9" title="9">runResource</a>
<a class="sourceLine" id="cb4-10" title="10"><span class="ot">    ::</span> <span class="ot">∀</span> r a</a>
<a class="sourceLine" id="cb4-11" title="11">     <span class="fu">.</span> <span class="dt">Member</span> (<span class="dt">Lift</span> <span class="dt">IO</span>) r</a>
<a class="sourceLine" id="cb4-12" title="12">    <span class="ot">=&gt;</span> (<span class="ot">∀</span> x<span class="fu">.</span> <span class="dt">Sem</span> r x <span class="ot">-&gt;</span> <span class="dt">IO</span> x)  <span class="co">-- irrelevant to the discussion</span></a>
<a class="sourceLine" id="cb4-13" title="13">    <span class="ot">-&gt;</span> <span class="dt">Sem</span> (<span class="dt">Resource</span> &#39;<span class="fu">:</span> r) a</a>
<a class="sourceLine" id="cb4-14" title="14">    <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</a>
<a class="sourceLine" id="cb4-15" title="15">runResource lower <span class="fu">=</span> interpret <span class="fu">$</span> \state distrib <span class="ot">-&gt;</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb4-16" title="16">  <span class="dt">Bracket</span> alloc finalize use <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb4-17" title="17">    <span class="kw">let</span><span class="ot"> toIO ::</span> <span class="dt">Sem</span> (<span class="dt">Resource</span> &#39;<span class="fu">:</span> r) x <span class="ot">-&gt;</span> <span class="dt">IO</span> x</a>
<a class="sourceLine" id="cb4-18" title="18">        toIO <span class="fu">=</span> lower <span class="fu">.</span> runResource lower</a>
<a class="sourceLine" id="cb4-19" title="19"></a>
<a class="sourceLine" id="cb4-20" title="20">    sendM <span class="fu">$</span> X.bracket</a>
<a class="sourceLine" id="cb4-21" title="21">      (toIO <span class="fu">$</span> distrib <span class="fu">$</span> alloc <span class="fu">&lt;$</span> state)         <span class="co">-- 1</span></a>
<a class="sourceLine" id="cb4-22" title="22">      (\a <span class="ot">-&gt;</span> toIO <span class="fu">$</span> distrib <span class="fu">$</span> <span class="fu">fmap</span> finalize a)</a>
<a class="sourceLine" id="cb4-23" title="23">      (\a <span class="ot">-&gt;</span> toIO <span class="fu">$</span> distrib <span class="fu">$</span> <span class="fu">fmap</span> use a)</a></code></pre></div>
<p>The <code>bracket</code> function allocates some resource of type <code>a</code>, provides it to the <code>use</code> block for some computation, and ensures that it will be cleaned up via <code>finalize</code> — even if the <code>use</code> block crashed.</p>
<p>There are a few subtleties in the type instantiation here. In the comment marked <code>-- 1</code>, we run <code>distrib</code> on our <code>m a</code> parameter, which transforms it into an <code>Sem (Resource ': r) (f a)</code>. Note that we’ve introduced an <code>f</code> here! This in turn unifies our <code>finalize</code> and <code>use</code> types as <code>f a -&gt; m b</code> and <code>f a -&gt; m c</code>, respectively. Because we later need to distribute to turn those <code>m</code>s into <code>Sem (Resource ': r)</code>s, we also introduce <code>f</code>s into <code>b</code> and <code>c</code>.</p>
<p>In essence, we end up with functions <code>alloc :: Sem (Resource ': r) (f a)</code>, <code>finalize :: f a -&gt; Sem (Resource ': r) (f b)</code> and <code>use :: f a -&gt; Sem (Resource ': r) (f c)</code>. This threading of <code>f</code> evident in the types corresponds directly to the fact that we need to keep track of other people’s state. As we’ll see in a future post, is indicative of a huge problem with the naive semantics we’ve given to <code>Resource</code> here.</p>
<p>Anyway, looking at <code>runReader</code> and <code>runResource</code>, we see two particular patterns emerge in our interpreters:</p>
<ol type="1">
<li><code>distrib $ ma &lt;$ state</code> for the case of an <code>m a</code> argument</li>
<li><code>\fa -&gt; distrib $ fmap mb fa</code> for the case of an <code>a -&gt; m b</code> argument</li>
</ol>
<p>The insight here is that maybe we can just make these combinators a part of the <code>interpret</code> interface directly, rather than have people write them by hand for each interpreter. It doesn’t help the horrifying types:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1">interpret</a>
<a class="sourceLine" id="cb5-2" title="2"><span class="ot">    ::</span> (<span class="ot">∀</span> x m f</a>
<a class="sourceLine" id="cb5-3" title="3">           <span class="fu">.</span> <span class="dt">Functor</span> f</a>
<a class="sourceLine" id="cb5-4" title="4">          <span class="ot">=&gt;</span> (<span class="ot">∀</span> y<span class="fu">.</span> m y <span class="ot">-&gt;</span> <span class="dt">Sem</span> (e &#39;<span class="fu">:</span> r) (f y))</a>
<a class="sourceLine" id="cb5-5" title="5">          <span class="ot">-&gt;</span> (<span class="ot">∀</span> y z<span class="fu">.</span> (y <span class="ot">-&gt;</span> m z) <span class="ot">-&gt;</span> f y <span class="ot">-&gt;</span> <span class="dt">Sem</span> (e &#39;<span class="fu">:</span> r) (f z))</a>
<a class="sourceLine" id="cb5-6" title="6">          <span class="ot">-&gt;</span> e m x</a>
<a class="sourceLine" id="cb5-7" title="7">          <span class="ot">-&gt;</span> <span class="dt">Sem</span> r (f x)</a>
<a class="sourceLine" id="cb5-8" title="8">       )</a>
<a class="sourceLine" id="cb5-9" title="9">    <span class="ot">-&gt;</span> <span class="dt">Sem</span> (e &#39;<span class="fu">:</span> r) a</a>
<a class="sourceLine" id="cb5-10" title="10">    <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</a>
<a class="sourceLine" id="cb5-11" title="11">interpret f (<span class="dt">Sem</span> m) <span class="fu">=</span> m <span class="fu">$</span> \u <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb5-12" title="12">  <span class="kw">case</span> decomp u <span class="kw">of</span></a>
<a class="sourceLine" id="cb5-13" title="13">    <span class="dt">Right</span> (<span class="dt">Yo</span> eff state distrib y) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb5-14" title="14">      <span class="fu">fmap</span> y <span class="fu">$</span> f (distrib <span class="fu">.</span> (<span class="fu">&lt;$</span> state))</a>
<a class="sourceLine" id="cb5-15" title="15">                 (\mf <span class="ot">-&gt;</span> distrib <span class="fu">.</span> <span class="fu">fmap</span> mf)</a>
<a class="sourceLine" id="cb5-16" title="16">                 eff</a>
<a class="sourceLine" id="cb5-17" title="17">    <span class="dt">Left</span>  another_effect <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb5-18" title="18">      liftSem <span class="fu">$</span> hoist (interpret f) another_effect</a></code></pre></div>
<p>But it sure as heck improves the ergonomics:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1">runResource</a>
<a class="sourceLine" id="cb6-2" title="2"><span class="ot">    ::</span> <span class="ot">∀</span> r a</a>
<a class="sourceLine" id="cb6-3" title="3">     <span class="fu">.</span> <span class="dt">Member</span> (<span class="dt">Lift</span> <span class="dt">IO</span>) r</a>
<a class="sourceLine" id="cb6-4" title="4">    <span class="ot">=&gt;</span> (<span class="ot">∀</span> x<span class="fu">.</span> <span class="dt">Sem</span> r x <span class="ot">-&gt;</span> <span class="dt">IO</span> x)</a>
<a class="sourceLine" id="cb6-5" title="5">    <span class="ot">-&gt;</span> <span class="dt">Sem</span> (<span class="dt">Resource</span> &#39;<span class="fu">:</span> r) a</a>
<a class="sourceLine" id="cb6-6" title="6">    <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</a>
<a class="sourceLine" id="cb6-7" title="7">runResource lower <span class="fu">=</span> interpret <span class="fu">$</span> \start continue <span class="ot">-&gt;</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb6-8" title="8">  <span class="dt">Bracket</span> alloc finalize use <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb6-9" title="9">    <span class="kw">let</span><span class="ot"> toIO ::</span> <span class="dt">Sem</span> (<span class="dt">Resource</span> &#39;<span class="fu">:</span> r) x <span class="ot">-&gt;</span> <span class="dt">IO</span> x</a>
<a class="sourceLine" id="cb6-10" title="10">        toIO <span class="fu">=</span> lower <span class="fu">.</span> runResource lower</a>
<a class="sourceLine" id="cb6-11" title="11"></a>
<a class="sourceLine" id="cb6-12" title="12">    sendM <span class="fu">$</span> X.bracket</a>
<a class="sourceLine" id="cb6-13" title="13">      (toIO <span class="fu">$</span> start alloc)</a>
<a class="sourceLine" id="cb6-14" title="14">      (toIO <span class="fu">.</span> continue finalize)</a>
<a class="sourceLine" id="cb6-15" title="15">      (toIO <span class="fu">.</span> continue use)</a></code></pre></div>
<p>Much nicer! If only we could do something about those gnarly types, we’d be in business!</p>
<p>The last conceptual step here is to realize that the <code>start :: ∀ y. m y -&gt; Sem (e ': r) (f y)</code> and <code>continue :: ∀ y z. (y -&gt; m z) -&gt; f y -&gt; Sem (e ': r) (f z)</code> parameters are static. That means we could stick them into a reader monad — or perhaps more mind-crushingly, an <em>effect.</em></p>
<p>And so, we can provide the two following primitive actions in our <code>Tactics</code> effect, and then derive <code>start</code> and <code>continue</code> from them:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">data</span> <span class="dt">Tactics</span> f n r m a <span class="kw">where</span></a>
<a class="sourceLine" id="cb7-2" title="2">  <span class="dt">GetInitialState</span><span class="ot">     ::</span> <span class="dt">Tactics</span> f n r m (f ())</a>
<a class="sourceLine" id="cb7-3" title="3">  <span class="dt">HoistInterpretation</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> n b) <span class="ot">-&gt;</span> <span class="dt">Tactics</span> f n r m (f a <span class="ot">-&gt;</span> <span class="dt">Sem</span> r (f b))</a>
<a class="sourceLine" id="cb7-4" title="4"></a>
<a class="sourceLine" id="cb7-5" title="5"><span class="kw">type</span> <span class="dt">WithTactics</span> e f m r <span class="fu">=</span> <span class="dt">Tactics</span> f m (e &#39;<span class="fu">:</span> r) &#39;<span class="fu">:</span> r</a></code></pre></div>
<p>This thing is a mess of type parameters, but <code>f</code> is exactly what you’d expect. The <code>n</code> corresponds to what <code>m</code> used to be (it’s standard operating procedure in polysemy to use <code>m</code> as the name of the second-last type argument.) And we introduce <code>r</code> which corresponds to the effect row that we’re trying to interpret.</p>
<p>Interpreters for effect actions <code>e m</code> end up running with the <code>∀ f. Functor f =&gt; WithTactics e f m r</code> effect row. This thing gives us access to a <code>Tactics</code> capable of producing <code>Sem (e ': r)</code>s, but doesn’t <em>itself</em> have access to <code>e</code> effects.</p>
<p>Finally, we use a type synonym to hide most of the nasty details.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">type</span> <span class="dt">Tactical</span> e m r x <span class="fu">=</span></a>
<a class="sourceLine" id="cb8-2" title="2">  <span class="ot">∀</span> f<span class="fu">.</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Sem</span> (<span class="dt">WithTactics</span> e f m r) (f x)</a></code></pre></div>
<p>Given an appropriate <code>runTactics</code> interpreter:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1">runTactics</a>
<a class="sourceLine" id="cb9-2" title="2"><span class="ot">   ::</span> <span class="dt">Functor</span> f</a>
<a class="sourceLine" id="cb9-3" title="3">   <span class="ot">=&gt;</span> f ()</a>
<a class="sourceLine" id="cb9-4" title="4">   <span class="ot">-&gt;</span> (<span class="ot">∀</span> x<span class="fu">.</span> f (m x) <span class="ot">-&gt;</span> <span class="dt">Sem</span> r2 (f x))</a>
<a class="sourceLine" id="cb9-5" title="5">   <span class="ot">-&gt;</span> <span class="dt">Sem</span> (<span class="dt">Tactics</span> f m r2 &#39;<span class="fu">:</span> r) a</a>
<a class="sourceLine" id="cb9-6" title="6">   <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</a>
<a class="sourceLine" id="cb9-7" title="7">runTactics state distrib (<span class="dt">Sem</span> m) <span class="fu">=</span> m <span class="fu">$</span> \u <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-8" title="8">  <span class="kw">case</span> decomp u <span class="kw">of</span></a>
<a class="sourceLine" id="cb9-9" title="9">    <span class="dt">Left</span> x <span class="ot">-&gt;</span> liftSem <span class="fu">$</span> hoist (runTactics state distrib) x</a>
<a class="sourceLine" id="cb9-10" title="10">    <span class="dt">Right</span> (<span class="dt">Yo</span> <span class="dt">GetInitialState</span> state&#39; _ y _) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-11" title="11">      <span class="fu">pure</span> <span class="fu">$</span> y <span class="fu">$</span> state <span class="fu">&lt;$</span> state&#39;</a>
<a class="sourceLine" id="cb9-12" title="12">    <span class="dt">Right</span> (<span class="dt">Yo</span> (<span class="dt">HoistInterpretation</span> na) state&#39; _ y _) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb9-13" title="13">      <span class="fu">pure</span> <span class="fu">$</span> y <span class="fu">$</span> (distrib <span class="fu">.</span> <span class="fu">fmap</span> na) <span class="fu">&lt;$</span> state&#39;</a></code></pre></div>
<p>We can finally implement <code>interpret</code>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1">interpret</a>
<a class="sourceLine" id="cb10-2" title="2"><span class="ot">    ::</span> (<span class="ot">∀</span> x m <span class="fu">.</span> e m x <span class="ot">-&gt;</span> <span class="dt">Tactical</span> e m r x)</a>
<a class="sourceLine" id="cb10-3" title="3">    <span class="ot">-&gt;</span> <span class="dt">Sem</span> (e &#39;<span class="fu">:</span> r) a</a>
<a class="sourceLine" id="cb10-4" title="4">    <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</a>
<a class="sourceLine" id="cb10-5" title="5">interpret f (<span class="dt">Sem</span> m) <span class="fu">=</span> m <span class="fu">$</span> \u <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb10-6" title="6">  <span class="kw">case</span> decomp u <span class="kw">of</span></a>
<a class="sourceLine" id="cb10-7" title="7">    <span class="dt">Left</span>  x <span class="ot">-&gt;</span> liftSem <span class="fu">$</span> hoist (interpret f) x</a>
<a class="sourceLine" id="cb10-8" title="8">    <span class="dt">Right</span> (<span class="dt">Yo</span> eff state distrib y) <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb10-9" title="9">      a <span class="ot">&lt;-</span> runTactics state distrib <span class="fu">$</span> f eff</a>
<a class="sourceLine" id="cb10-10" title="10">      <span class="fu">pure</span> <span class="fu">$</span> y a</a></code></pre></div>
<p>We’ve hid all of the nasty type inside of that <code>Tactical</code> synonym (which admittedly is still gross, but at least it’s not rank 3.) And we’ve create an effect interpreter effect in which we can put any combinators people will need for writing interpreters.</p>
<p>After renaming <code>start</code> to <code>runT</code> and <code>continue</code> to <code>bindT</code> for branding purposes, <code>runResource</code> ends up in its final form:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1">runResource</a>
<a class="sourceLine" id="cb11-2" title="2"><span class="ot">    ::</span> <span class="ot">∀</span> r a</a>
<a class="sourceLine" id="cb11-3" title="3">     <span class="fu">.</span> <span class="dt">Member</span> (<span class="dt">Lift</span> <span class="dt">IO</span>) r</a>
<a class="sourceLine" id="cb11-4" title="4">    <span class="ot">=&gt;</span> (<span class="ot">∀</span> x<span class="fu">.</span> <span class="dt">Sem</span> r x <span class="ot">-&gt;</span> <span class="dt">IO</span> x)</a>
<a class="sourceLine" id="cb11-5" title="5">    <span class="ot">-&gt;</span> <span class="dt">Sem</span> (<span class="dt">Resource</span> &#39;<span class="fu">:</span> r) a</a>
<a class="sourceLine" id="cb11-6" title="6">    <span class="ot">-&gt;</span> <span class="dt">Sem</span> r a</a>
<a class="sourceLine" id="cb11-7" title="7">runResource lower <span class="fu">=</span> interpret <span class="fu">$</span> \<span class="kw">case</span></a>
<a class="sourceLine" id="cb11-8" title="8">  <span class="dt">Bracket</span> alloc dealloc use <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb11-9" title="9">    <span class="kw">let</span><span class="ot"> toIO ::</span> <span class="dt">Sem</span> (<span class="dt">Resource</span> &#39;<span class="fu">:</span> r) x <span class="ot">-&gt;</span> <span class="dt">IO</span> x</a>
<a class="sourceLine" id="cb11-10" title="10">        toIO <span class="fu">=</span> lower <span class="fu">.</span> runResource lower</a>
<a class="sourceLine" id="cb11-11" title="11"></a>
<a class="sourceLine" id="cb11-12" title="12">    a <span class="ot">&lt;-</span> runT  alloc</a>
<a class="sourceLine" id="cb11-13" title="13">    d <span class="ot">&lt;-</span> bindT dealloc</a>
<a class="sourceLine" id="cb11-14" title="14">    u <span class="ot">&lt;-</span> bindT use</a>
<a class="sourceLine" id="cb11-15" title="15">    sendM <span class="fu">$</span> X.bracket (toIO a) (toIO <span class="fu">.</span> d) (toIO <span class="fu">.</span> u)</a></code></pre></div>
<p>I’m unable to properly express the amount of joy I get in using a library to implement core features in itself. The result is one of the most mind-crushingly meta things I’ve ever written, but it elegantly solves a real problem — so why not?</p>
<p>In the next post in this series, we’ll discuss the semantics behind the order in which you interpret effects, and how this can get you into trouble with things like <code>runResource</code>. Stay tuned.</p>
        ]]>
      </content>
    </entry>
    <entry>
      <title>Implement With Types, Not Your Brain!</title>
      <id>blog/typeholes/index.html</id>
      <link href='blog/typeholes/index.html'/>
      <published>2019-06-25T14:56:00Z</published>
      <updated>2019-06-25T14:56:00Z</updated>

      <content type="html">
        <![CDATA[
        <p>When asked about the virtues of Haskell’s strong type system, most people will say the best part is that it lets you refactor with a zen-like tranquility, or that it stops your program from crashing at runtime. I mean, those are both great. But my favorite part is that having a strong type system means I don’t need to use my brain to do programming.</p>
<p>It sounds snide, but it’s true. Here’s a function from <a href="https://github.com/polysemy-research/polysemy">my library polysemy</a>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1">hoistStateIntoStateT</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="ot">    ::</span> <span class="dt">Sem</span> (<span class="dt">State</span> s &#39;<span class="fu">:</span> r) a</a>
<a class="sourceLine" id="cb1-3" title="3">    <span class="ot">-&gt;</span> <span class="dt">S.StateT</span> s (<span class="dt">Sem</span> r) a</a>
<a class="sourceLine" id="cb1-4" title="4">hoistStateIntoStateT (<span class="dt">Sem</span> m) <span class="fu">=</span> m <span class="fu">$</span> \u <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb1-5" title="5">  <span class="kw">case</span> decomp u <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-6" title="6">    <span class="dt">Left</span> x <span class="ot">-&gt;</span> <span class="dt">S.StateT</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb1-7" title="7">      liftSem <span class="fu">.</span> <span class="fu">fmap</span> swap</a>
<a class="sourceLine" id="cb1-8" title="8">              <span class="fu">.</span> weave (s, ())</a>
<a class="sourceLine" id="cb1-9" title="9">                      (\(s&#39;, m&#39;) <span class="ot">-&gt;</span> <span class="fu">fmap</span> swap</a>
<a class="sourceLine" id="cb1-10" title="10">                                  <span class="fu">$</span> S.runStateT m&#39; s&#39;)</a>
<a class="sourceLine" id="cb1-11" title="11">                      (<span class="dt">Just</span> <span class="fu">.</span> <span class="fu">snd</span>)</a>
<a class="sourceLine" id="cb1-12" title="12">              <span class="fu">$</span> hoist hoistStateIntoStateT x</a>
<a class="sourceLine" id="cb1-13" title="13">    <span class="dt">Right</span> (<span class="dt">Yo</span> <span class="dt">Get</span> z _ y _)     <span class="ot">-&gt;</span> <span class="fu">fmap</span> (y <span class="fu">.</span> (<span class="fu">&lt;$</span> z)) <span class="fu">$</span> S.get</a>
<a class="sourceLine" id="cb1-14" title="14">    <span class="dt">Right</span> (<span class="dt">Yo</span> (<span class="dt">Put</span> s) z _ y _) <span class="ot">-&gt;</span> <span class="fu">fmap</span> (y <span class="fu">.</span> (<span class="fu">&lt;$</span> z)) <span class="fu">$</span> S.put s</a></code></pre></div>
<p>Gee, that’s complicated! I must be really smart to have written such a function, right?</p>
<p>Wrong! I just have a trick!</p>
<p>The technique is called “just use type holes,” and for my money, it’s the most important skill in a Haskeller’s tool-belt. The idea is to implement the tiny part of a function that you know how to do, and then ask the compiler for help on the rest of it. It’s an iterative process. It’s a discussion with the compiler. Each step of the way, you get a little closer to the right answer, and after enough iterations your function has written itself — even if you’re not entirely sure <em>how.</em></p>
<p>Let’s go through an example together. Consider the random type signature that I just made up:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="ot">jonk ::</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> ((a <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> ((b <span class="ot">-&gt;</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span> <span class="dt">Int</span>)</a></code></pre></div>
<p>If you want a challenge, take a few minutes to try to implement this function. It’s tricky, and most people get lost along the way. When you’re convinced that it’s sufficiently hard, continue reading.</p>
<p>The first step of writing a function is to bind all of the variables we have. That’s the <code>a -&gt; b</code> and <code>(a -&gt; Int) -&gt; Int</code> bits here. I usually give them names that help me remember their types — such as <code>ab</code> and <code>aii</code>, respectively.</p>
<p>Then, bang out a <code>_</code> on the right hand side. This thing is a placeholder, and is called a type hole.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1">jonk ab aii <span class="fu">=</span> _</a></code></pre></div>
<p>Try to compile this (consider using something like <a href="https://github.com/ndmitchell/ghcid">ghcid</a> so you don’t need to call <code>ghc</code> by hand.) The compiler will yell at you:</p>
<pre><code>    • Found hole: _ :: (b -&gt; Int) -&gt; Int
      Where: ‘b’ is a rigid type variable bound by
               the type signature for:
                 jonk :: forall a b.
                         (a -&gt; b) -&gt; ((a -&gt; Int) -&gt; Int) -&gt; (b -&gt; Int) -&gt; Int
               at /home/sandy/Test.hs:3:1-62
    • In the expression: _
      In an equation for ‘jonk’: jonk ab aii = _
    • Relevant bindings include
        aii :: (a -&gt; Int) -&gt; Int (bound at /home/sandy/Test.hs:4:9)
        ab :: a -&gt; b (bound at /home/sandy/Test.hs:4:6)
        jonk :: (a -&gt; b) -&gt; ((a -&gt; Int) -&gt; Int) -&gt; (b -&gt; Int) -&gt; Int
          (bound at /home/sandy/Test.hs:4:1)
  |
4 | jonk ab aii = _
  |</code></pre>
<p>A common complaint from beginners is that GHC’s error messages are noisy. This is true. To a first approximation, the useful bit of this error message is this:</p>
<pre><code>• Found hole: _ :: (b -&gt; Int) -&gt; Int
• Relevant bindings include
    aii :: (a -&gt; Int) -&gt; Int (bound at /home/sandy/Test.hs:4:9)
    ab :: a -&gt; b (bound at /home/sandy/Test.hs:4:6)
    jonk :: (a -&gt; b) -&gt; ((a -&gt; Int) -&gt; Int) -&gt; (b -&gt; Int) -&gt; Int
      (bound at /home/sandy/Test.hs:4:1)</code></pre>
<p>There’s no way of getting GHC to shut up about that other stuff, so you just need to train yourself to focus on this core piece of information. That’s not to say the other stuff <em>isn’t</em> helpful, just that this stuff is almost always enough.</p>
<p>So what is the compiler telling us? Two things:</p>
<ol type="1">
<li>The expression we want to replace <code>_</code> with must have type <code>(b -&gt; Int) -&gt; Int</code>.</li>
<li>We have some local binds (<code>aii</code>, <code>ab</code>, <code>jonk</code>, and their types) that we can use to help with the implementation.</li>
</ol>
<p>Using this information, our goal is to write the correct expression in place of the type hole. In most cases doing that in one step is unfeasible, but we can often write a little more of expression, and use a type hole in <em>that</em>.</p>
<p>In this case, we notice that our hole has type <code>(b -&gt; Int) -&gt; Int</code>, which is to say, that it’s a function that takes a <code>(b -&gt; Int)</code> and returns an <code>Int</code>. As such, it means we should bind the <code>(b -&gt; Int)</code> in a lambda:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1">jonk ab aii <span class="fu">=</span> \bi <span class="ot">-&gt;</span> _</a></code></pre></div>
<p>The resulting error message in full is this:</p>
<pre><code>    • Found hole: _ :: Int
    • In the expression: _
      In the expression: \ bi -&gt; _
      In an equation for ‘jonk’: jonk ab aii = \ bi -&gt; _
    • Relevant bindings include
        bi :: b -&gt; Int (bound at /home/sandy/Test.hs:4:16)
        aii :: (a -&gt; Int) -&gt; Int (bound at /home/sandy/Test.hs:4:9)
        ab :: a -&gt; b (bound at /home/sandy/Test.hs:4:6)
        jonk :: (a -&gt; b) -&gt; ((a -&gt; Int) -&gt; Int) -&gt; (b -&gt; Int) -&gt; Int
          (bound at /home/sandy/Test.hs:4:1)
      Valid hole fits include
        maxBound :: forall a. Bounded a =&gt; a
          with maxBound @Int
          (imported from ‘Prelude’ at /home/sandy/Test.hs:1:1
           (and originally defined in ‘GHC.Enum’))
        minBound :: forall a. Bounded a =&gt; a
          with minBound @Int
          (imported from ‘Prelude’ at /home/sandy/Test.hs:1:1
           (and originally defined in ‘GHC.Enum’))
  |
4 | jonk ab aii = \bi -&gt; _
  |</code></pre>
<p>GHC now mentions “Valid hole fits”. In my experience, these are almost always useless, so I just exclude them. In GHCi, the following incantation will make them disappear.</p>
<pre><code>:set -fmax-valid-hole-fits=0</code></pre>
<p>(or you can just squint and ignore them manually!)</p>
<p>Again, ignoring the irrelevant pieces of the error message, we can pare GHC’s response down to this:</p>
<pre><code>• Found hole: _ :: Int
• Relevant bindings include
    bi :: b -&gt; Int (bound at /home/sandy/Test.hs:4:16)
    aii :: (a -&gt; Int) -&gt; Int (bound at /home/sandy/Test.hs:4:9)
    ab :: a -&gt; b (bound at /home/sandy/Test.hs:4:6)
    jonk :: (a -&gt; b) -&gt; ((a -&gt; Int) -&gt; Int) -&gt; (b -&gt; Int) -&gt; Int
      (bound at /home/sandy/Test.hs:4:1)</code></pre>
<p>OK, great! Now we just need to produce an <code>Int</code>. While we could just put <code>0</code> here, that is a <em>clearly wrong</em> solution, since we wouldn’t be using any of <code>ab</code>, <code>aii</code> or <code>bi</code>. Don’t just return <code>0</code>.</p>
<p>But we notice that both <code>aii</code> and <code>bi</code> will return an <code>Int</code>. Since that’s what we want to return, the odds are good that we want to call one of these functions in this hole. Let’s choose <code>aii</code> as a guess. Feel free to write in your notebook that you are guessing about <code>aii</code>, but also <code>bi</code> could have been chosen — we have no guarantees that <code>aii</code> is the right call!</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1">jonk ab aii <span class="fu">=</span> \bi <span class="ot">-&gt;</span> aii <span class="fu">$</span> _</a></code></pre></div>
<pre><code>• Found hole: _ :: a -&gt; Int
• Relevant bindings include
    bi :: b -&gt; Int (bound at /home/sandy/Test.hs:4:16)
    aii :: (a -&gt; Int) -&gt; Int (bound at /home/sandy/Test.hs:4:9)
    ab :: a -&gt; b (bound at /home/sandy/Test.hs:4:6)
    jonk :: (a -&gt; b) -&gt; ((a -&gt; Int) -&gt; Int) -&gt; (b -&gt; Int) -&gt; Int
      (bound at /home/sandy/Test.hs:4:1)</code></pre>
<p>Our hole has a function type, so let’s introduce a lambda:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1">jonk ab aii <span class="fu">=</span> \bi <span class="ot">-&gt;</span> aii <span class="fu">$</span> \a <span class="ot">-&gt;</span> _</a></code></pre></div>
<pre><code>• Found hole: _ :: Int
• Relevant bindings include
    a :: a (bound at /home/sandy/Test.hs:4:29)
    bi :: b -&gt; Int (bound at /home/sandy/Test.hs:4:16)
    aii :: (a -&gt; Int) -&gt; Int (bound at /home/sandy/Test.hs:4:9)
    ab :: a -&gt; b (bound at /home/sandy/Test.hs:4:6)
    jonk :: (a -&gt; b) -&gt; ((a -&gt; Int) -&gt; Int) -&gt; (b -&gt; Int) -&gt; Int
      (bound at /home/sandy/Test.hs:4:1)</code></pre>
<p>We need to produce an <code>Int</code> again. Since we don’t have one in scope, our only options are again <code>aii</code> and <code>bi</code>. But we’ve already used <code>aii</code>, so let’s try <code>bi</code> this time.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1">jonk ab aii <span class="fu">=</span> \bi <span class="ot">-&gt;</span> aii <span class="fu">$</span> \a <span class="ot">-&gt;</span> bi <span class="fu">$</span> _</a></code></pre></div>
<pre><code>• Found hole: _ :: b
• Relevant bindings include
    a :: a (bound at /home/sandy/Test.hs:4:29)
    bi :: b -&gt; Int (bound at /home/sandy/Test.hs:4:16)
    aii :: (a -&gt; Int) -&gt; Int (bound at /home/sandy/Test.hs:4:9)
    ab :: a -&gt; b (bound at /home/sandy/Test.hs:4:6)
    jonk :: (a -&gt; b) -&gt; ((a -&gt; Int) -&gt; Int) -&gt; (b -&gt; Int) -&gt; Int
      (bound at /home/sandy/Test.hs:4:1)</code></pre>
<p>Great! Now we need to produce a <code>b</code>. We have a function that can do that, <code>ab :: a -&gt; b</code>. So let’s call <em>that</em>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1">jonk ab aii <span class="fu">=</span> \bi <span class="ot">-&gt;</span> aii <span class="fu">$</span> \a <span class="ot">-&gt;</span> bi <span class="fu">$</span> ab <span class="fu">$</span> _</a></code></pre></div>
<pre><code>• Found hole: _ :: a
• Relevant bindings include
    a :: a (bound at /home/sandy/Test.hs:4:29)
    bi :: b -&gt; Int (bound at /home/sandy/Test.hs:4:16)
    aii :: (a -&gt; Int) -&gt; Int (bound at /home/sandy/Test.hs:4:9)
    ab :: a -&gt; b (bound at /home/sandy/Test.hs:4:6)
    jonk :: (a -&gt; b) -&gt; ((a -&gt; Int) -&gt; Int) -&gt; (b -&gt; Int) -&gt; Int
      (bound at /home/sandy/Test.hs:4:1)</code></pre>
<p>Finally, we have a hole whose type is <code>a</code>. And we <em>have</em> an <code>a</code>! Let’s just use that thing!</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" title="1">jonk ab aii <span class="fu">=</span> \bi <span class="ot">-&gt;</span> aii <span class="fu">$</span> \a <span class="ot">-&gt;</span> bi <span class="fu">$</span> ab <span class="fu">$</span> a</a></code></pre></div>
<pre><code>[1 of 1] Compiling Main             ( /home/sandy/Test.hs, interpreted )
Ok, one module loaded.</code></pre>
<p>Cool! It worked! We just wrote a non-trivial function without doing any thinking, really. Not bad! But can we be confident that our implementation is any good?</p>
<p>The first line of defense against this is to enable <code>-Wall</code>. In GHCi, you can do this via:</p>
<pre><code>:set -Wall</code></pre>
<p>You’ll notice there are no warnings generated by our definition. This is usually enough of a sanity check that our implementation is fine. For example, let’s see what happens when we try the <em>obviously stupid</em> implementation:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" title="1">jonk ab aii <span class="fu">=</span> \bi <span class="ot">-&gt;</span> <span class="dv">0</span></a></code></pre></div>
<pre><code>/home/sandy/Test.hs:4:6: warning: [-Wunused-matches]
    Defined but not used: ‘ab’
  |
4 | jonk ab aii = \bi -&gt; 0
  |      ^^

/home/sandy/Test.hs:4:9: warning: [-Wunused-matches]
    Defined but not used: ‘aii’
  |
4 | jonk ab aii = \bi -&gt; 0
  |         ^^^

/home/sandy/Test.hs:4:16: warning: [-Wunused-matches]
    Defined but not used: ‘bi’
  |
4 | jonk ab aii = \bi -&gt; 0
  |</code></pre>
<p>Those warnings are pointing out that we haven’t used everything available to us. If we assume that the <em>type of <code>jonk</code> is correct</em>, then any implementation of <code>jonk</code> which doesn’t use all of its variables is <em>extremely suspect.</em></p>
<p>The other common way to go wrong here is that you’ll notice that <code>jonk</code> comes up in the relevant bindings <em>while trying to write <code>jonk</code>.</em> For example, this thing will happily typecheck:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" title="1">jonk <span class="fu">=</span> jonk</a></code></pre></div>
<p>But this too is clearly wrong, since we haven’t done any work. The situation becomes more insidious when you call yourself recursively <em>after doing some work</em>, which can be correct. Let’s look at an example of that.</p>
<p>Let’s try this type on for size:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" title="1"><span class="ot">zoop ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b</a></code></pre></div>
<p>The first thing to do is to bind all of our variables:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" title="1">zoop abb b as <span class="fu">=</span> _</a></code></pre></div>
<p>But we notice that <code>as</code> has type <code>[a]</code>. Since <code>[a]</code> has two constructors, let’s pattern match on those before going any further.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" title="1">zoop abb b []       <span class="fu">=</span> _</a>
<a class="sourceLine" id="cb26-2" title="2">zoop abb b (a <span class="fu">:</span> as) <span class="fu">=</span> _</a></code></pre></div>
<pre><code>• Found hole: _ :: b
• Relevant bindings include
    b :: b (bound at /home/sandy/Test.hs:4:10)
    abb :: a -&gt; b -&gt; b (bound at /home/sandy/Test.hs:4:6)
    zoop :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
      (bound at /home/sandy/Test.hs:4:1)

• Found hole: _ :: b
• Relevant bindings include
    as :: [a] (bound at /home/sandy/Test.hs:5:17)
    a :: a (bound at /home/sandy/Test.hs:5:13)
    b :: b (bound at /home/sandy/Test.hs:5:10)
    abb :: a -&gt; b -&gt; b (bound at /home/sandy/Test.hs:5:6)
    zoop :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
      (bound at /home/sandy/Test.hs:4:1)</code></pre>
<p>Oh god! Too many holes at once. My brain is already exploding. You honestly expect me to keep this much information in my head at once?? Instead, we can replace one of the holes with <code>undefined</code> in order to get GHC to shut up and let us focus.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" title="1">zoop abb b []        <span class="fu">=</span> _</a>
<a class="sourceLine" id="cb28-2" title="2">zoop abb b (a <span class="fu">:</span> as) <span class="fu">=</span> <span class="fu">undefined</span></a></code></pre></div>
<pre><code>• Found hole: _ :: b
• Relevant bindings include
    b :: b (bound at /home/sandy/Test.hs:4:10)
    abb :: a -&gt; b -&gt; b (bound at /home/sandy/Test.hs:4:6)
    zoop :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
      (bound at /home/sandy/Test.hs:4:1)</code></pre>
<p>Much easier. We see that we need to produce a <code>b</code>, and hey, look at that. We already have one. Furthermore, <em>we don’t</em> have an <code>a</code>, and so we have <em>no chance</em> of calling <code>abb</code>. So we assume <code>b</code> is correct. Let’s fill it in, and then replace our <code>undefined</code> with a hole again:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" title="1">zoop abb b []       <span class="fu">=</span> b</a>
<a class="sourceLine" id="cb30-2" title="2">zoop abb b (a <span class="fu">:</span> as) <span class="fu">=</span> _</a></code></pre></div>
<pre><code>• Found hole: _ :: b
• Relevant bindings include
    as :: [a] (bound at /home/sandy/Test.hs:5:17)
    a :: a (bound at /home/sandy/Test.hs:5:13)
    b :: b (bound at /home/sandy/Test.hs:5:10)
    abb :: a -&gt; b -&gt; b (bound at /home/sandy/Test.hs:5:6)
    zoop :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
      (bound at /home/sandy/Test.hs:4:1)</code></pre>
<p>Again we want to produce a <code>b</code>. We <em>could</em> use the <code>b</code> we have, but that would mean <code>abb</code> is completely unused in our function. So let’s assume we want to call <code>abb</code> instead. Since it takes two arguments, let’s give the first one a hole, and the second <code>undefined</code>. One step at a time.</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb32-1" title="1">zoop abb b []       <span class="fu">=</span> b</a>
<a class="sourceLine" id="cb32-2" title="2">zoop abb b (a <span class="fu">:</span> as) <span class="fu">=</span> abb _ <span class="fu">undefined</span></a></code></pre></div>
<pre><code>• Found hole: _ :: a
• Relevant bindings include
    as :: [a] (bound at /home/sandy/Test.hs:5:17)
    a :: a (bound at /home/sandy/Test.hs:5:13)
    b :: b (bound at /home/sandy/Test.hs:5:10)
    abb :: a -&gt; b -&gt; b (bound at /home/sandy/Test.hs:5:6)
    zoop :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
      (bound at /home/sandy/Test.hs:4:1)</code></pre>
<p>We want an <code>a</code>. And we have an <code>a</code>. Since we have no guarantees that <code>as</code> isn’t <code>[]</code>, this <code>a</code> is our only choice. So it’s pretty safe to assume our hole should be filled with <code>a</code>.</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb34-1" title="1"><span class="ot">zoop ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb34-2" title="2">zoop abb b []       <span class="fu">=</span> b</a>
<a class="sourceLine" id="cb34-3" title="3">zoop abb b (a <span class="fu">:</span> as) <span class="fu">=</span> abb a _</a></code></pre></div>
<pre><code>• Found hole: _ :: b
• Relevant bindings include
    as :: [a] (bound at /home/sandy/Test.hs:5:17)
    a :: a (bound at /home/sandy/Test.hs:5:13)
    b :: b (bound at /home/sandy/Test.hs:5:10)
    abb :: a -&gt; b -&gt; b (bound at /home/sandy/Test.hs:5:6)
    zoop :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
      (bound at /home/sandy/Test.hs:4:1)</code></pre>
<p>So we need to produce a <code>b</code>, and we still have the unused <code>as :: [a]</code> to work with, so it’s unlikely to just be our binding <code>b</code>. Instead, our only option which takes a <code>[a]</code> is <code>zoop</code> itself! This is a recursive call, but we’ve already popped the head off our list, so it’s not going to be an infinite loop.</p>
<p>Lets fill in our hole with <code>zoop _ _ as</code>. Or, <code>zoop _ undefined as</code> if you prefer.</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb36-1" title="1">zoop abb b []       <span class="fu">=</span> b</a>
<a class="sourceLine" id="cb36-2" title="2">zoop abb b (a <span class="fu">:</span> as) <span class="fu">=</span> abb a <span class="fu">$</span> zoop _ <span class="fu">undefined</span> as</a></code></pre></div>
<pre><code>• Found hole: _ :: a -&gt; b -&gt; b
• Relevant bindings include
    as :: [a] (bound at /home/sandy/Test.hs:5:17)
    a :: a (bound at /home/sandy/Test.hs:5:13)
    b :: b (bound at /home/sandy/Test.hs:5:10)
    abb :: a -&gt; b -&gt; b (bound at /home/sandy/Test.hs:5:6)
    zoop :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b
      (bound at /home/sandy/Test.hs:4:1)</code></pre>
<p>Probably <code>abb</code>, because we’re recursing, and have no real reason to want to change this function. Fill it in, and, for the same argument, replace our <code>undefined</code> with <code>b</code>. Our final function in all its glory is this:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb38-1" title="1"><span class="ot">zoop ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb38-2" title="2">zoop abb b []       <span class="fu">=</span> b</a>
<a class="sourceLine" id="cb38-3" title="3">zoop abb b (a <span class="fu">:</span> as) <span class="fu">=</span> abb a <span class="fu">$</span> zoop abb b as</a></code></pre></div>
<p>And it works! Except that <code>-Wall</code> yells at us:</p>
<pre><code>/home/sandy/Test.hs:4:6: warning: [-Wunused-matches]
    Defined but not used: ‘abb’
  |
4 | zoop abb b []       = b
  |</code></pre>
<p>This is a little alarming, until we realize that <code>abb</code> isn’t <em>not</em> used in <code>zoop</code>, it’s just not used in this branch. We can put a wildcard to match <code>abb</code> here to get rid of this warning:</p>
<div class="sourceCode" id="cb40"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb40-1" title="1"><span class="ot">zoop ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b</a>
<a class="sourceLine" id="cb40-2" title="2">zoop _   b []       <span class="fu">=</span> b</a>
<a class="sourceLine" id="cb40-3" title="3">zoop abb b (a <span class="fu">:</span> as) <span class="fu">=</span> abb a <span class="fu">$</span> zoop abb b as</a></code></pre></div>
<p>(note that this <code>_</code> on the left-hand side of the equals sign is <em>not</em> a type hole, it’s a wildcard pattern match!)</p>
<p>Finally we’re finished! A little experimentation will convince you that this <code>zoop</code> thing we just wrote is in fact just <code>foldr</code>! Pretty impressive for just blindly filling in holes, no?</p>
<p>I’m not going to say that blindly filling in type holes <em>always</em> works, but I’d say maybe 95% of the time? It’s truly amazing just how far you can get by writing down the right type and making sure you use every variable.</p>
<p>The reason why this works is known as <a href="/blog/theorems-for-free/">theorems for free</a>, which roughly states that we can infer lots of facts about a type signature (assuming it’s correct.) One of those facts we can infer is often the <em>the only possible implementation.</em> It’s cool as fuck, but you don’t need to understand the paper to use this idea in practice.</p>
<p>One question you might have is “what the heck does it mean for a type to be correct?” Good question! It means your type should be <em>as polymorphic as possible</em>. For example, if you want a function that creates a list with length <span class="math inline">\(n\)</span>, where all elements are the same value, then that thing should have type <code>Int -&gt; a -&gt; [a]</code>, not <code>Int -&gt; Bool -&gt; [Bool]</code>. Because we can do this operation for any type, we don’t need to give it a monomorphic type. Here we would say <code>Int -&gt; a -&gt; [a]</code> is the correct type for this operation, while <code>Int -&gt; Bool -&gt; [Bool]</code> is not.</p>
<p>You know when people say “types are not an alternative to documentation?” I think this is a pretty knock-down argument to that claim. Once you really understand the typesystem, most of the time, types <em>really are</em> the best documentation — they often tell you <em>exactly</em> what the function does, in a way that English comments never will.</p>
<p>In conclusion, a strong type system is fucking awesome because it’s smart enough to know the necessary type of any given expression. Which means you can slowly use type holes to chip away at a difficult implementation, without ever really knowing what you’re doing. It’s <em>marvelous.</em> Get into the habit of using this technique, and you’ll quickly be amazed at just how good you get at Haskell.</p>
        ]]>
      </content>
    </entry>
    <entry>
      <title>Polysemy Internals: Freer Interpretations of Higher-Order Effects</title>
      <id>blog/freer-higher-order-effects/index.html</id>
      <link href='blog/freer-higher-order-effects/index.html'/>
      <published>2019-05-31T01:11:00Z</published>
      <updated>2019-05-31T01:11:00Z</updated>

      <content type="html">
        <![CDATA[
        <blockquote>
<p>aka “what the hell is that <code>Yo</code> type?”</p>
</blockquote>
<p>This is the first post in a series of implementation details in <a href="https://github.com/isovector/polysemy"><code>polysemy</code></a> — a fast, powerful and low-boilerplate effect-system library.</p>
<p>Even if you’re not particularly interested in <code>polysemy</code>, there are some functional pearls here — and a crash course on the history on the implementations of free monads in Haskell.</p>
<hr />
<p>Critics of free monads often make the claim that higher-order effects aren’t possible. This has historically been true, but Wu, Schrijvers and Hinze’s paper <a href="https://www.cs.ox.ac.uk/people/nicolas.wu/papers/Scope.pdf">Effect Handlers in Scope</a> gives a technique for lifting the restriction. Today I want to illustrate the problem, discuss Wu et al.’s solution, and then show what changes <code>polysemy</code> makes to remove the boilerplate. In the process, we’ll look at finding free constructions for tricky typeclasses.</p>
<h2 id="the-problem">The Problem</h2>
<p>Let’s consider the <code>Error e</code> effect, in which we’d like to be able to <code>throw</code> errors of type <code>e</code>, and <code>catch</code> any errors thrown within a specific block of code. You’re already familiar with this concept, in <code>transformers</code> it’s called <code>ExceptT e</code>, and in <code>mtl</code>, <code>MonadError e</code>. A typical usage of this effect might be:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1">foo <span class="fu">=</span></a>
<a class="sourceLine" id="cb1-2" title="2">  <span class="fu">catch</span></a>
<a class="sourceLine" id="cb1-3" title="3">    <span class="kw">do</span>             <span class="co">-- computation to run</span></a>
<a class="sourceLine" id="cb1-4" title="4">      when (<span class="fu">not</span> someBool) <span class="fu">$</span> throw <span class="dt">SomeError</span></a>
<a class="sourceLine" id="cb1-5" title="5">      <span class="fu">pure</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb1-6" title="6">    \<span class="dt">SomeError</span> <span class="ot">-&gt;</span>  <span class="co">-- error handler</span></a>
<a class="sourceLine" id="cb1-7" title="7">      <span class="fu">pure</span> <span class="dt">False</span></a></code></pre></div>
<p>We would expect <code>foo</code> to be <code>pure False</code> whenever <code>someBool</code> is <code>False</code>; and vice versa. The idea is that a <code>throw</code> should short-circuit the rest of the computation, until it reaches the end of a <code>catch</code> statement. This is the basis of every exception system of all time, so we won’t belabor the example any further.</p>
<p>Given some appropriate <code>m</code>, we’d like to model this problem with the following interface:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="ot">throw ::</span> e <span class="ot">-&gt;</span> m a</a>
<a class="sourceLine" id="cb2-2" title="2"><span class="fu">catch</span><span class="ot"> ::</span> m a <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> m a</a></code></pre></div>
<p>In first-order effect systems such as <a href="http://hackage.haskell.org/package/freer-simple"><code>freer-simple</code></a>, our effects have kind <code>* -&gt; *</code>. With such a kind, we can easily model <code>throw</code>, but it’s less clear how to model <code>catch</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">data</span> <span class="dt">Error</span> e a <span class="kw">where</span></a>
<a class="sourceLine" id="cb3-2" title="2">  <span class="dt">Throw</span><span class="ot"> ::</span> e <span class="ot">-&gt;</span> <span class="dt">Error</span> e a</a>
<a class="sourceLine" id="cb3-3" title="3">  <span class="dt">Catch</span><span class="ot"> ::</span> <span class="fu">??</span></a></code></pre></div>
<p>We simply don’t have an <code>m</code> available to us in order to write something equivalent to <code>m a -&gt; (e -&gt; m a) -&gt; m a</code>. There are a few unsatisfactory solutions here — you can either choose a concrete <code>m</code> and bake it in (which defeats the <em>entire purpose</em> of effect systems), or you can attempt to encode <code>m</code> somewhere inside of the <code>Error e</code> part. Neither is fruitful.</p>
<p><code>freer-simple</code> actually takes a pretty clever approach to this problem. Instead of modeling <code>catch</code> in the <code>Error e</code> effect, it just provides <code>catch</code> as a function:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="fu">catch</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="ot">    ::</span> <span class="dt">Member</span> (<span class="dt">Error</span> e) r</a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="ot">=&gt;</span> <span class="dt">Eff</span> r a</a>
<a class="sourceLine" id="cb4-4" title="4">    <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> <span class="dt">Eff</span> r a)</a>
<a class="sourceLine" id="cb4-5" title="5">    <span class="ot">-&gt;</span> <span class="dt">Eff</span> r a</a>
<a class="sourceLine" id="cb4-6" title="6"><span class="fu">catch</span> ma f <span class="fu">=</span> <span class="co">-- replace every call to `throw e` in `ma` with `f e`</span></a></code></pre></div>
<p>And what do you know, this solution actually works pretty well. It accurately captures the semantics of <code>catch</code> for <code>ExceptT</code>. Success! For most people, most of the time, this implementation of <code>catch</code> is perfectly fine.</p>
<p>But let’s consider an interpretation of <code>Error e</code> which <em>isn’t</em> completely analogous to <code>ExceptT</code>. After all, the whole point of effect-systems is to be able to arbitrarily reinterpret the meaning of your programs. So let’s pretend that we’re writing an interpretation of the system which wants to audit the happy code path. As a result, we’d like to log whether or not we successfully got to the end of a <code>catch</code> block.</p>
<p>In essence, we’d like to replace every call to <code>catch ma f</code> with:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1">catch&#39; ma f <span class="fu">=</span> <span class="fu">catch</span> (ma <span class="fu">&lt;*</span> logSuccessfulExit) f</a></code></pre></div>
<p>meaning <code>logSuccessfulExit</code> will be called <em>if and only if</em> <code>ma</code> didn’t contain a <code>throw</code> statement.</p>
<p>Unfortunately, the clever encoding of <code>catch</code> as a separate function <em>outside</em> of <code>Effect e</code> means that this interpretation of <code>catch</code> is impossible. The problem is fundamentally that by virtue of being outside the effect, <code>catch</code> must choose its own interpretation of catching effects, and you’re out of luck if its choice isn’t what you want.</p>
<p>This is a bit of a contrived example, but it shows up every time you want to embed a computation; such as doing callbacks, coroutines, asynchronous work, or resource bracketing. It’s a <em>big</em> class of problems that quickly become untenable in the first-order world.</p>
<h2 id="effect-handlers-in-scope">Effect Handlers in Scope</h2>
<p><a href="https://www.cs.ox.ac.uk/people/nicolas.wu/papers/Scope.pdf">Wu et al. give us a real solution</a> for the problem above. Instead of modeling our effects with kind <code>* -&gt; *</code>, we give them a kind <code>(* -&gt; *) -&gt; * -&gt; *</code>. This extra <code>(* -&gt; *)</code> is enough to hold a monad in. As such, <code>Error e</code> is now modeled as:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">data</span> <span class="dt">Error</span> e m a <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-2" title="2">  <span class="dt">Throw</span><span class="ot"> ::</span> e <span class="ot">-&gt;</span> <span class="dt">Error</span> e m a</a>
<a class="sourceLine" id="cb6-3" title="3">  <span class="dt">Catch</span><span class="ot"> ::</span> m a <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> m a) <span class="ot">-&gt;</span> <span class="dt">Error</span> e m a</a></code></pre></div>
<p>This extra <code>m</code> parameter lets us write <code>Catch</code> as a constructor, meaning it is now part of the effect algebra. By writing clever constructors, we can force <code>m</code> to be the effect stack we’re running in:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="fu">catch</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="ot">    ::</span> <span class="dt">Member</span> (<span class="dt">Error</span> e) r</a>
<a class="sourceLine" id="cb7-3" title="3">    <span class="ot">=&gt;</span> <span class="dt">Eff</span> r a <span class="ot">-&gt;</span> (e <span class="ot">-&gt;</span> <span class="dt">Eff</span> r a) <span class="ot">-&gt;</span> <span class="dt">Eff</span> r a</a></code></pre></div>
<p>which nicely ties the recursive knot.</p>
<p>This change is pretty straightforward, and has probably occurred to most people who’ve spent any time playing around with the internals of first-order free monads. However, here is where the first problem sets in.</p>
<p>Effect systems model interpretations of effects as functions. For example, lets’ assume we have a <code>State s</code> effect to play with. We can give an interpretation of it with the type:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="ot">runState ::</span> s <span class="ot">-&gt;</span> <span class="dt">Eff</span> (<span class="dt">State</span> s &#39;<span class="fu">:</span> r) a <span class="ot">-&gt;</span> <span class="dt">Eff</span> r (s, a)</a></code></pre></div>
<p>In the first-order world, you can just have <code>runState</code> walk through every action in <code>Eff</code>, and handle the <code>State s</code> ones. In the higher-order world, however, we <em>also</em> need to run <code>runState</code> on all of the <em>embedded</em> computations (like <code>Catch</code>) as well — and then somehow merge the resulting side states back into the main thread.</p>
<p>Recall above that we tied the recursive knot on <code>catch</code>, so that the <code>m</code> in <code>Error e m</code> was always equal to the actual <code>Eff</code> monad its being run in. By calling <code>runState</code>, we’re promising that that <code>m</code> is of the form <code>Eff (State s ': r)</code>. But now we’re eliminating the <code>State s</code> effect, <em>and we want to maintain the invariant that <code>m</code> is the same monad.</em> Which means, we need to somehow use <code>runState</code> to eliminate the <code>State s</code> <em>inside of</em> <code>Catch</code>.</p>
<p>It makes my head spin, too. English is not particularly good at describing these kinds of things, so pay attention to the types here:</p>
<ol type="1">
<li>We called <code>catch :: Eff r a -&gt; (e -&gt; Eff r0 a) -&gt; Eff r0 a</code> somewhere in our application code</li>
<li>We then interpret the application via <code>runState :: s -&gt; Eff (State s ': r1) a -&gt; Eff r1 (s, a)</code></li>
<li>As such, we learn that <code>r0 ~ (State s ': r1)</code></li>
<li>After calling <code>runState</code>, we are left only with <code>r1</code> in our effect stack.</li>
<li>But <code>catch</code> still contains <code>r0</code>. We need to transform it into <code>r1</code> to maintain our invariant that the computations embedded <em>inside</em> <code>catch</code> are in same monad as the call <em>to</em> <code>catch</code>.</li>
</ol>
<p>Doing such a thing is going to require a function:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1">call&#39;runState&#39;InsideError</a>
<a class="sourceLine" id="cb9-2" title="2"><span class="ot">    ::</span> s</a>
<a class="sourceLine" id="cb9-3" title="3">    <span class="ot">-&gt;</span> <span class="dt">Error</span> (<span class="dt">Eff</span> (<span class="dt">State</span> s &#39;<span class="fu">:</span> r)) a</a>
<a class="sourceLine" id="cb9-4" title="4">    <span class="ot">-&gt;</span> <span class="dt">Error</span> (<span class="dt">Eff</span> r) (s, a)</a></code></pre></div>
<p>which for reasons that will become clearer later, we will uncurry into:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1">call&#39;runState&#39;InsideError</a>
<a class="sourceLine" id="cb10-2" title="2"><span class="ot">    ::</span> (s, <span class="dt">Error</span> (<span class="dt">Eff</span> (<span class="dt">State</span> s &#39;<span class="fu">:</span> r)) a)</a>
<a class="sourceLine" id="cb10-3" title="3">    <span class="ot">-&gt;</span> <span class="dt">Error</span> (<span class="dt">Eff</span> r) (s, a)</a></code></pre></div>
<p>The implementation of this function is guided by the types, and looks like this:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1">call&#39;runState&#39;InsideError</a>
<a class="sourceLine" id="cb11-2" title="2"><span class="ot">    ::</span> (s, <span class="dt">Error</span> (<span class="dt">Eff</span> (<span class="dt">State</span> s &#39;<span class="fu">:</span> r)) a)</a>
<a class="sourceLine" id="cb11-3" title="3">    <span class="ot">-&gt;</span> <span class="dt">Error</span> (<span class="dt">Eff</span> r) (s, a)</a>
<a class="sourceLine" id="cb11-4" title="4">call&#39;runState&#39;InsideError (_, <span class="dt">Throw</span> e) <span class="fu">=</span> <span class="dt">Throw</span> e</a>
<a class="sourceLine" id="cb11-5" title="5">call&#39;runState&#39;InsideError (s, <span class="dt">Catch</span> ma f) <span class="fu">=</span></a>
<a class="sourceLine" id="cb11-6" title="6">  <span class="dt">Catch</span> (runState s ma)</a>
<a class="sourceLine" id="cb11-7" title="7">        (\e <span class="ot">-&gt;</span> runState s <span class="fu">$</span> f e)</a></code></pre></div>
<p>Such an example is helpful for building intuition, but is completely infeasible in the real world. Not only do we need one of these functions for every effect inside of our stack, but we also need one for every interpretation of every effect in our stack! This is <code>O(m*n)</code> functions in the number of effects and interpretations we have.</p>
<p>The insight of Wu et al. is that we can get this down to <code>O(n)</code> — one function analogous to <code>call'runState'InsideError</code> for each effect. Let’s go through the derivation together.</p>
<p>The first thing to notice is that we don’t need to hard-code <code>runState</code> in <code>call'runState'InsideError'</code>. It’s fine to just pass it in as a parameter:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1">elimStateInsideError</a>
<a class="sourceLine" id="cb12-2" title="2"><span class="ot">    ::</span> (<span class="kw">forall</span> x<span class="fu">.</span> (s, <span class="dt">Eff</span> (<span class="dt">State</span> s &#39;<span class="fu">:</span> r) x) <span class="ot">-&gt;</span> <span class="dt">Eff</span> r (s, x))</a>
<a class="sourceLine" id="cb12-3" title="3">    <span class="ot">-&gt;</span> (s, <span class="dt">Error</span> (<span class="dt">Eff</span> (<span class="dt">State</span> s &#39;<span class="fu">:</span> r)) a)</a>
<a class="sourceLine" id="cb12-4" title="4">    <span class="ot">-&gt;</span> <span class="dt">Error</span> (<span class="dt">Eff</span> r) (s, a)</a>
<a class="sourceLine" id="cb12-5" title="5">elimStateInsideError _ (_, <span class="dt">Throw</span> e) <span class="fu">=</span> <span class="dt">Throw</span> e</a>
<a class="sourceLine" id="cb12-6" title="6">elimStateInsideError elimState (s, <span class="dt">Catch</span> ma f) <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-7" title="7">  <span class="dt">Catch</span> (elimState (s, ma))</a>
<a class="sourceLine" id="cb12-8" title="8">        (\e <span class="ot">-&gt;</span> elimState (s, f e))</a></code></pre></div>
<p>Note that the <code>elimState</code> function must be rank-2 so that we can use it on every instance of <code>Catch</code> — there’s no guarantee that they’ll all be called to produce the same type.</p>
<p>The next step is to notice that there’s a homomorphism here; we transforming a <code>(s, m a)</code> into <code>m' (s, a)</code>, by somehow pushing the <code>(,) s</code> bit through the monad. We can make that a little more clear by explicitly factoring it out:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1">elimStateInsideError</a>
<a class="sourceLine" id="cb13-2" title="2"><span class="ot">    ::</span> (f <span class="fu">~</span> ((,) s))</a>
<a class="sourceLine" id="cb13-3" title="3">    <span class="ot">=&gt;</span> (<span class="kw">forall</span> x<span class="fu">.</span> f (<span class="dt">Eff</span> (<span class="dt">State</span> s &#39;<span class="fu">:</span> r) x) <span class="ot">-&gt;</span> <span class="dt">Eff</span> r (f x))</a>
<a class="sourceLine" id="cb13-4" title="4">    <span class="ot">-&gt;</span> f (<span class="dt">Error</span> (<span class="dt">Eff</span> (<span class="dt">State</span> s &#39;<span class="fu">:</span> r)) a)</a>
<a class="sourceLine" id="cb13-5" title="5">    <span class="ot">-&gt;</span> <span class="dt">Error</span> (<span class="dt">Eff</span> r) (f a)</a></code></pre></div>
<p>This type is identical to before, we’ve just renamed <code>(,) s</code> to <code>f</code>. Let’s do the same renaming trick on <code>Eff (State s ': r)</code>:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1">elimStateInsideError</a>
<a class="sourceLine" id="cb14-2" title="2"><span class="ot">    ::</span> ( f <span class="fu">~</span> ((,) s)</a>
<a class="sourceLine" id="cb14-3" title="3">       , m <span class="fu">~</span> <span class="dt">Eff</span> (<span class="dt">State</span> s &#39;<span class="fu">:</span> r)</a>
<a class="sourceLine" id="cb14-4" title="4">       )</a>
<a class="sourceLine" id="cb14-5" title="5">    <span class="ot">=&gt;</span> (<span class="kw">forall</span> x<span class="fu">.</span> f (m x) <span class="ot">-&gt;</span> <span class="dt">Eff</span> r (f x))</a>
<a class="sourceLine" id="cb14-6" title="6">    <span class="ot">-&gt;</span> f (<span class="dt">Error</span> m a)</a>
<a class="sourceLine" id="cb14-7" title="7">    <span class="ot">-&gt;</span> <span class="dt">Error</span> (<span class="dt">Eff</span> r) (f a)</a></code></pre></div>
<p>and then <em>again</em> on <code>Eff r</code>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1">elimStateInsideError</a>
<a class="sourceLine" id="cb15-2" title="2"><span class="ot">    ::</span> ( f <span class="fu">~</span> ((,) s)</a>
<a class="sourceLine" id="cb15-3" title="3">       , m <span class="fu">~</span> <span class="dt">Eff</span> (<span class="dt">State</span> s &#39;<span class="fu">:</span> r)</a>
<a class="sourceLine" id="cb15-4" title="4">       , n <span class="fu">~</span> <span class="dt">Eff</span> r</a>
<a class="sourceLine" id="cb15-5" title="5">       )</a>
<a class="sourceLine" id="cb15-6" title="6">    <span class="ot">=&gt;</span> (<span class="kw">forall</span> x<span class="fu">.</span> f (m x) <span class="ot">-&gt;</span> n (f x))</a>
<a class="sourceLine" id="cb15-7" title="7">    <span class="ot">-&gt;</span> f (<span class="dt">Error</span> m a)</a>
<a class="sourceLine" id="cb15-8" title="8">    <span class="ot">-&gt;</span> <span class="dt">Error</span> n (f a)</a></code></pre></div>
<p>As it stands, our current implementation of <code>elimStateInsideError</code> will actually work for any <code>m</code> and <code>n</code>; so we can just get rid of those renames:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1">elimEffectInsideError</a>
<a class="sourceLine" id="cb16-2" title="2"><span class="ot">    ::</span> (f <span class="fu">~</span> ((,) s))</a>
<a class="sourceLine" id="cb16-3" title="3">    <span class="ot">=&gt;</span> (<span class="kw">forall</span> x<span class="fu">.</span> f (m x) <span class="ot">-&gt;</span> n (f x))</a>
<a class="sourceLine" id="cb16-4" title="4">    <span class="ot">-&gt;</span> f (<span class="dt">Error</span> m a)</a>
<a class="sourceLine" id="cb16-5" title="5">    <span class="ot">-&gt;</span> <span class="dt">Error</span> n (f a)</a>
<a class="sourceLine" id="cb16-6" title="6">elimEffectInsideError _ (_, <span class="dt">Throw</span> e) <span class="fu">=</span> <span class="dt">Throw</span> e</a>
<a class="sourceLine" id="cb16-7" title="7">elimEffectInsideError elim (s, <span class="dt">Catch</span> ma f) <span class="fu">=</span></a>
<a class="sourceLine" id="cb16-8" title="8">  <span class="dt">Catch</span> (elim (s, ma))</a>
<a class="sourceLine" id="cb16-9" title="9">        (\e <span class="ot">-&gt;</span> elim (s, f e))</a></code></pre></div>
<p>Let’s now <em>undo</em> our uncurrying of our <code>s -&gt; Error m a -&gt; ...</code> as <code>(s, Error m a) -&gt; ...</code>. But since we’ve renamed <code>s</code> away, we’re not allowed to reference it anymore. Instead, we can use <code>f ()</code>, aka <code>(s, ())</code>, which you’ll notice is isomorphic to <code>s</code>.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1">elimEffectInsideError</a>
<a class="sourceLine" id="cb17-2" title="2"><span class="ot">    ::</span> (f <span class="fu">~</span> ((,) s))</a>
<a class="sourceLine" id="cb17-3" title="3">    <span class="ot">=&gt;</span> (<span class="kw">forall</span> x<span class="fu">.</span> f (m x) <span class="ot">-&gt;</span> n (f x))</a>
<a class="sourceLine" id="cb17-4" title="4">    <span class="ot">-&gt;</span> f ()</a>
<a class="sourceLine" id="cb17-5" title="5">    <span class="ot">-&gt;</span> <span class="dt">Error</span> m a</a>
<a class="sourceLine" id="cb17-6" title="6">    <span class="ot">-&gt;</span> <span class="dt">Error</span> n (f a)</a>
<a class="sourceLine" id="cb17-7" title="7">elimEffectInsideError _ _ <span class="dt">Throw</span> e <span class="fu">=</span> <span class="dt">Throw</span> e</a>
<a class="sourceLine" id="cb17-8" title="8">elimEffectInsideError elim (s, ()) (<span class="dt">Catch</span> ma f) <span class="fu">=</span></a>
<a class="sourceLine" id="cb17-9" title="9">  <span class="dt">Catch</span> (elim (s, ma))</a>
<a class="sourceLine" id="cb17-10" title="10">        (\e <span class="ot">-&gt;</span> elim (s, f e))</a></code></pre></div>
<p>As one last step, we can rewrite the explicit destructuring of the <code>f ()</code> parameter using its functor instance. Given the ice-cream cone function <code>(&lt;$) :: Functor f =&gt; a -&gt; f b -&gt; f a</code>, which replaces the contents of a functor, we can rewrite <code>elimEffectInsideError</code> as follows:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" title="1">elimEffectInsideError</a>
<a class="sourceLine" id="cb18-2" title="2"><span class="ot">    ::</span> (f <span class="fu">~</span> ((,) s))</a>
<a class="sourceLine" id="cb18-3" title="3">    <span class="ot">=&gt;</span> (<span class="kw">forall</span> x<span class="fu">.</span> f (m x) <span class="ot">-&gt;</span> n (f x))</a>
<a class="sourceLine" id="cb18-4" title="4">    <span class="ot">-&gt;</span> f ()</a>
<a class="sourceLine" id="cb18-5" title="5">    <span class="ot">-&gt;</span> <span class="dt">Error</span> m a</a>
<a class="sourceLine" id="cb18-6" title="6">    <span class="ot">-&gt;</span> <span class="dt">Error</span> n (f a)</a>
<a class="sourceLine" id="cb18-7" title="7">elimEffectInsideError _ _ <span class="dt">Throw</span> e <span class="fu">=</span> <span class="dt">Throw</span> e</a>
<a class="sourceLine" id="cb18-8" title="8">elimEffectInsideError elim s (<span class="dt">Catch</span> ma f) <span class="fu">=</span></a>
<a class="sourceLine" id="cb18-9" title="9">  <span class="dt">Catch</span> (elim <span class="fu">$</span> ma <span class="fu">&lt;$</span> s)</a>
<a class="sourceLine" id="cb18-10" title="10">        (\e <span class="ot">-&gt;</span> elim <span class="fu">$</span> f e <span class="fu">&lt;$</span> s)</a></code></pre></div>
<p>and in doing so, are now fully functor-agnostic, so we can get rid of the <code>f</code>-renaming now:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb19-1" title="1">elimEffectInsideError</a>
<a class="sourceLine" id="cb19-2" title="2"><span class="ot">    ::</span> <span class="dt">Functor</span> f</a>
<a class="sourceLine" id="cb19-3" title="3">    <span class="ot">=&gt;</span> (<span class="kw">forall</span> x<span class="fu">.</span> f (m x) <span class="ot">-&gt;</span> n (f x))</a>
<a class="sourceLine" id="cb19-4" title="4">    <span class="ot">-&gt;</span> f ()</a>
<a class="sourceLine" id="cb19-5" title="5">    <span class="ot">-&gt;</span> <span class="dt">Error</span> m a</a>
<a class="sourceLine" id="cb19-6" title="6">    <span class="ot">-&gt;</span> <span class="dt">Error</span> n (f a)</a></code></pre></div>
<p>That was a lot of work! But we’ve bought ourselves a huge amount with this. Now <code>elimEffectInsideError</code> is general enough that it supports eliminating <em>any</em> effect inside of <code>Error</code>. The last step is to wrap this thing up into a typeclass, which Wu et al. call <code>weave</code>:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb20-1" title="1"><span class="kw">class</span> (<span class="ot">∀</span> m<span class="fu">.</span> <span class="dt">Functor</span> m <span class="ot">=&gt;</span> <span class="dt">Functor</span> (e m)) <span class="ot">=&gt;</span> <span class="dt">Effect</span> e <span class="kw">where</span></a>
<a class="sourceLine" id="cb20-2" title="2">  weave</a>
<a class="sourceLine" id="cb20-3" title="3"><span class="ot">      ::</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> m, <span class="dt">Functor</span> n)</a>
<a class="sourceLine" id="cb20-4" title="4">      <span class="ot">=&gt;</span> f ()</a>
<a class="sourceLine" id="cb20-5" title="5">      <span class="ot">-&gt;</span> (<span class="ot">∀</span> x<span class="fu">.</span> f (m x) <span class="ot">-&gt;</span> n (f x))</a>
<a class="sourceLine" id="cb20-6" title="6">      <span class="ot">-&gt;</span> e m a</a>
<a class="sourceLine" id="cb20-7" title="7">      <span class="ot">-&gt;</span> e n (f a)</a></code></pre></div>
<p>Don’t worry about the extra mentions of <code>Functor</code> in this definition; they’re there for reasons we don’t care about today.</p>
<p>By giving an instance of <code>Effect</code> for <code>e</code>, we can now thread any other effects <em>through</em> <code>e</code>. If we give an instance of <code>Effect</code> for every effect, we get higher-order effects that can be run through one another in any order. Happy days!</p>
<p>This <code>weave</code> transformation is the major contribution of Effect Handlers in Scope. And while it does indeed solve the problem of higher-order effects, such a thing brings with it a lot of boilerplate; we need to write an instance of <code>Effect</code> for each of our effects, which is non-trivial and can’t be automated via today’s support for generics.</p>
<h2 id="free-effects">Free Effects</h2>
<p>Back in the bad old days of <a href="http://hackage.haskell.org/package/free"><code>free</code></a>, we would have had to model the first-order version of <code>Error e</code> above (the one that just has <code>Throw</code>) as follows:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb21-1" title="1"><span class="kw">data</span> <span class="dt">Error</span> e a <span class="fu">=</span> <span class="kw">forall</span> x<span class="fu">.</span> <span class="dt">Throw</span> (x <span class="ot">-&gt;</span> a)</a></code></pre></div>
<p>while <code>State s</code> would look like this:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb22-1" title="1"><span class="kw">data</span> <span class="dt">State</span> s a</a>
<a class="sourceLine" id="cb22-2" title="2">  <span class="fu">=</span> <span class="dt">Get</span> (s <span class="ot">-&gt;</span> a)</a>
<a class="sourceLine" id="cb22-3" title="3">  <span class="fu">|</span> <span class="dt">Put</span> s (() <span class="ot">-&gt;</span> a)</a></code></pre></div>
<p>It’s gross, <em>and</em> you’d need to give <code>Functor</code> instances for both. <em>AND</em> you can’t even derive <code>Functor</code> for <code>Error e</code> due to the existential.</p>
<p>The specifics here aren’t very important, but the point is that this was a bunch of boilerplate that got in the way of doing any work. The main contribution of Kiselyov and Ishii’s paper <a href="https://okmij.org/ftp/Haskell/extensible/more.pdf">Freer Monads, More Extensible Effects</a> is that we can use a <em>free functor</em> to automate away this boilerplate. The result is what puts the “simple” in <code>freer-simple</code><a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>.</p>
<p>The free functor is called <a href="https://www.stackage.org/haddock/lts-13.23/kan-extensions-5.2/Data-Functor-Coyoneda.html"><code>Coyoneda</code></a><a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>, and it looks like this:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb23-1" title="1"><span class="kw">data</span> <span class="dt">Coyoneda</span> f b <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-2" title="2">  <span class="dt">Coyoneda</span><span class="ot"> ::</span> f a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Coyoneda</span> f b</a>
<a class="sourceLine" id="cb23-3" title="3"></a>
<a class="sourceLine" id="cb23-4" title="4"><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Coyoneda</span> f) <span class="kw">where</span></a>
<a class="sourceLine" id="cb23-5" title="5">  <span class="fu">fmap</span> f&#39; (<span class="dt">Coyoneda</span> fa f) <span class="fu">=</span> <span class="dt">Coyoneda</span> fa (f&#39; <span class="fu">.</span> f)</a></code></pre></div>
<p>As you can see, <code>Coyoneda f</code> is a <code>Functor</code>, <em>even when <code>f</code> itself isn’t.</em> <code>Coyoneda</code> just accumulates all of the <code>fmap</code>s you wanted to do, and you can choose later what to do with the resulting function.</p>
<p>This got me to thinking. Maybe there’s a free <code>Effect</code> that can likewise accumulate all of the <code>weave</code>ing we’d like to do, so that library users don’t need to write those instances themselves.</p>
<p>The “trick” to making a free construction is to just make a datatype that stores each parameter to the characteristic function. In the <code>Functor</code> example, you’ll notice a similarity between the types of (flipped) <code>fmap</code> and <code>Coyoneda</code>:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb24-1" title="1"><span class="fu">flip</span><span class="ot"> fmap ::</span> f a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> f b</a>
<a class="sourceLine" id="cb24-2" title="2"><span class="dt">Coyoneda</span><span class="ot">  ::</span> f a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> <span class="dt">Coyoneda</span> f b</a></code></pre></div>
<p>So let’s do the same thing, for <code>weave</code>, and construct an equivalent datatype. Recall the type of <code>weave</code>:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb25-1" title="1">weave</a>
<a class="sourceLine" id="cb25-2" title="2"><span class="ot">    ::</span> (<span class="dt">Functor</span> f, <span class="dt">Functor</span> m, <span class="dt">Functor</span> n)</a>
<a class="sourceLine" id="cb25-3" title="3">    <span class="ot">=&gt;</span> f ()</a>
<a class="sourceLine" id="cb25-4" title="4">    <span class="ot">-&gt;</span> (<span class="ot">∀</span> x<span class="fu">.</span> f (m x) <span class="ot">-&gt;</span> n (f x))</a>
<a class="sourceLine" id="cb25-5" title="5">    <span class="ot">-&gt;</span> e m a</a>
<a class="sourceLine" id="cb25-6" title="6">    <span class="ot">-&gt;</span> e n (f a)</a></code></pre></div>
<p>As a first attempt, let’s just turn this thing into a GADT and see what happens. I called it <code>Yo</code> a little because it’s sorta like <code>Coyoneda</code>, but mostly because naming things is hard.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb26-1" title="1"><span class="kw">data</span> <span class="dt">Yo</span> e m a <span class="kw">where</span></a>
<a class="sourceLine" id="cb26-2" title="2">  <span class="dt">Yo</span><span class="ot"> ::</span> <span class="dt">Functor</span> f</a>
<a class="sourceLine" id="cb26-3" title="3">     <span class="ot">=&gt;</span> e m a</a>
<a class="sourceLine" id="cb26-4" title="4">     <span class="ot">-&gt;</span> f ()</a>
<a class="sourceLine" id="cb26-5" title="5">     <span class="ot">-&gt;</span> (<span class="kw">forall</span> x<span class="fu">.</span> f (m x) <span class="ot">-&gt;</span> n (f x))</a>
<a class="sourceLine" id="cb26-6" title="6">     <span class="ot">-&gt;</span> <span class="dt">Yo</span> e n (f a)</a></code></pre></div>
<p>While this looks right, it turns out to be a no-go. We can’t actually give an instance of <code>Effect</code> for <code>Yo e</code>. We can get close, by realizing that the composition of any two functors is also a functor (given via the <code>Compose</code> newtype). With that in mind, it’s just a little work to make all of the types line up:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb27-1" title="1"><span class="kw">instance</span> <span class="dt">Effect</span> (<span class="dt">Yo</span> e) <span class="kw">where</span></a>
<a class="sourceLine" id="cb27-2" title="2">  weave s&#39; elim&#39; (<span class="dt">Yo</span> e s elim) <span class="fu">=</span></a>
<a class="sourceLine" id="cb27-3" title="3">    <span class="dt">Yo</span> e (<span class="dt">Compose</span> <span class="fu">$</span> s <span class="fu">&lt;$</span> s&#39;)</a>
<a class="sourceLine" id="cb27-4" title="4">         (<span class="fu">fmap</span> <span class="dt">Compose</span> <span class="fu">.</span> elim&#39; <span class="fu">.</span> <span class="fu">fmap</span> elim <span class="fu">.</span> getCompose)</a></code></pre></div>
<p>Unfortunately, this definition doesn’t quite work. The problem is that <code>weave s elim</code> is supposed to result in a <code>e m a -&gt; e n (f a)</code>, but ours has type <code>e m (g a) -&gt; e n (Compose f g a)</code>! By hard-coding that <code>f</code> into the result of our GADT, we’ve painted ourselves into a corner. Similar problems would crop up if we wanted to give a <code>Functor</code> instance to <code>Yo e m</code>.</p>
<p>As is so often the case in this line of work, the solution is to make <code>f</code> existential, and to take another function which is responsible for producing the desired type. We add a <code>(f a -&gt; b)</code> parameter to <code>Yo</code>, and make it return <code>Yo e n b</code>:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb28-1" title="1"><span class="kw">data</span> <span class="dt">Yo</span> e m a <span class="kw">where</span></a>
<a class="sourceLine" id="cb28-2" title="2">  <span class="dt">Yo</span><span class="ot"> ::</span> <span class="dt">Functor</span> f</a>
<a class="sourceLine" id="cb28-3" title="3">     <span class="ot">=&gt;</span> e m a</a>
<a class="sourceLine" id="cb28-4" title="4">     <span class="ot">-&gt;</span> f ()</a>
<a class="sourceLine" id="cb28-5" title="5">     <span class="ot">-&gt;</span> (<span class="kw">forall</span> x<span class="fu">.</span> f (m x) <span class="ot">-&gt;</span> n (f x))</a>
<a class="sourceLine" id="cb28-6" title="6">     <span class="ot">-&gt;</span> (f a <span class="ot">-&gt;</span> b)</a>
<a class="sourceLine" id="cb28-7" title="7">     <span class="ot">-&gt;</span> <span class="dt">Yo</span> e n b</a></code></pre></div>
<p>We can now call <code>getCompose</code> in this last function — in order to undo our trick of packing the two pieces of state together.</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb29-1" title="1"><span class="kw">instance</span> <span class="dt">Effect</span> (<span class="dt">Yo</span> e) <span class="kw">where</span></a>
<a class="sourceLine" id="cb29-2" title="2">  weave s&#39; elim&#39; (<span class="dt">Yo</span> e s elim f) <span class="fu">=</span></a>
<a class="sourceLine" id="cb29-3" title="3">    <span class="dt">Yo</span> e (<span class="dt">Compose</span> <span class="fu">$</span> s <span class="fu">&lt;$</span> s&#39;)</a>
<a class="sourceLine" id="cb29-4" title="4">         (<span class="fu">fmap</span> <span class="dt">Compose</span> <span class="fu">.</span> elim&#39; <span class="fu">.</span> <span class="fu">fmap</span> elim <span class="fu">.</span> getCompose)</a>
<a class="sourceLine" id="cb29-5" title="5">         (<span class="fu">fmap</span> f <span class="fu">.</span> getCompose)</a></code></pre></div>
<p>Giving an instance of <code>Functor (Yo e m)</code> can also riff on this final parameter, exactly in the same way that <code>Coyoneda</code> did:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb30-1" title="1"><span class="kw">instance</span> <span class="dt">Functor</span> (<span class="dt">Yo</span> e m) <span class="kw">where</span></a>
<a class="sourceLine" id="cb30-2" title="2">  <span class="fu">fmap</span> f&#39; (<span class="dt">Yo</span> e s elim f) <span class="fu">=</span> <span class="dt">Yo</span> e s elim (f&#39; <span class="fu">.</span> f)</a></code></pre></div>
<p>(The real implementation also needs <code>hoist :: (forall x. m x -&gt; n x) -&gt; e m a -&gt; e n a</code>, which turns out to be a special case of <code>weave</code>. This is left as an exercise for the ambitious reader.)</p>
<p>All that’s left is be able to lift <code>e m a</code>s into <code>Yo e m a</code>s. In every free construction I’ve ever seen, this operation is to just fill all of your parameters with identity — and this case is no different!</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb31-1" title="1"><span class="ot">liftYo ::</span> <span class="dt">Functor</span> m <span class="ot">=&gt;</span> e m a <span class="ot">-&gt;</span> <span class="dt">Yo</span> e m a</a>
<a class="sourceLine" id="cb31-2" title="2">liftYo e <span class="fu">=</span> <span class="dt">Yo</span> e (<span class="dt">Identity</span> ()) (<span class="fu">fmap</span> <span class="dt">Identity</span> <span class="fu">.</span> runIdentity) runIdentity</a></code></pre></div>
<p>We’re done! This funny <code>Yo</code> construction is powerful enough to coalesce entire chains of effect interpreters into a single call. We haven’t done anything magical here — someone still needs to figure out what these functions actually mean for their interpretation. By collecting it all into a single place, we can cut down on boilerplate and find easier ways to express these concepts to the end-user.</p>
<p>But that’s a tale for another time, when we talk about <code>polysemy</code>’s <code>Tactics</code> machinery.</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Plus, it provides better combinators and more helpful error messages.<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>For further discussion of <code>Coyoneda</code> and how it can help performance, perhaps you might be interested in <a href="https://thinkingwithtypes.com/">my book</a>.<a href="#fnref2" class="footnote-back">↩</a></p></li>
</ol>
</section>
        ]]>
      </content>
    </entry>
    <entry>
      <title>Faking Fundeps with Typechecker Plugins</title>
      <id>blog/faking-fundeps/index.html</id>
      <link href='blog/faking-fundeps/index.html'/>
      <published>2019-05-25T02:17:00Z</published>
      <updated>2019-05-25T02:17:00Z</updated>

      <content type="html">
        <![CDATA[
        <blockquote>
<p>The approach here, and my original implementation are both lifted almost entirely from <a href="https://github.com/LukaHorvat">Luka Horvat</a>’s <a href="https://gitlab.com/LukaHorvat/simple-effects/commit/966ce80b8b5777a4bd8f87ffd443f5fa80cc8845#f51c1641c95dfaa4827f641013f8017e8cd02aab">plugin for <code>simple-effects</code></a>. All praise should be directed to him.</p>
</blockquote>
<hr />
<p><a href="/blog/writing-custom-optimizations/">Last time</a> we chatted about using a GHC plugin to run custom Core-to-Core transformations on the programs that GHC is compiling. Doing so allows us to add custom optimization passes, and even other, more <em>exotic</em> things like <a href="https://github.com/conal/concat">rewriting lambda expression as categorical operations</a>.</p>
<p>Today I want to talk about another sort of GHC plugin: <em>type-checker plugins!</em> TC plugins let you hook into GHC’s constraint machinery and help it solve domain-specific problems that it wouldn’t be able to otherwise. One of the more interesting examples of a TC plugin is <a href="https://www.joachim-breitner.de/blog">nomeata’s</a> <a href="http://hackage.haskell.org/package/ghc-justdoit">ghc-justdoit</a> — which will automatically generate a value of the correct type, essentially letting you leave implementations as “exercises for the compiler.”</p>
<p><a href="https://github.com/isovector/polysemy/">Polysemy</a> uses a TC plugin in order to improve type-inference. The result is that it can provide type-inference that is as good as <code>mtl</code>’s, without succumbing to the pitfalls that accompany <code>mtl</code>’s approach.</p>
<h2 id="the-problem">The Problem</h2>
<p>Consider the following program:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="ot">foo ::</span> <span class="dt">MonadState</span> <span class="dt">Int</span> m <span class="ot">=&gt;</span> m ()</a>
<a class="sourceLine" id="cb1-2" title="2">foo <span class="fu">=</span> modify (<span class="fu">+</span> <span class="dv">1</span>)</a></code></pre></div>
<p>Such a thing compiles and runs no problem. There are no surprises here for any Haskell programmers who have ever run into <code>mtl</code>. But the reason it works is actually quite subtle. If we look at the type of <code>modify</code> we see:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="ot">modify ::</span> <span class="dt">MonadState</span> s m <span class="ot">=&gt;</span> (s <span class="ot">-&gt;</span> s) <span class="ot">-&gt;</span> m ()</a></code></pre></div>
<p>which suggests that the <code>s -&gt; s</code> function we pass to it should determine the <code>s</code> parameter. But our function <code>(+ 1)</code> has type <code>Num a =&gt; a -&gt; a</code>, therefore the type of <code>modify (+1)</code> should be this:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1">modify (<span class="fu">+</span> <span class="dv">1</span>)<span class="ot"> ::</span> (<span class="dt">MonadState</span> s m, <span class="dt">Num</span> s) <span class="ot">=&gt;</span> m ()</a></code></pre></div>
<p>So the question is, why the heck is GHC willing to use a <code>MonadState Int m</code> constraint to solve the wanted <code>(MonadState s m, Num s)</code> constraint arising from a use of <code>modify (+1)</code>? The problem feels analogous to this one, which <em>doesn’t work:</em></p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="ot">bar ::</span> <span class="dt">Show</span> <span class="dt">Bool</span> <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span></a>
<a class="sourceLine" id="cb4-2" title="2">bar b <span class="fu">=</span> <span class="fu">show</span> b  <span class="co">-- doesn&#39;t work</span></a></code></pre></div>
<p>Just because we have a <code>Show Bool</code> constraint in scope <em>doesn’t mean that <code>a</code> is a <code>Bool</code>!</em> So how come we’re allowed to use our <code>MonadState Int m</code> constraint, to solve a <code>(MonadState s m, Num s)</code>? Completely analogously, <em>we don’t know that <code>s</code> is an <code>Int</code>!</em></p>
<p>The solution to this puzzler is in the definition of <code>MondState</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">class</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">MonadState</span> s (<span class="ot">m ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="fu">|</span> m <span class="ot">-&gt;</span> s <span class="kw">where</span></a></code></pre></div>
<p>Notice this <code>| m -&gt; s</code> bit, which is known as a <em>functional dependency</em> or a <em>fundep</em> for short. The fundep says “if you know <code>m</code>, you also know <code>s</code>,” or equivalently, “<code>s</code> is completely determined by <code>m</code>.” And so, when typechecking <code>foo</code>, GHC is asked to solve both <code>MonadState Int m</code> and <code>(Num s, MonadState s m)</code>. But since there can only be a <em>single instance</em> of <code>MonadState</code> for m, this means that <code>MonadState Int m</code> and <code>MonadState s m</code> <em>must be the same</em>. Therefore <code>s ~ Int</code>.</p>
<p>This is an elegant solution, but it comes at a cost — namely that we’re only allowed to use a single <code>MonadState</code> at a time! If you’re a longtime Haskell programmer, this probably doesn’t feel like a limitation to you; just stick all the pieces of state you want into a single type, and then use some classy fields to access them, right? <a href="https://www.parsonsmatt.org/">Matt Parsons</a> has <a href="https://www.parsonsmatt.org/2018/11/03/trouble_with_typed_errors.html">a blog post</a> on the pain points, and some bandages, for doing this with typed errors. At the end of the day, the real problem is that we’re only allowed a single <code>MonadError</code> constraint.</p>
<p>Polysemy “fixes the glitch” by just not using fundeps. This means you’re completely free to use as many state, error, and whatever effects you want all at the same time. The downside? Type-inference sucks again. Indeed, the equivalent program to <code>foo</code> in <code>polysemy</code> doesn’t compile by default:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="ot">foo&#39; ::</span> <span class="dt">Member</span> (<span class="dt">State</span> <span class="dt">Int</span>) r <span class="ot">=&gt;</span> <span class="dt">Sem</span> r ()</a>
<a class="sourceLine" id="cb6-2" title="2">foo&#39; <span class="fu">=</span> modify (<span class="fu">+</span> <span class="dv">1</span>)</a></code></pre></div>
<pre><code>• Ambiguous use of effect &#39;State&#39;
  Possible fix:
    add (Member (State s0) r) to the context of
      the type signature
  If you already have the constraint you want, instead
    add a type application to specify
      &#39;s0&#39; directly, or activate polysemy-plugin which
        can usually infer the type correctly.
• In the expression: modify (+ 1)
  In an equation for ‘foo&#39;’: foo&#39; = modify (+ 1)</code></pre>
<p>This situation blows chunks. It’s obvious what this program should do, so let’s just fix it.</p>
<h2 id="the-solution">The Solution</h2>
<p>Let’s forget about the compiler for a second and ask ourselves how the Human Brain Typechecker(TM) would type-check this problem. Given the program:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="ot">foo&#39; ::</span> <span class="dt">Member</span> (<span class="dt">State</span> <span class="dt">Int</span>) r <span class="ot">=&gt;</span> <span class="dt">Sem</span> r ()</a>
<a class="sourceLine" id="cb8-2" title="2">foo&#39; <span class="fu">=</span> modify (<span class="fu">+</span> <span class="dv">1</span>)</a></code></pre></div>
<p>A human would look at the <code>modify</code> here, and probably run an algorithm similar to this:</p>
<ul>
<li>Okay, what <code>State</code> is <code>modify</code> running over here?</li>
<li>Well, it’s some sort of <code>Num</code>.</li>
<li>Oh, look, there’s a <code>Member (State Int) r</code> constraint in scope.</li>
<li>That thing wouldn’t be there if it wasn’t necessary.</li>
<li>I guess <code>modify</code> is running over <code>State Int</code>.</li>
</ul>
<p>Pretty great algorithm! Instead, here’s what GHC does:</p>
<ul>
<li>Okay, what <code>State</code> is <code>modify</code> running over here?</li>
<li>Well, it’s some sort of <code>Num</code>.</li>
<li>But that thing is polymorphic.</li>
<li>Guess I’ll emit a <code>(Num n, Member (State n) r)</code> constraint.</li>
<li>Why did the stupid human put an unnecessary <code>Member (State Int) r</code> constraint here?</li>
<li>What an idiot!</li>
</ul>
<p>And then worse, it won’t compile because the generated <code>n</code> type is now ambiguous and not mentioned anywhere in the type signature!</p>
<p>Instead, let’s use a TC plugin to make GHC reason more like a human when it comes to <code>Member</code> constraints. In particular, we’re going to mock the fundep lookup algorithm:</p>
<ul>
<li>Whenever GHC is trying to solve a <code>Member (effect a) r</code> constraint</li>
<li>And there is <em>exactly one</em> constraint in scope of the form <code>Member (effect b) r</code></li>
<li>Then emit a <code>a ~ b</code> constraint, allowing GHC to use the given <code>Member (effect b) r</code> constraint to solve the wanted <code>Member (effect a) r</code></li>
</ul>
<h2 id="tc-plugins">TC Plugins</h2>
<p>At its heart, a TC plugin is a value of type <code>TcPlugin</code>, a record of three methods:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">data</span> <span class="dt">TcPlugin</span> <span class="fu">=</span> <span class="kw">forall</span> s<span class="fu">.</span> <span class="dt">TcPlugin</span></a>
<a class="sourceLine" id="cb9-2" title="2">  {<span class="ot"> tcPluginInit  ::</span> <span class="dt">TcPluginM</span> s</a>
<a class="sourceLine" id="cb9-3" title="3">  ,<span class="ot"> tcPluginSolve ::</span> s <span class="ot">-&gt;</span> [<span class="dt">Ct</span>] <span class="ot">-&gt;</span> [<span class="dt">Ct</span>] <span class="ot">-&gt;</span> [<span class="dt">Ct</span>] <span class="ot">-&gt;</span> <span class="dt">TcPluginM</span> <span class="dt">TcPluginResult</span></a>
<a class="sourceLine" id="cb9-4" title="4">  ,<span class="ot"> tcPluginStop  ::</span> s <span class="ot">-&gt;</span> <span class="dt">TcPluginM</span> ()</a>
<a class="sourceLine" id="cb9-5" title="5">  }</a></code></pre></div>
<p>The <code>tcPluginInit</code> field can be used to allocate a piece of state that is passed to the other two records, and <code>tcPluginStop</code> finalizes that state. Most plugins I’ve seen use the <code>s</code> parameter to lookup the GHC representation of classes that they want to help solve. However, the most interesting bit is the <code>tcPluginSolve</code> function.</p>
<p><code>tcPluginSolve</code> takes three lists of <code>Ct</code>s, which are different varieties of constraints relevant to the problem.</p>
<ol type="1">
<li>The first list is the <em>given</em> constraints — the ones a user has explicitly written out in a type signature.</li>
<li>The second list is the <em>derived</em> constraints — things GHC has inferred from context.</li>
<li>The third list is the <em>wanted</em> constraints — the ones that GHC can’t solve on its own.</li>
</ol>
<p>From these three lists, we are expected to provide a <code>TcPluginResult</code>, which for our purposes is a pair of new <code>Ct</code>s we’d like GHC to solve; and a list of the <code>Ct</code>s we solved, along with the corresponding dictionaries. Returning two empty lists here signals to GHC “I can’t do any more work!”</p>
<p>So let’s get to work. The first thing we need to do is get our hands on the <code>Member</code> class we want to solve. In <code>polysemy</code>, <code>Member</code> is actually just a type synonym for a few other typeclasses; so the real typeclass we’d like to solve for is called <code>Find</code>.</p>
<p>As a brief aside on the <code>Find</code> class, its definition is this:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">class</span> <span class="dt">Find</span> (<span class="ot">r ::</span> [k]) (<span class="ot">t ::</span> k) <span class="kw">where</span></a></code></pre></div>
<p>and it means “lookup the index of <code>t</code> inside <code>r</code>”. In Polysemy, <code>r</code> is usually left polymorphic, for the same reasons that we leave the <code>m</code> polymorphic in <code>MonadState s m</code>.</p>
<p>Anyway, we want to find the <code>Find</code> class. We can do this by writing a function for our <code>tcPluginInit</code> function:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="ot">findFindClass ::</span> <span class="dt">TcPlugin</span> <span class="dt">Class</span></a>
<a class="sourceLine" id="cb11-2" title="2">findFindClass <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb11-3" title="3">  md <span class="ot">&lt;-</span> lookupModule</a>
<a class="sourceLine" id="cb11-4" title="4">          (mkModuleName <span class="st">&quot;Polysemy.Internal.Union&quot;</span>)</a>
<a class="sourceLine" id="cb11-5" title="5">          (fsLit <span class="st">&quot;polysemy&quot;</span>)</a>
<a class="sourceLine" id="cb11-6" title="6">  find_tc <span class="ot">&lt;-</span> lookupName md <span class="fu">$</span> mkTcOcc <span class="st">&quot;Find&quot;</span></a>
<a class="sourceLine" id="cb11-7" title="7">  tcLookupClass find_tc</a></code></pre></div>
<p>We first lookup the defining module, here <code>Polysemy.Internal.Union</code> in package <code>polysemy</code>. We then lookup the <code>Find</code> name in that module, and then lookup the class with that name. By setting <code>findFindClass</code> as our <code>tcPluginInit</code>, our <code>tcPluginSolve</code> function will receive the <code>Find</code> class as a parameter.</p>
<p>Before diving into <code>tcPluginSolve</code>, we’re going to need some helper functions.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="ot">allFindCts ::</span> <span class="dt">Class</span> <span class="ot">-&gt;</span> [<span class="dt">Ct</span>] <span class="ot">-&gt;</span> [(<span class="dt">CtLoc</span>, (<span class="dt">Type</span>, <span class="dt">Type</span>, <span class="dt">Type</span>))]</a>
<a class="sourceLine" id="cb12-2" title="2">allFindCts cls cts <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb12-3" title="3">  ct <span class="ot">&lt;-</span> cts</a>
<a class="sourceLine" id="cb12-4" title="4">  <span class="dt">CDictCan</span> { cc_tyargs <span class="fu">=</span> [ _, r, eff ] } <span class="ot">&lt;-</span> <span class="fu">pure</span> ct</a>
<a class="sourceLine" id="cb12-5" title="5">  guard <span class="fu">$</span> cls <span class="fu">==</span> cc_class cd</a>
<a class="sourceLine" id="cb12-6" title="6">  <span class="kw">let</span> eff_name <span class="fu">=</span> getEffName eff</a>
<a class="sourceLine" id="cb12-7" title="7">  <span class="fu">pure</span> (ctLoc ct, (eff_name, eff, r))</a>
<a class="sourceLine" id="cb12-8" title="8"></a>
<a class="sourceLine" id="cb12-9" title="9"><span class="ot">getEffName ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb12-10" title="10">getEffName t <span class="fu">=</span> <span class="fu">fst</span> <span class="fu">$</span> splitAppTys t</a></code></pre></div>
<p>The <code>allFindCts</code> function searches through the <code>Ct</code>s for <code>Find</code> constraints, and unpacks the pieces we’re going to need. We first pattern match on whether the <code>Ct</code> is a <code>CDictCan</code>, which corresponds to everyday typeclass-y constraints. We ensure it has exactly three type args (<code>Find</code> takes a kind, and then the two parameters we care about), and ensure that this class is the <code>cls</code> we’re looking for.</p>
<p>We return four things for each matching <code>Ct</code>:</p>
<ol type="1">
<li>We need to keep track of its <code>CtLoc</code> — corresponding to where the constraint came from. This is necessary to keep around so GHC can give good error messages if things go wrong.</li>
<li>The effect “name”. This is just the head of the effect, in our ongoing example, it’s <code>State</code>.</li>
<li>The actual effect we’re looking for. This corresponds to the <code>t</code> parameter in a <code>Find</code> constraint. In the ongoing example, <code>State s</code>.</li>
<li>The effect stack we’re searching in (<code>r</code> in the <code>Find</code> constraint).</li>
</ol>
<p>So remember, our idea is “see if there is exactly one matching given <code>Find</code> constraint for any wanted <code>Find</code> constraint — and if so, unify the two.”</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1">findMatchingEffect</a>
<a class="sourceLine" id="cb13-2" title="2"><span class="ot">    ::</span> (<span class="dt">Type</span>, <span class="dt">Type</span>, <span class="dt">Type</span>)</a>
<a class="sourceLine" id="cb13-3" title="3">    <span class="ot">-&gt;</span> [(<span class="dt">Type</span>, <span class="dt">Type</span>, <span class="dt">Type</span>)]</a>
<a class="sourceLine" id="cb13-4" title="4">    <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">Type</span></a>
<a class="sourceLine" id="cb13-5" title="5">findMatchingEffect (eff_name, _, r) ts <span class="fu">=</span></a>
<a class="sourceLine" id="cb13-6" title="6">  singleListToJust <span class="fu">$</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb13-7" title="7">    (eff_name&#39;, eff&#39;, r&#39;) <span class="ot">&lt;-</span> ts</a>
<a class="sourceLine" id="cb13-8" title="8">    guard <span class="fu">$</span> eqType eff_name eff_name&#39;</a>
<a class="sourceLine" id="cb13-9" title="9">    guard <span class="fu">$</span> eqType r r&#39;</a>
<a class="sourceLine" id="cb13-10" title="10">    <span class="fu">pure</span> eff</a>
<a class="sourceLine" id="cb13-11" title="11"></a>
<a class="sourceLine" id="cb13-12" title="12"><span class="ot">singleListToJust ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> a</a>
<a class="sourceLine" id="cb13-13" title="13">singleListToJust [a] <span class="fu">=</span> <span class="dt">Just</span> a</a>
<a class="sourceLine" id="cb13-14" title="14">singleListToJust _ <span class="fu">=</span> <span class="dt">Nothing</span></a></code></pre></div>
<p><code>findMatchingEffect</code> takes the output of <code>allFindCts</code> for a <em>single wanted constraint</em>, and <em>all of the given</em> constraints, and sees if there’s a single match between the two. If so, it returns the matching effect.</p>
<p>We need one last helper before we’re ready to put everything together. We wanted to be able to generate new wanted constraints of the form <code>a ~ b</code>. Emitting such a thing as a new wanted constraint will cause GHC to unify <code>a</code> and <code>b</code>; which is exactly what we’d like in order to convince it to use one given constraint in place of another.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1"><span class="ot">mkWanted ::</span> <span class="dt">CtLoc</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">TcPluginM</span> (<span class="dt">Maybe</span> <span class="dt">Ct</span>)</a>
<a class="sourceLine" id="cb14-2" title="2">mkWanted loc eff eff&#39; <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb14-3" title="3">  <span class="kw">if</span> eqType (getEffName eff) (getEffName eff&#39;)</a>
<a class="sourceLine" id="cb14-4" title="4">     <span class="kw">then</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb14-5" title="5">       (ev, _) <span class="ot">&lt;-</span> unsafeTcPluginTcM</a>
<a class="sourceLine" id="cb14-6" title="6">                <span class="fu">.</span> runTcSDeriveds</a>
<a class="sourceLine" id="cb14-7" title="7">                <span class="fu">$</span> newWantedEq loc <span class="dt">Nominal</span> eff eff&#39;</a>
<a class="sourceLine" id="cb14-8" title="8">       <span class="fu">pure</span> <span class="fu">.</span> <span class="dt">Just</span> <span class="fu">$</span> <span class="dt">CNonCanonical</span> ev</a>
<a class="sourceLine" id="cb14-9" title="9">     <span class="kw">else</span></a>
<a class="sourceLine" id="cb14-10" title="10">       <span class="fu">pure</span> <span class="dt">Nothing</span></a></code></pre></div>
<p>What’s going on here? Well we check if the two effects we want to unify have the same effect name. Then if so, we use the wanted’s <code>CtLoc</code> to generate a new, derived wanted constraint of the form <code>eff ~ eff'</code>. In essence, we’re promising the compiler that it can solve the wanted if it can solve <code>eff ~ eff'</code>.</p>
<p>And finally we’re ready to roll.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1"><span class="ot">solveFundep ::</span> <span class="dt">Class</span> <span class="ot">-&gt;</span> [<span class="dt">Ct</span>] <span class="ot">-&gt;</span> [<span class="dt">Ct</span>] <span class="ot">-&gt;</span> [<span class="dt">Ct</span>] <span class="ot">-&gt;</span> <span class="dt">TcPluginM</span> <span class="dt">TcPluginResult</span></a>
<a class="sourceLine" id="cb15-2" title="2">solveFundep find_cls giv _ want <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb15-3" title="3">    <span class="kw">let</span> wanted_effs <span class="fu">=</span> allFindCts find_cls want</a>
<a class="sourceLine" id="cb15-4" title="4">        given_effs  <span class="fu">=</span> <span class="fu">fmap</span> <span class="fu">snd</span> <span class="fu">$</span> allFindCts find_cls giv</a>
<a class="sourceLine" id="cb15-5" title="5"></a>
<a class="sourceLine" id="cb15-6" title="6">    eqs <span class="ot">&lt;-</span> forM wanted_effs <span class="fu">$</span> \(loc, e<span class="fu">@</span>(_, eff, r)) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb15-7" title="7">      <span class="kw">case</span> findMatchingEffect e given_effs <span class="kw">of</span></a>
<a class="sourceLine" id="cb15-8" title="8">        <span class="dt">Just</span> eff&#39; <span class="ot">-&gt;</span> mkWanted loc eff eff&#39;</a>
<a class="sourceLine" id="cb15-9" title="9">        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb15-10" title="10">          <span class="kw">case</span> splitAppTys r <span class="kw">of</span></a>
<a class="sourceLine" id="cb15-11" title="11">            (_, [_, eff&#39;, _]) <span class="ot">-&gt;</span> mkWanted loc eff eff&#39;</a>
<a class="sourceLine" id="cb15-12" title="12">            _                 <span class="ot">-&gt;</span> <span class="fu">pure</span> <span class="dt">Nothing</span></a>
<a class="sourceLine" id="cb15-13" title="13"></a>
<a class="sourceLine" id="cb15-14" title="14">    <span class="fu">pure</span> <span class="fu">.</span> <span class="dt">TcPluginOk</span> [] <span class="fu">$</span> catMaybes eqs</a></code></pre></div>
<p>We get all of the <code>Find</code> constraints in the givens and the wanteds. Then, for each wanted, we see if there is a singularly matching given, and if so, generate a wanted constraint unifying the two.</p>
<p>However, if we <em>don’t</em> find a singularly matching effect, we’re not necessarily in hot water. We attempt to decompose <code>r</code> into a type constructor and its arguments. Since <code>r</code> has kind <code>[k]</code>, there are three possibilities here:</p>
<ol type="1">
<li><code>r</code> is a polymorphic type variable, in which case we can do nothing.</li>
<li><code>r</code> is <code>'[]</code>, so we have no effects to possibly unify, and so we can do nothing.</li>
<li><code>r</code> has form <code>e ': es</code>, in which case we attempt to unify <code>e</code> with the wanted.</li>
</ol>
<p>What’s going on with this? Why is this bit necessary? Well, consider the case where we want to <em>run</em> our effect stack. Let’s say we have this program:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1"><span class="ot">foo&#39; ::</span> <span class="dt">Member</span> (<span class="dt">State</span> <span class="dt">Int</span>) r <span class="ot">=&gt;</span> <span class="dt">Sem</span> r ()</a>
<a class="sourceLine" id="cb16-2" title="2">foo&#39; <span class="fu">=</span> modify (<span class="fu">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb16-3" title="3"></a>
<a class="sourceLine" id="cb16-4" title="4"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb16-5" title="5">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb16-6" title="6">  result <span class="ot">&lt;-</span> runM <span class="fu">.</span> runState <span class="dv">5</span> <span class="fu">$</span> foo&#39;</a>
<a class="sourceLine" id="cb16-7" title="7">  <span class="fu">print</span> result</a></code></pre></div>
<p>The type of <code>runM . runState 5</code> is <code>Num a =&gt; Sem '[State a, Lift IO] x -&gt; IO x</code>. But <code>foo'</code> still wants a <code>State Int</code> constraint, however, <code>main</code> <em>doesn’t have any givens!</em> Instead, the wanted we see is of the form <code>Find '[State a, Lift IO] (State Int)</code>, and so we’re justified in our logic above to unify <code>State Int</code> with the head of the list.</p>
<p>Finally we can bundle everything up:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1"><span class="ot">plugin ::</span> <span class="dt">Plugin</span></a>
<a class="sourceLine" id="cb17-2" title="2">plugin <span class="fu">=</span> defaultPlugin</a>
<a class="sourceLine" id="cb17-3" title="3">    { tcPlugin <span class="fu">=</span> <span class="fu">const</span> <span class="fu">$</span> <span class="dt">Just</span> fundepPlugin</a>
<a class="sourceLine" id="cb17-4" title="4">    }</a>
<a class="sourceLine" id="cb17-5" title="5"></a>
<a class="sourceLine" id="cb17-6" title="6"><span class="ot">fundepPlugin ::</span> <span class="dt">TcPlugin</span></a>
<a class="sourceLine" id="cb17-7" title="7">fundepPlugin <span class="fu">=</span> <span class="dt">TcPlugin</span></a>
<a class="sourceLine" id="cb17-8" title="8">    { tcPluginInit <span class="fu">=</span> findFindClass</a>
<a class="sourceLine" id="cb17-9" title="9">    , tcPluginSolve <span class="fu">=</span> solveFundep</a>
<a class="sourceLine" id="cb17-10" title="10">    , tcPluginStop <span class="fu">=</span> <span class="fu">const</span> <span class="fu">$</span> <span class="fu">pure</span> ()</a>
<a class="sourceLine" id="cb17-11" title="11">    }</a></code></pre></div>
<p>and voila, upon loading our module via the <code>-fplugin</code> flag, GHC will automatically start solving <code>Member</code> constraints as though they were fundeps!</p>
<p>This isn’t the whole story; there are still a few kinks in the implementation for when your given is more polymorphic than your wanted (in which case they shouldn’t unify), but this is enough to get a feeling for the idea. As always, the <a href="https://github.com/isovector/polysemy/blob/master/polysemy-plugin/src/Polysemy/Plugin/Fundep.hs">full source code is on Github</a>.</p>
<p>As we’ve seen, TC plugins are extraordinarily powerful for helping GHC solve domain-specific problems, and simultaneously quite easy to write. They’re not often the right solution, but they’re a great thing to keep in your tool belt!</p>
        ]]>
      </content>
    </entry>
    <entry>
      <title>Writing Custom Optimization Passes</title>
      <id>blog/writing-custom-optimizations/index.html</id>
      <link href='blog/writing-custom-optimizations/index.html'/>
      <published>2019-05-22T13:39:00Z</published>
      <updated>2019-05-22T13:39:00Z</updated>

      <content type="html">
        <![CDATA[
        <p>I’ve been paying a lot of attention to performance in <a href="https://github.com/isovector/polysemy/"><code>polysemy</code></a>. Getting it to be fast <a href="/blog/freer-yet-too-costly/">has been really hard</a>. It’s clearly possible, but for the longest time I was afraid I’d need to fork the compiler. And that didn’t seem like a thing that would attract a large-user base.</p>
<p>For example, <code>polysemy</code> benefits greatly from a <a href="/blog/specialization/">late specialization pass</a>, and would benefit further from aggressive inlining <em>after</em> the late specialization pass. Unfortunately, <a href="https://github.com/ghc/ghc/blob/master/compiler/simplCore/SimplCore.hs#L320-L345">GHC doesn’t do any inlining passes after <code>-flate-specialise</code></a>, so it feels like we’re stuck on this front.</p>
<p>Thankfully, the eternally helpful <a href="https://mpickering.github.io/">mpickering</a> pointed me at the <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/extending_ghc.html#writing-compiler-plugins">GHC plugin interface</a>, which has support for directing the optimizer to do things it wouldn’t usually.</p>
<p>Today, I want to talk about how I made the <a href="https://github.com/isovector/polysemy/tree/master/polysemy-plugin"><code>polysemy-plugin</code></a> run two optimizations that greatly benefit code written with <code>polysemy</code>.</p>
<p>The gist of writing a GHC plugin is to import <code>ghc:Plugins</code>, and to create an exported top-level bind <code>plugin :: Plugin</code>. Other code can use this plugin by specifying the <code>-fplugin=</code> option to point at this module.</p>
<h2 id="installing-core-todos">Installing Core ToDos</h2>
<p><code>Plugin</code>s have a field called <code>installCoreToDos</code> with type <code>[CommandLineOption] -&gt; [CoreToDo] -&gt; CoreM [CoreToDo]</code>. A <code>CoreToDo</code> is GHC’s oddly-named concept of a compiler pass over Core. This function receives the list of <code>CoreToDo</code>s it was planning to do, and you can change that list if you want.</p>
<p>By default there’s a big flowchart of <code>CoreToDo</code>s that the compiler will run through in order to compile a module. The optimization level (<code>-O</code>) effects which passes get run, as do many of the <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/using-optimisation.html#f-platform-independent-flags">individual optimization flags</a>.</p>
<p>By attaching our extra optimization passes to the end of this list, we can make GHC optimize harder than it usually would. But because most code <em>won’t</em> benefit from this extra work, we guard the new optimization passes behind two conditions. The user must be compiling with optimizations turned on, and the module being compiled must import <code>Polysemy</code>.</p>
<p>Checking for the optimization level is simple enough, we can pull it out of the <code>DynFlags</code> (GHC’s datatype that stores all of the crazy flags you might have set):</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1">  dflags <span class="ot">&lt;-</span> getDynFlags</a>
<a class="sourceLine" id="cb1-2" title="2">  <span class="kw">case</span> optLevel dflags <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-3" title="3">    <span class="dv">0</span> <span class="ot">-&gt;</span> <span class="co">-- corresponds to -O0</span></a>
<a class="sourceLine" id="cb1-4" title="4">    <span class="dv">1</span> <span class="ot">-&gt;</span> <span class="co">-- corresponds to -O</span></a>
<a class="sourceLine" id="cb1-5" title="5">    <span class="dv">2</span> <span class="ot">-&gt;</span> <span class="co">-- corresponds to -O2</span></a></code></pre></div>
<p>Checking, however, for presence of the <code>Polysemy</code> module is less straightforward. Honestly I’m not sure what the “correct” solution to this problem is, but I’m pretty happy with the disgusting hack I came up with.</p>
<p>The <code>CoreM</code> monad (which is what you’re running in when you install <code>CoreToDo</code>s) doesn’t exactly have <a href="https://www.stackage.org/haddock/lts-13.21/ghc-8.6.5/CoreMonad.html#t:CoreM">stellar documentation</a>. It has access to the <code>HscEnv</code>, which in turn has a <code>hsc_mod_graph :: ModuleGraph</code> — which sounds like the sort of thing that might contain the modules currently in scope. Unfortunately this is not so; <code>hsc_mod_graph</code> contains the modules defined in the <em>package</em> being defined.</p>
<p>If we could get our hands on the <code>ModGuts</code> (GHC’s representation of a Haskell module), we could inspect its <code>mg_deps :: Dependencies</code> field, which would surely have what we need. Unfortunately, I couldn’t find any easy way to get access to the <code>ModGuts</code> in a <code>CoreM</code> without jumping through several hoops.</p>
<p>But one thing caught my eye! There is an operation <code>getVisibleOrphanMods :: CoreM ModuleSet</code>, which after some investigation, turns out to contain any module in scope (directly or otherwise) that defines an orphan instance.</p>
<p>It’s disgusting, but I made an internal module in <code>polysemy</code> that contains the following definitions:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">module</span> <span class="dt">Polysemy.Internal.PluginLookup</span> <span class="kw">where</span></a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="kw">class</span> <span class="dt">PluginLookup</span> t</a>
<a class="sourceLine" id="cb2-4" title="4"><span class="kw">data</span> <span class="dt">Plugin</span></a></code></pre></div>
<p>and the corresponding orphan instance in the module I wanted to track in my plugin:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="ot">{-# OPTIONS_GHC -fno-warn-orphans #-}</span></a>
<a class="sourceLine" id="cb3-2" title="2"></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="kw">import</span> <span class="dt">Polysemy.Internal.PluginLookup</span></a>
<a class="sourceLine" id="cb3-4" title="4"></a>
<a class="sourceLine" id="cb3-5" title="5"><span class="kw">instance</span> <span class="dt">PluginLookup</span> <span class="dt">Plugin</span></a></code></pre></div>
<p>I know, I know. But because the module that defines these things is internal, there’s no way for anyone else to define instances of this thing. So at least it’s a safe use of orphans.</p>
<p>Sure enough, this little gem is enough to get my module noticed by <code>getVisibleOrphanMods</code>, and so I can check for the presence of my module via:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1">  mods <span class="ot">&lt;-</span> moduleSetElts <span class="fu">&lt;$&gt;</span> getVisibleOrphanMods</a>
<a class="sourceLine" id="cb4-2" title="2">  <span class="kw">if</span> <span class="fu">any</span> ((<span class="fu">==</span> mkModuleName <span class="st">&quot;Polysemy.Internal&quot;</span>) <span class="fu">.</span> moduleName) mods</a>
<a class="sourceLine" id="cb4-3" title="3">     <span class="kw">then</span> <span class="fu">...</span></a></code></pre></div>
<p>And voila, we’re now ready to install our extra <code>CoreToDo</code>s. In this case, I just cargo-culted a few from GHC’s existing passes list. Namely I added a <code>CoreDoSpecialising</code>, a <code>CoreDoStaticArgs</code>, yet another <code>CoreDoSpecialising</code>, and a bevvy of simplification passes. The result might be overkill, but it’s sufficient to massage <a href="https://gist.github.com/isovector/e4832512ec9c73bff94432a7a58470f9#file-t16473-dump-simpl">this scary core</a> into <a href="https://gist.github.com/isovector/e4832512ec9c73bff94432a7a58470f9#gistcomment-2883147">this</a> — and get roughly a 1000x runtime performance improvement in the process.</p>
<h2 id="inlining-recursive-calls">Inlining Recursive Calls</h2>
<p>But this lack of optimization passes wasn’t the only thing slowly <code>polysemy</code> down. The library depends on several library- and user-written functions that are complicated and necessarily self-recursive.</p>
<p>GHC is understandably hesitant to inline recursive functions — the result would diverge — but as a side-effect, it seems to refuse to optimize big recursive functions whatsoever. For my purposes, this meant that most of the crucial machinery in the library was being completely ignored by GHC’s best optimization pass.</p>
<p>I accidentally stumbled upon a fix. To illustrate, let’s pretend like the <code>factorial</code> function is my complicated self-recursive function. The optimizer would refuse to fire when the function was written like this:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="ot">factorial ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb5-2" title="2">factorial <span class="dv">0</span> <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb5-3" title="3">factorial n <span class="fu">=</span> n <span class="fu">*</span> factorial (n <span class="fu">-</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb5-4" title="4"><span class="ot">{-# INLINE factorial #-}</span></a></code></pre></div>
<p>But, a minor syntactic tweak was enough to trick the compiler into optimizing it:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="ot">factorial ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb6-2" title="2">factorial <span class="dv">0</span> <span class="fu">=</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb6-3" title="3">factorial n <span class="fu">=</span> n <span class="fu">*</span> factorial&#39; (n <span class="fu">-</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb6-4" title="4"><span class="ot">{-# INLINE factorial #-}</span></a>
<a class="sourceLine" id="cb6-5" title="5"></a>
<a class="sourceLine" id="cb6-6" title="6"><span class="ot">factorial&#39; ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb6-7" title="7">factorial&#39; <span class="fu">=</span> factorial</a>
<a class="sourceLine" id="cb6-8" title="8"><span class="ot">{-# NOINLINE factorial&#39; #-}</span></a></code></pre></div>
<p>Now <code>factorial</code> is no longer self-recursive. It’s mutually recursive, and for some reason, the <code>NO/INLINE</code> pragmas are enough to keep GHC off our back. This is an easy fix, but it’s annoying boilerplate. And I <em>hate</em> annoying boilerplate.</p>
<p>Early versions of <code>polysemy</code> shipped with a function <code>inlineRecursiveCalls :: Q [Dec] -&gt; Q [Dec]</code> which would use Template Haskell to transform our slow, self-recursive <code>factorial</code> above into the fast, mutually-exclusive version below. While this worked, it was unsatisfactory; TH splices don’t play nicely with haddock or with text editors.</p>
<p>But this isn’t something that regular users should need to care about! Optimization concerns should lie solely in the responsibility of library-writers — not in their users. It seemed like a good opportunity to write a custom optimization pass, and like any curious boy, I took it.</p>
<p>We can use the <code>CoreDoPluginPass :: String -&gt; (ModGuts -&gt; CoreM ModGuts) -&gt; CoreToDo</code> constructor to inject our own <code>ModGuts</code> transformation as an optimization pass. Recall that <code>ModGuts</code> is GHC’s definition of a module. For our purposes, we’re interested in its <code>mg_binds</code> field, which contains all of the value-level things in the module.</p>
<p>A <code>mg_binds</code> is a <code>[Bind CoreBndr]</code>, and a <code>Bind CoreBndr</code> is a pair of a name and its corresponding expression definition. More specifically, the definition for <code>Bind</code> is:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">data</span> <span class="dt">Bind</span> b <span class="fu">=</span> <span class="dt">NonRec</span> b (<span class="dt">Expr</span> b)</a>
<a class="sourceLine" id="cb7-2" title="2">            <span class="fu">|</span> <span class="dt">Rec</span> [(b, (<span class="dt">Expr</span> b))]</a></code></pre></div>
<p>A non-recursive binding is something like <code>x = 5</code>, while a recursive binding is anything that is self- or mutually-recursive.</p>
<p>So, if we want to transform self-recursive calls into mutually-recursive calls, we first need to identify if a definition is self-recursive. Fortunately, the incredible <code>syb</code> library comes in handy here, as it lets us write small queries that get lifted over the entire datatype.</p>
<p>We can write <code>containsName</code> using <a href="https://www.stackage.org/haddock/lts-13.22/syb-0.7/Data-Generics-Schemes.html#v:everywhere"><code>everywhere</code></a>, <a href="https://www.stackage.org/haddock/lts-13.22/syb-0.7/Data-Generics-Aliases.html#v:mkQ"><code>mkQ</code></a> and the <a href="https://www.stackage.org/haddock/lts-13.22/base-4.12.0.0/Data-Monoid.html#t:Any"><code>Any</code></a> monoid to determine if the <code>CoreBndr</code> name is used anywhere in the <code>CoreExpr</code><a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1"><span class="ot">containsName ::</span> <span class="dt">CoreBndr</span> <span class="ot">-&gt;</span> <span class="dt">CoreExpr</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb8-2" title="2">containsName n <span class="fu">=</span></a>
<a class="sourceLine" id="cb8-3" title="3">    getAny <span class="fu">.</span></a>
<a class="sourceLine" id="cb8-4" title="4">      everything</a>
<a class="sourceLine" id="cb8-5" title="5">        (<span class="fu">&lt;&gt;</span>)</a>
<a class="sourceLine" id="cb8-6" title="6">        (mkQ (<span class="dt">Any</span> <span class="dt">False</span>) matches)</a>
<a class="sourceLine" id="cb8-7" title="7">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb8-8" title="8"><span class="ot">    matches ::</span> <span class="dt">CoreExpr</span> <span class="ot">-&gt;</span> <span class="dt">Any</span></a>
<a class="sourceLine" id="cb8-9" title="9">    matches (<span class="dt">Var</span> n&#39;) <span class="fu">|</span> n <span class="fu">==</span> n&#39; <span class="fu">=</span> <span class="dt">Any</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb8-10" title="10">    matches _ <span class="fu">=</span> <span class="dt">Any</span> <span class="dt">False</span></a></code></pre></div>
<p>If <code>containsName b e</code> is <code>True</code> for any <code>(b, e)</code> in the <code>mg_binds</code>, then that function is self-recursive. As such, we’d like to generate a new <code>NOINLINE</code> bind for it, and then replace the original self-call to be to this new bind.</p>
<p>Replacing a call is just as easy as finding the recursion:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1"><span class="ot">replace ::</span> <span class="dt">CoreBndr</span> <span class="ot">-&gt;</span> <span class="dt">CoreBndr</span> <span class="ot">-&gt;</span> <span class="dt">CoreExpr</span> <span class="ot">-&gt;</span> <span class="dt">CoreExpr</span></a>
<a class="sourceLine" id="cb9-2" title="2">replace n n&#39; <span class="fu">=</span> everywhere <span class="fu">$</span> mkT go</a>
<a class="sourceLine" id="cb9-3" title="3">  <span class="kw">where</span></a>
<a class="sourceLine" id="cb9-4" title="4"><span class="ot">    go ::</span> <span class="dt">CoreExpr</span> <span class="ot">-&gt;</span> <span class="dt">CoreExpr</span></a>
<a class="sourceLine" id="cb9-5" title="5">    go v<span class="fu">@</span>(<span class="dt">Var</span> nn)</a>
<a class="sourceLine" id="cb9-6" title="6">      <span class="fu">|</span> nn <span class="fu">==</span> n   <span class="fu">=</span> <span class="dt">Var</span> n&#39;</a>
<a class="sourceLine" id="cb9-7" title="7">      <span class="fu">|</span> <span class="fu">otherwise</span> <span class="fu">=</span> v</a>
<a class="sourceLine" id="cb9-8" title="8">    go x <span class="fu">=</span> x</a></code></pre></div>
<p>But creating the new binding is rather more work; we need to construct a new name for it, and then fiddle with its <code>IdInfo</code> in order to set the inlining information we’d like.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="ot">loopbreaker ::</span> <span class="dt">Uniq</span> <span class="ot">-&gt;</span> <span class="dt">CoreBndr</span> <span class="ot">-&gt;</span> <span class="dt">CoreExpr</span> <span class="ot">-&gt;</span> [(<span class="dt">Var</span>, <span class="dt">CoreExpr</span>)]</a>
<a class="sourceLine" id="cb10-2" title="2">loopbreaker newUniq n e <span class="fu">=</span></a>
<a class="sourceLine" id="cb10-3" title="3">  <span class="kw">let</span> <span class="dt">Just</span> info <span class="fu">=</span> zapUsageInfo <span class="fu">$</span> idInfo n</a>
<a class="sourceLine" id="cb10-4" title="4">      info&#39; <span class="fu">=</span> setInlinePragInfo info alwaysInlinePragma</a>
<a class="sourceLine" id="cb10-5" title="5">      n&#39; <span class="fu">=</span> mkLocalVar</a>
<a class="sourceLine" id="cb10-6" title="6">             (idDetails n)</a>
<a class="sourceLine" id="cb10-7" title="7">             (mkInternalName newUniq (occName n) noSrcSpan)</a>
<a class="sourceLine" id="cb10-8" title="8">             (idType n)</a>
<a class="sourceLine" id="cb10-9" title="9">         <span class="fu">$</span> setInlinePragInfo vanillaIdInfo neverInlinePragma</a>
<a class="sourceLine" id="cb10-10" title="10">   <span class="kw">in</span> [ (lazySetIdInfo n info&#39;, replace n n&#39; e)</a>
<a class="sourceLine" id="cb10-11" title="11">      , (n&#39;, <span class="dt">Var</span> n)</a>
<a class="sourceLine" id="cb10-12" title="12">      ]</a></code></pre></div>
<p>First we use <code>zapUsageInfo</code> to make GHC forget that this binding is self-recursive<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>, and then use <code>setInlinePragInfo</code> to spiritually inject a <code>{-# INLINE n #-}</code> pragma onto it. We then construct a new name (a nontrivial affair; <code>loopbreaker</code> above is simplified in order to get the new <code>Uniq</code> to ensure our variable is hygienic), and replace the self-recursive call with a call to the new name. Finally, we need to spit out the two resulting binds.</p>
<p>There’s a little machinery to call <code>loopbreaker</code> on the <code>mg_guts</code>, but it’s uninteresting and this post is already long enough. If you’re interested, the <a href="https://github.com/isovector/polysemy/blob/f84dc2577524e8ba25c35b9b7479c63edd220a6e/polysemy-plugin/src/Polysemy/Plugin/InlineRecursiveCalls.hs">full code is available on Github</a>. In total, it’s a little less than 100 lines long; pretty good for adding a completely new optimization pass!</p>
<p>That’s enough about writing plugins for improving performance; in the next post we’ll discuss typechecker plugins, and how they can be used to extend GHC’s constraint-solving machinery. Stay tuned!</p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>GHC has a bad habit of using type synonyms. A <code>CoreExpr</code> is just a <code>Expr CoreBndr</code>.<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>I’m not sure this part is necessary, but it doesn’t seem to hurt.<a href="#fnref2" class="footnote-back">↩</a></p></li>
</ol>
</section>
        ]]>
      </content>
    </entry>
    <entry>
      <title>GHC&#39;s Specializer: Much More Than You Wanted to Know</title>
      <id>blog/specialization/index.html</id>
      <link href='blog/specialization/index.html'/>
      <published>2019-05-18T21:59:00Z</published>
      <updated>2019-05-18T21:59:00Z</updated>

      <content type="html">
        <![CDATA[
        <p>In the course of <a href="/blog/freer-yet-too-costly/">tracking down why free monads were so slow</a>, I fell into a deep labyrinth of scary GHC internals. Six weeks later, I emerged, significantly more knowledgeable, and having implemented some changes in the compiler that will allow <a href="https://hackage.haskell.org/package/polysemy"><code>polysemy</code></a> to be optimized much better. The improvements will be available in 8.10.1.</p>
<p>All of this seems like a good opportunity to share what I’ve learned, so today let’s talk about GHC’s <em>specialization pass.</em> This optimization is more popularly known as “the reason why <code>mtl</code> is so fast.”</p>
<p>At a high level, the specialization pass is responsible for optimizing away uses of ad-hoc polymorphism (typeclasses) in Haskell source code. When <code>-fspecialise</code> is enabled, GHC will make a monomorphic copy of every polymorphic method — one for every unique type it’s called with. The result should feel similar to anyone who’s written modern C++, as it’s completely analogous to how templates work.</p>
<p>While polymorphic functions are great for <em>humans to write</em>, they’re significantly slower for <em>machines to execute,</em> since you need to pass around vtables and perform dynamic dispatches, and all sorts of crazy things. This is exactly the purpose of GHC’s specialization pass, to simply get rid of all of that machinery and keep only the pieces that are explicitly used.</p>
<p>Let’s take an example. Consider the following program:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb1-1" title="1"><span class="ot">{-# LANGUAGE FlexibleContexts #-}</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="ot">{-# OPTIONS_GHC</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="ot">      -ddump-simpl</span></a>
<a class="sourceLine" id="cb1-4" title="4"><span class="ot">      -dsuppress-idinfo</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="ot">      -dsuppress-coercions</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="ot">      -dsuppress-module-prefixes</span></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="ot">      -fforce-recomp</span></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="ot">      #-}</span></a>
<a class="sourceLine" id="cb1-9" title="9"></a>
<a class="sourceLine" id="cb1-10" title="10"><span class="kw">import</span>           <span class="dt">Control.Monad.State.Class</span></a>
<a class="sourceLine" id="cb1-11" title="11"><span class="kw">import</span> <span class="kw">qualified</span> <span class="dt">Control.Monad.Trans.State</span> <span class="kw">as</span> <span class="dt">S</span></a>
<a class="sourceLine" id="cb1-12" title="12"></a>
<a class="sourceLine" id="cb1-13" title="13"><span class="ot">countdown ::</span> <span class="dt">S.StateT</span> <span class="dt">Int</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-14" title="14">countdown <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-15" title="15">  v <span class="ot">&lt;-</span> get</a>
<a class="sourceLine" id="cb1-16" title="16">  <span class="kw">case</span> v <span class="kw">of</span></a>
<a class="sourceLine" id="cb1-17" title="17">    <span class="dv">0</span> <span class="ot">-&gt;</span> <span class="fu">pure</span> ()</a>
<a class="sourceLine" id="cb1-18" title="18">    _ <span class="ot">-&gt;</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb1-19" title="19">      put <span class="fu">$</span> v <span class="fu">-</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb1-20" title="20">      countdown</a>
<a class="sourceLine" id="cb1-21" title="21"></a>
<a class="sourceLine" id="cb1-22" title="22"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb1-23" title="23">main <span class="fu">=</span> S.evalStateT countdown <span class="dv">10</span></a></code></pre></div>
<p>When compiled via <code>ghc Example.hs -O -fno-specialise</code><a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>, we can look directly at the resulting Core of this program. If you’re unfamiliar with Core, it’s GHC’s intermediate language between source-level Haskell and the generated machine code. Core differs in two notable ways from source Haskell: its evaluation is explicit via <code>case</code> expressions, and both types and typeclass instances are explicitly passed around.</p>
<p>Anyway, here’s the relevant Core for our above program:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb2-1" title="1"><span class="dt">Rec</span> {</a>
<a class="sourceLine" id="cb2-2" title="2"><span class="co">-- RHS size: {terms: 14, types: 13, coercions: 0, joins: 0/0}</span></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="fu">$</span>wcountdown</a>
<a class="sourceLine" id="cb2-4" title="4"><span class="ot">  ::</span> <span class="dt">Int</span><span class="fu">#</span> <span class="ot">-&gt;</span> <span class="dt">State</span><span class="fu">#</span> <span class="dt">RealWorld</span> <span class="ot">-&gt;</span> (<span class="fu">#</span> <span class="dt">State</span><span class="fu">#</span> <span class="dt">RealWorld</span>, ((), <span class="dt">Int</span>) <span class="fu">#</span>)</a>
<a class="sourceLine" id="cb2-5" title="5"><span class="fu">$</span>wcountdown</a>
<a class="sourceLine" id="cb2-6" title="6">  <span class="fu">=</span> \ (<span class="ot">ww_s49L ::</span> <span class="dt">Int</span><span class="fu">#</span>) (<span class="ot">w_s49I ::</span> <span class="dt">State</span><span class="fu">#</span> <span class="dt">RealWorld</span>) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb2-7" title="7">      <span class="kw">case</span> ww_s49L <span class="kw">of</span> ds_X2I1 {</a>
<a class="sourceLine" id="cb2-8" title="8">        __DEFAULT <span class="ot">-&gt;</span> <span class="fu">$</span>wcountdown (<span class="fu">-#</span> ds_X2I1 <span class="dv">1</span><span class="fu">#</span>) w_s49I;</a>
<a class="sourceLine" id="cb2-9" title="9">        <span class="dv">0</span><span class="fu">#</span> <span class="ot">-&gt;</span> (<span class="fu">#</span> w_s49I, lvl1_r4ap <span class="fu">#</span>)</a>
<a class="sourceLine" id="cb2-10" title="10">      }</a>
<a class="sourceLine" id="cb2-11" title="11">end <span class="dt">Rec</span> }</a>
<a class="sourceLine" id="cb2-12" title="12"></a>
<a class="sourceLine" id="cb2-13" title="13"><span class="co">-- RHS size: {terms: 12, types: 29, coercions: 0, joins: 0/0}</span></a>
<a class="sourceLine" id="cb2-14" title="14"><span class="ot">main1 ::</span> <span class="dt">State</span><span class="fu">#</span> <span class="dt">RealWorld</span> <span class="ot">-&gt;</span> (<span class="fu">#</span> <span class="dt">State</span><span class="fu">#</span> <span class="dt">RealWorld</span>, () <span class="fu">#</span>)</a>
<a class="sourceLine" id="cb2-15" title="15">main1</a>
<a class="sourceLine" id="cb2-16" title="16">  <span class="fu">=</span> \ (<span class="ot">s_a2Ks ::</span> <span class="dt">State</span><span class="fu">#</span> <span class="dt">RealWorld</span>) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb2-17" title="17">      <span class="kw">case</span> <span class="fu">$</span>wcountdown <span class="dv">10</span><span class="fu">#</span> s_a2Ks <span class="kw">of</span> { (<span class="fu">#</span> ipv_a2Kv, ipv1_a2Kw <span class="fu">#</span>) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb2-18" title="18">      (<span class="fu">#</span> ipv_a2Kv,</a>
<a class="sourceLine" id="cb2-19" title="19">         <span class="kw">case</span> ipv1_a2Kw <span class="kw">of</span> { (a1_a2I6, ds2_a2I7) <span class="ot">-&gt;</span> a1_a2I6 } <span class="fu">#</span>)</a>
<a class="sourceLine" id="cb2-20" title="20">      }</a></code></pre></div>
<p>As you can see, this is very short and to the point. Reading Core is a bit of an art, but the gist of it is this: <code>main1</code> calls <code>$wcountdown</code>, which recursively calls itself, until the value of <code>w_s49I</code> is <code>0#</code> when it stops. It’s probably exactly the same code you’d write by hand, if for some reason you were writing Core by hand.</p>
<p>Our program above is written directly against <code>transformers</code>, but nobody actually writes code against <code>transformers</code> in the real world. Choosing a concrete monad transformer stack is limiting, and at the same time, prevents you from restricting access to pieces of the stack. Instead, we’re encouraged to write code against abstract monad capabilities, traditionally <code>mtl</code>.</p>
<p>So let’s subtly change the type of <code>countdown</code> above:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb3-1" title="1"><span class="ot">countdown ::</span> <span class="dt">MonadState</span> <span class="dt">Int</span> m <span class="ot">=&gt;</span> m ()</a></code></pre></div>
<p>Nothing else in the program needs to change. Let’s now compile this program again via <code>ghc Example.hs -O -fno-specialise</code>. The result is <em>horrendously</em> worse Core:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb4-1" title="1"><span class="dt">Rec</span> {</a>
<a class="sourceLine" id="cb4-2" title="2"><span class="co">-- RHS size: {terms: 35, types: 47, coercions: 0, joins: 0/2}</span></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="fu">$</span>wcountdown</a>
<a class="sourceLine" id="cb4-4" title="4"><span class="ot">  ::</span> <span class="kw">forall</span> (<span class="ot">m ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>)<span class="fu">.</span></a>
<a class="sourceLine" id="cb4-5" title="5">     <span class="dt">Applicative</span> m <span class="ot">=&gt;</span></a>
<a class="sourceLine" id="cb4-6" title="6">     (<span class="kw">forall</span> a b<span class="fu">.</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b)</a>
<a class="sourceLine" id="cb4-7" title="7">     <span class="ot">-&gt;</span> (<span class="kw">forall</span> a b<span class="fu">.</span> m a <span class="ot">-&gt;</span> m b <span class="ot">-&gt;</span> m b)</a>
<a class="sourceLine" id="cb4-8" title="8">     <span class="ot">-&gt;</span> m <span class="dt">Int</span></a>
<a class="sourceLine" id="cb4-9" title="9">     <span class="ot">-&gt;</span> (<span class="dt">Int</span> <span class="ot">-&gt;</span> m ())</a>
<a class="sourceLine" id="cb4-10" title="10">     <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="cb4-11" title="11"><span class="fu">$</span>wcountdown</a>
<a class="sourceLine" id="cb4-12" title="12">  <span class="fu">=</span> \ (<span class="fu">@</span> (<span class="ot">m_s4WK ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>))</a>
<a class="sourceLine" id="cb4-13" title="13">      (<span class="ot">ww_s4WR ::</span> <span class="dt">Applicative</span> m_s4WK)</a>
<a class="sourceLine" id="cb4-14" title="14">      (<span class="ot">ww1_s4WS ::</span> <span class="kw">forall</span> a b<span class="fu">.</span> m_s4WK a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m_s4WK b) <span class="ot">-&gt;</span> m_s4WK b)</a>
<a class="sourceLine" id="cb4-15" title="15">      (<span class="ot">ww2_s4WT ::</span> <span class="kw">forall</span> a b<span class="fu">.</span> m_s4WK a <span class="ot">-&gt;</span> m_s4WK b <span class="ot">-&gt;</span> m_s4WK b)</a>
<a class="sourceLine" id="cb4-16" title="16">      (<span class="ot">ww3_s4WX ::</span> m_s4WK <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb4-17" title="17">      (<span class="ot">ww4_s4WY ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> m_s4WK ()) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb4-18" title="18">      <span class="kw">let</span> {</a>
<a class="sourceLine" id="cb4-19" title="19"><span class="ot">        lvl6_s4W1 ::</span> m_s4WK ()</a>
<a class="sourceLine" id="cb4-20" title="20">        lvl6_s4W1</a>
<a class="sourceLine" id="cb4-21" title="21">          <span class="fu">=</span> <span class="fu">$</span>wcountdown</a>
<a class="sourceLine" id="cb4-22" title="22">              <span class="fu">@</span> m_s4WK ww_s4WR ww1_s4WS ww2_s4WT ww3_s4WX ww4_s4WY } <span class="kw">in</span></a>
<a class="sourceLine" id="cb4-23" title="23">      <span class="kw">let</span> {</a>
<a class="sourceLine" id="cb4-24" title="24"><span class="ot">        lvl7_s4W2 ::</span> m_s4WK ()</a>
<a class="sourceLine" id="cb4-25" title="25">        lvl7_s4W2 <span class="fu">=</span> <span class="fu">pure</span> <span class="fu">@</span> m_s4WK ww_s4WR <span class="fu">@</span> () () } <span class="kw">in</span></a>
<a class="sourceLine" id="cb4-26" title="26">      ww1_s4WS</a>
<a class="sourceLine" id="cb4-27" title="27">        <span class="fu">@</span> <span class="dt">Int</span></a>
<a class="sourceLine" id="cb4-28" title="28">        <span class="fu">@</span> ()</a>
<a class="sourceLine" id="cb4-29" title="29">        ww3_s4WX</a>
<a class="sourceLine" id="cb4-30" title="30">        (\ (<span class="ot">v_a192 ::</span> <span class="dt">Int</span>) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb4-31" title="31">           <span class="kw">case</span> v_a192 <span class="kw">of</span> { <span class="dt">I</span><span class="fu">#</span> ds_d3xJ <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb4-32" title="32">           <span class="kw">case</span> ds_d3xJ <span class="kw">of</span> ds1_X3xT {</a>
<a class="sourceLine" id="cb4-33" title="33">             __DEFAULT <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb4-34" title="34">               ww2_s4WT <span class="fu">@</span> () <span class="fu">@</span> () (ww4_s4WY (<span class="dt">I</span><span class="fu">#</span> (<span class="fu">-#</span> ds1_X3xT <span class="dv">1</span><span class="fu">#</span>))) lvl6_s4W1;</a>
<a class="sourceLine" id="cb4-35" title="35">             <span class="dv">0</span><span class="fu">#</span> <span class="ot">-&gt;</span> lvl7_s4W2</a>
<a class="sourceLine" id="cb4-36" title="36">           }</a>
<a class="sourceLine" id="cb4-37" title="37">           })</a>
<a class="sourceLine" id="cb4-38" title="38">end <span class="dt">Rec</span> }</a>
<a class="sourceLine" id="cb4-39" title="39"></a>
<a class="sourceLine" id="cb4-40" title="40"><span class="co">-- RHS size: {terms: 17, types: 32, coercions: 21, joins: 0/0}</span></a>
<a class="sourceLine" id="cb4-41" title="41"><span class="ot">main1 ::</span> <span class="dt">State</span><span class="fu">#</span> <span class="dt">RealWorld</span> <span class="ot">-&gt;</span> (<span class="fu">#</span> <span class="dt">State</span><span class="fu">#</span> <span class="dt">RealWorld</span>, () <span class="fu">#</span>)</a>
<a class="sourceLine" id="cb4-42" title="42">main1</a>
<a class="sourceLine" id="cb4-43" title="43">  <span class="fu">=</span> \ (<span class="ot">s_a3z5 ::</span> <span class="dt">State</span><span class="fu">#</span> <span class="dt">RealWorld</span>) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb4-44" title="44">      <span class="kw">case</span> ((((<span class="fu">$</span>wcountdown</a>
<a class="sourceLine" id="cb4-45" title="45">                 <span class="fu">@</span> (<span class="dt">StateT</span> <span class="dt">Int</span> <span class="dt">IO</span>)</a>
<a class="sourceLine" id="cb4-46" title="46">                 lvl_r4VN</a>
<a class="sourceLine" id="cb4-47" title="47">                 lvl1_r50i</a>
<a class="sourceLine" id="cb4-48" title="48">                 lvl2_r50j</a>
<a class="sourceLine" id="cb4-49" title="49">                 (lvl3_r50k <span class="ot">`cast`</span> <span class="fu">&lt;</span><span class="dt">Co</span><span class="fu">:</span><span class="dv">13</span><span class="fu">&gt;</span>)</a>
<a class="sourceLine" id="cb4-50" title="50">                 lvl4_r50l)</a>
<a class="sourceLine" id="cb4-51" title="51">              <span class="ot">`cast`</span> <span class="fu">&lt;</span><span class="dt">Co</span><span class="fu">:</span><span class="dv">4</span><span class="fu">&gt;</span>)</a>
<a class="sourceLine" id="cb4-52" title="52">               lvl5_r50m)</a>
<a class="sourceLine" id="cb4-53" title="53">            <span class="ot">`cast`</span> <span class="fu">&lt;</span><span class="dt">Co</span><span class="fu">:</span><span class="dv">4</span><span class="fu">&gt;</span>)</a>
<a class="sourceLine" id="cb4-54" title="54">             s_a3z5</a>
<a class="sourceLine" id="cb4-55" title="55">      <span class="kw">of</span></a>
<a class="sourceLine" id="cb4-56" title="56">      { (<span class="fu">#</span> ipv_a3z8, ipv1_a3z9 <span class="fu">#</span>) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb4-57" title="57">      (<span class="fu">#</span> ipv_a3z8,</a>
<a class="sourceLine" id="cb4-58" title="58">         <span class="kw">case</span> ipv1_a3z9 <span class="kw">of</span> { (a1_a3y3, ds2_a3y4) <span class="ot">-&gt;</span> a1_a3y3 } <span class="fu">#</span>)</a>
<a class="sourceLine" id="cb4-59" title="59">      }</a></code></pre></div>
<p>Yikes! What a mess! It’s amazing how much of a difference that one type signature made! Our simple <code>mtl</code> program above has turned into an unholy mess of passing around overly-polymorphic functions. We’ve paid an awful price to abstract away our monad stack, <em>even though the actual program being run didn’t change!</em></p>
<p>Of course, this isn’t a <em>real problem</em> in the wild. Compile the program again, this time without the <code>-fno-specialise</code> flag<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a> — <code>ghc Example.hs -O</code>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb5-1" title="1"><span class="dt">Rec</span> {</a>
<a class="sourceLine" id="cb5-2" title="2"><span class="co">-- RHS size: {terms: 14, types: 13, coercions: 0, joins: 0/0}</span></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="fu">$</span>w<span class="fu">$</span>scountdown</a>
<a class="sourceLine" id="cb5-4" title="4"><span class="ot">  ::</span> <span class="dt">Int</span><span class="fu">#</span> <span class="ot">-&gt;</span> <span class="dt">State</span><span class="fu">#</span> <span class="dt">RealWorld</span> <span class="ot">-&gt;</span> (<span class="fu">#</span> <span class="dt">State</span><span class="fu">#</span> <span class="dt">RealWorld</span>, ((), <span class="dt">Int</span>) <span class="fu">#</span>)</a>
<a class="sourceLine" id="cb5-5" title="5"><span class="fu">$</span>w<span class="fu">$</span>scountdown</a>
<a class="sourceLine" id="cb5-6" title="6">  <span class="fu">=</span> \ (<span class="ot">ww_s5dY ::</span> <span class="dt">Int</span><span class="fu">#</span>) (<span class="ot">w_s5dV ::</span> <span class="dt">State</span><span class="fu">#</span> <span class="dt">RealWorld</span>) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb5-7" title="7">      <span class="kw">case</span> ww_s5dY <span class="kw">of</span> ds_X3xU {</a>
<a class="sourceLine" id="cb5-8" title="8">        __DEFAULT <span class="ot">-&gt;</span> <span class="fu">$</span>w<span class="fu">$</span>scountdown (<span class="fu">-#</span> ds_X3xU <span class="dv">1</span><span class="fu">#</span>) w_s5dV;</a>
<a class="sourceLine" id="cb5-9" title="9">        <span class="dv">0</span><span class="fu">#</span> <span class="ot">-&gt;</span> (<span class="fu">#</span> w_s5dV, lvl1_r5jV <span class="fu">#</span>)</a>
<a class="sourceLine" id="cb5-10" title="10">      }</a>
<a class="sourceLine" id="cb5-11" title="11">end <span class="dt">Rec</span> }</a>
<a class="sourceLine" id="cb5-12" title="12"></a>
<a class="sourceLine" id="cb5-13" title="13"><span class="co">-- RHS size: {terms: 12, types: 29, coercions: 0, joins: 0/0}</span></a>
<a class="sourceLine" id="cb5-14" title="14"><span class="ot">main1 ::</span> <span class="dt">State</span><span class="fu">#</span> <span class="dt">RealWorld</span> <span class="ot">-&gt;</span> (<span class="fu">#</span> <span class="dt">State</span><span class="fu">#</span> <span class="dt">RealWorld</span>, () <span class="fu">#</span>)</a>
<a class="sourceLine" id="cb5-15" title="15">main1</a>
<a class="sourceLine" id="cb5-16" title="16">  <span class="fu">=</span> \ (<span class="ot">s_X3Bw ::</span> <span class="dt">State</span><span class="fu">#</span> <span class="dt">RealWorld</span>) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb5-17" title="17">      <span class="kw">case</span> <span class="fu">$</span>w<span class="fu">$</span>scountdown <span class="dv">10</span><span class="fu">#</span> s_X3Bw <span class="kw">of</span> { (<span class="fu">#</span> ipv_a3z9, ipv1_a3za <span class="fu">#</span>) <span class="ot">-&gt;</span></a>
<a class="sourceLine" id="cb5-18" title="18">      (<span class="fu">#</span> ipv_a3z9,</a>
<a class="sourceLine" id="cb5-19" title="19">         <span class="kw">case</span> ipv1_a3za <span class="kw">of</span> { (a1_a3y4, ds2_a3y5) <span class="ot">-&gt;</span> a1_a3y4 } <span class="fu">#</span>)</a>
<a class="sourceLine" id="cb5-20" title="20">      }</a></code></pre></div>
<p>Whew! We’re back to the speedy program we started with. <code>-fspecialise</code> has done the hard work of transforming our <em>abstract code</em> into <em>fast code</em> for us — exactly as a good compiler should.</p>
<h2 id="whats-going-on">What’s Going On?</h2>
<p>It’s amazing how drastic the differences are in the generated code, just from flipping a switch!</p>
<p>Before we can discuss exactly how this transformation helps, we need to first go over some details of how GHC implements a few source-level Haskell features. The first is <em>dictionaries</em>, which are how typeclass dispatch works.</p>
<h3 id="dictionaries">Dictionaries</h3>
<p>Consider the following program in source-level Haskell:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">class</span> <span class="dt">Eq</span> a <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="ot">  (==) ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb6-3" title="3"></a>
<a class="sourceLine" id="cb6-4" title="4"><span class="kw">instance</span> <span class="dt">Eq</span> () <span class="kw">where</span></a>
<a class="sourceLine" id="cb6-5" title="5">  (<span class="fu">==</span>) _ _ <span class="fu">=</span> <span class="dt">True</span></a>
<a class="sourceLine" id="cb6-6" title="6"></a>
<a class="sourceLine" id="cb6-7" title="7"><span class="ot">equate ::</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb6-8" title="8">equate a1 a2 <span class="fu">=</span> a1 <span class="fu">==</span> a2</a>
<a class="sourceLine" id="cb6-9" title="9"></a>
<a class="sourceLine" id="cb6-10" title="10"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb6-11" title="11">main <span class="fu">=</span> <span class="fu">print</span> <span class="fu">$</span> equate () ()</a></code></pre></div>
<p>Internally, GHC will generate the equivalent program:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">data</span> <span class="dt">Eq</span> a <span class="fu">=</span> <span class="dt">Eq</span>  <span class="co">-- #1</span></a>
<a class="sourceLine" id="cb7-2" title="2">  (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>)</a>
<a class="sourceLine" id="cb7-3" title="3"></a>
<a class="sourceLine" id="cb7-4" title="4"><span class="ot">(==) ::</span> <span class="dt">Eq</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></a>
<a class="sourceLine" id="cb7-5" title="5">(<span class="fu">==</span>) dEq&#39;a <span class="fu">=</span>  <span class="co">-- #2</span></a>
<a class="sourceLine" id="cb7-6" title="6">  <span class="kw">case</span> dEq&#39;a <span class="kw">of</span></a>
<a class="sourceLine" id="cb7-7" title="7">    <span class="dt">Eq</span> eqMethod <span class="ot">-&gt;</span> eqMethod</a>
<a class="sourceLine" id="cb7-8" title="8"></a>
<a class="sourceLine" id="cb7-9" title="9"><span class="ot">eqUnit ::</span> <span class="dt">Eq</span> ()  <span class="co">-- # 3</span></a>
<a class="sourceLine" id="cb7-10" title="10">eqUnit <span class="fu">=</span> <span class="dt">Eq</span></a>
<a class="sourceLine" id="cb7-11" title="11">  (\_ _ <span class="ot">-&gt;</span> <span class="dt">True</span>)</a>
<a class="sourceLine" id="cb7-12" title="12"></a>
<a class="sourceLine" id="cb7-13" title="13"><span class="ot">equate ::</span> <span class="dt">Eq</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span>  <span class="co">-- #4</span></a>
<a class="sourceLine" id="cb7-14" title="14">equate dEq&#39;a a1 a2 <span class="fu">=</span> (<span class="fu">==</span>) dEq&#39;a a1 a2  <span class="co">-- #5</span></a>
<a class="sourceLine" id="cb7-15" title="15"></a>
<a class="sourceLine" id="cb7-16" title="16"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb7-17" title="17">main <span class="fu">=</span> <span class="fu">print</span> <span class="fu">$</span> equate eqUnit () ()  <span class="co">-- #6</span></a></code></pre></div>
<p>Notably, the following changes occur:</p>
<ol type="1">
<li>The <code>class Eq a</code> is transformed into <code>data Eq a</code>, with each class method becoming a field.</li>
<li>The class method <code>(==)</code> receives a new <code>Eq a</code> parameter, and becomes a function which pattern matches on it.</li>
<li>The <code>instance Eq ()</code> becomes a top-level declaration of an <code>Eq ()</code> value.</li>
<li>The <code>Eq a</code> <em>constraint</em> on <code>equate</code> becomes a <em>parameter</em> of the new <code>Eq a</code> datatype.</li>
<li>The usage of <code>(==)</code> in <code>equate</code> receives the new <code>dEq'a</code> parameter.</li>
<li>The usage of <code>equate</code> at type <code>a ~ ()</code> in <code>main</code> receives the new top-level <code>eqUnit :: Eq ()</code> value as an argument.</li>
</ol>
<p>We call the values <code>eqUnit</code> and <code>dEq'a</code> <em>dictionaries</em>. More precisely, a dictionary is any value whose type is a data type corresponding to a typeclass. Dictionaries do not exist in source-level Haskell, only in the generated Core. In real Core, dictionaries have names that start with <code>$d</code>, but we’ll omit the leading <code>$</code> today, so we don’t get it confused with the <code>($)</code> operator.</p>
<p>From all of this that we see that, under the hood, <code>class</code> definitions are just <code>data</code> definitions, and that constraints are just invisible parameters.</p>
<h3 id="case-of-known-constructor">Case of Known Constructor</h3>
<p>Consider the following program:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb8-1" title="1">blah <span class="fu">=</span></a>
<a class="sourceLine" id="cb8-2" title="2">  <span class="kw">case</span> <span class="dt">True</span> <span class="kw">of</span></a>
<a class="sourceLine" id="cb8-3" title="3">    <span class="dt">True</span>  <span class="ot">-&gt;</span> foo</a>
<a class="sourceLine" id="cb8-4" title="4">    <span class="dt">False</span> <span class="ot">-&gt;</span> bar</a></code></pre></div>
<p>Because we’re scrutinizing on a constant value here, the result of this expression must always be <code>foo</code>. As such, it’s safe to replace the entire pattern match expression with <code>foo</code>:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb9-1" title="1">blah <span class="fu">=</span> foo</a></code></pre></div>
<p>This transformation is known as the <em>case of known constructor</em> optimization. While humans would never write such a thing by hand, expressions like these often come up as the result of other optimizing transformations.</p>
<h3 id="rewrite-rules">Rewrite Rules</h3>
<p>One final thing to discuss is GHC’s term rewriting mechanism, known as <em>rewrite rules</em>.</p>
<p>Rewrite rules are little statements that say “<em>this thing</em> can be written as <em>that thing</em>.” Whenever GHC encounters <em>this thing</em>, it will duly rewrite it as <em>that thing</em>. The motivating use case is to allow library authors to implement domain-specific optimizations — such as ensuring composing functions don’t generate intermediate structures. You might have heard of “list fusion,” which is implemented via rewrite rules.</p>
<p>Rewrite rules must preserve the type of the expression, but besides that are free to do anything they’d like. Just as an example, we can write a program which prints <code>hello world</code> seemingly from nowhere:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb10-1" title="1"><span class="ot">{-# RULES</span></a>
<a class="sourceLine" id="cb10-2" title="2"><span class="ot">  &quot;it&#39;s magic!&quot;</span></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="ot">    pure () = putStrLn &quot;hello world&quot;</span></a>
<a class="sourceLine" id="cb10-4" title="4"><span class="ot">  #-}</span></a>
<a class="sourceLine" id="cb10-5" title="5"></a>
<a class="sourceLine" id="cb10-6" title="6"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb10-7" title="7">main <span class="fu">=</span> <span class="fu">pure</span> ()</a></code></pre></div>
<p>Compiling this with <code>-O0</code> won’t print any message when run, but will print <code>hello world</code> when compiled with <code>-O</code>. Spooky!</p>
<p>When <code>-XTypeApplications</code> is enabled, rewrite rules are allowed to match on types too! For example, the following program will print <code>2 1 1</code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb11-1" title="1"><span class="ot">{-# LANGUAGE AllowAmbiguousTypes #-}</span></a>
<a class="sourceLine" id="cb11-2" title="2"><span class="ot">{-# LANGUAGE RankNTypes          #-}</span></a>
<a class="sourceLine" id="cb11-3" title="3"><span class="ot">{-# LANGUAGE TypeApplications    #-}</span></a>
<a class="sourceLine" id="cb11-4" title="4"></a>
<a class="sourceLine" id="cb11-5" title="5"><span class="ot">magic ::</span> <span class="kw">forall</span> b a<span class="fu">.</span> a <span class="ot">-&gt;</span> a</a>
<a class="sourceLine" id="cb11-6" title="6">magic <span class="fu">=</span> <span class="fu">id</span></a>
<a class="sourceLine" id="cb11-7" title="7"><span class="ot">{-# NOINLINE magic #-}</span></a>
<a class="sourceLine" id="cb11-8" title="8"></a>
<a class="sourceLine" id="cb11-9" title="9"><span class="ot">{-# RULES &quot;it&#39;s magic!&quot;</span></a>
<a class="sourceLine" id="cb11-10" title="10"><span class="ot">      forall (a :: Int).</span></a>
<a class="sourceLine" id="cb11-11" title="11"><span class="ot">        magic @String a = a + 1</span></a>
<a class="sourceLine" id="cb11-12" title="12"><span class="ot">      #-}</span></a>
<a class="sourceLine" id="cb11-13" title="13"></a>
<a class="sourceLine" id="cb11-14" title="14"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb11-15" title="15">main <span class="fu">=</span> <span class="kw">do</span></a>
<a class="sourceLine" id="cb11-16" title="16">  <span class="fu">print</span> <span class="fu">$</span> magic <span class="fu">@</span><span class="dt">String</span> (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb11-17" title="17">  <span class="fu">print</span> <span class="fu">$</span> magic <span class="fu">@</span><span class="dt">Bool</span>   (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>)</a>
<a class="sourceLine" id="cb11-18" title="18">  <span class="fu">print</span> <span class="fu">$</span> magic <span class="fu">@</span><span class="dt">String</span> (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Integer</span>)</a></code></pre></div>
<p>Of course, you shouldn’t abuse rewrite rules like this — make sure any rules you write are just more efficient versions of an equivalent program — but it’s helpful to demonstrate what’s going on.</p>
<p>Internally, GHC uses lots of rewrite rules itself! All of its constant-folding (e.g. replacing <code>2 + 3</code> with <code>5</code> at compile time) is done via rewrite rules, which helps separate that logic from the main compiler.</p>
<h2 id="specialization">Specialization</h2>
<p>So with all of that background information out of the way, we’re finally ready to talk about how the specializer works.</p>
<p>Recall our our original <code>mtl</code> program, transformed so it has its dictionaries explicitly passed:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb12-1" title="1"><span class="ot">countdown ::</span> <span class="dt">Monad</span> m <span class="ot">-&gt;</span> <span class="dt">MonadState</span> <span class="dt">Int</span> m <span class="ot">-&gt;</span> m ()</a>
<a class="sourceLine" id="cb12-2" title="2"><span class="co">-- There is a `Monad m` constraint on `MonadState s m`, which is where this</span></a>
<a class="sourceLine" id="cb12-3" title="3"><span class="co">-- extra constraint comes from.</span></a>
<a class="sourceLine" id="cb12-4" title="4">countdown dMonad&#39;m dMonadState&#39;m <span class="fu">=</span> <span class="kw">do</span> dMonad&#39;m</a>
<a class="sourceLine" id="cb12-5" title="5">  v <span class="ot">&lt;-</span> get dMonadState&#39;m</a>
<a class="sourceLine" id="cb12-6" title="6">  <span class="kw">case</span> v <span class="kw">of</span></a>
<a class="sourceLine" id="cb12-7" title="7">    <span class="dv">0</span> <span class="ot">-&gt;</span> <span class="fu">pure</span> dMonad&#39;m ()</a>
<a class="sourceLine" id="cb12-8" title="8">    _ <span class="ot">-&gt;</span> <span class="kw">do</span> dMonad&#39;m</a>
<a class="sourceLine" id="cb12-9" title="9">      put dMonadState&#39;m <span class="fu">$</span> v <span class="fu">-</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb12-10" title="10">      countdown dMonad&#39;m dMonadState&#39;m</a>
<a class="sourceLine" id="cb12-11" title="11"></a>
<a class="sourceLine" id="cb12-12" title="12"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb12-13" title="13">main <span class="fu">=</span></a>
<a class="sourceLine" id="cb12-14" title="14">  S.evalStateT</a>
<a class="sourceLine" id="cb12-15" title="15">    (countdown</a>
<a class="sourceLine" id="cb12-16" title="16">      (dMonadStateT dMonadIO)</a>
<a class="sourceLine" id="cb12-17" title="17">      (dMonadStateStateT dMonadIO))</a>
<a class="sourceLine" id="cb12-18" title="18">    <span class="dv">10</span></a></code></pre></div>
<p>When <code>-fspecialise</code> is set, the specializer will look for any calls to polymorphic functions with all of their dictionaries saturated by “interesting” dictionaries. The dictionaries <code>dMonad'm</code> and <code>dMonadState'm</code> in <code>countdown</code> aren’t interesting, since they’re just opaque dictionary variables; we don’t know anything about them.</p>
<p>However, GHC notices that <code>countdown</code> is called with <code>m ~ StateT Int IO</code>, and that all of its dictionaries are statically known. As such, it emits a <em>specialized</em> version of <code>countdown</code>, monomorphized to <code>StateT Int IO ()</code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb13-1" title="1"><span class="ot">scountdown_StateT ::</span> <span class="dt">StateT</span> <span class="dt">Int</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb13-2" title="2">scountdown_StateT <span class="fu">=</span> <span class="kw">do</span> (dMonadStateT dMonadIO)</a>
<a class="sourceLine" id="cb13-3" title="3">  v <span class="ot">&lt;-</span> get (dMonadStateStateT dMonadIO)</a>
<a class="sourceLine" id="cb13-4" title="4">  <span class="kw">case</span> v <span class="kw">of</span></a>
<a class="sourceLine" id="cb13-5" title="5">    <span class="dv">0</span> <span class="ot">-&gt;</span> <span class="fu">pure</span> (dMonadStateT dMonadIO) ()</a>
<a class="sourceLine" id="cb13-6" title="6">    _ <span class="ot">-&gt;</span> <span class="kw">do</span> (dMonadStateT dMonadIO)</a>
<a class="sourceLine" id="cb13-7" title="7">      put (dMonadStateStateT dMonadIO) <span class="fu">$</span> v <span class="fu">-</span> <span class="dv">1</span></a>
<a class="sourceLine" id="cb13-8" title="8">      scountdown_StateT</a></code></pre></div>
<p>In addition, the specializer will emit a rewrite rule:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb14-1" title="1"><span class="ot">{-# RULES &quot;SPEC countdown @ (StateT Int IO)&quot;</span></a>
<a class="sourceLine" id="cb14-2" title="2"><span class="ot">      forall (dMonad&#39;m :: Monad (StateT Int IO))</span></a>
<a class="sourceLine" id="cb14-3" title="3"><span class="ot">             (dMonadState&#39;m :: MonadState Int (StateT Int IO)).</span></a>
<a class="sourceLine" id="cb14-4" title="4"><span class="ot">        countdown @(StateT Int IO) dMonad&#39;m dMonadState&#39;m =</span></a>
<a class="sourceLine" id="cb14-5" title="5"><span class="ot">          scountdown_StateT</span></a>
<a class="sourceLine" id="cb14-6" title="6"><span class="ot">      #-}</span></a></code></pre></div>
<p>This rewrite rule will find any call to countdown at <code>m ~ StateT Int IO</code>, ignore the dictionaries passed to it, and replace the entire expression with the specialized <code>scountdown_StateT</code> function.</p>
<p>In particular, this means that <code>main</code> becomes:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb15-1" title="1"><span class="ot">main ::</span> <span class="dt">IO</span> ()</a>
<a class="sourceLine" id="cb15-2" title="2">main <span class="fu">=</span> S.evalStateT scountdown_StateT <span class="dv">10</span></a></code></pre></div>
<p>The rule takes advantage of the fact that dictionaries are known to be consistent (all expressions for a dictionary of a given type eventually evaluate to the same record), so it can completely ignore its two dictionary arguments. However, in principle there’s <em>absolutely no reason</em> this same technique couldn’t be used to specialize on other, non-dictionary, arguments!</p>
<p>Notice now that <code>pure</code>, <code>get</code>, and the two do-blocks in <code>scountdown_StateT</code> are now called with interesting dictionaries, so <code>pure</code>, <code>get</code> and <code>&gt;&gt;=</code> can now all also be specialized at <code>StateT Int IO</code>.</p>
<p>Eventually the concrete dictionaries and corresponding specializations have propagated throughout the entire program. The optimizer can take advantage of two other properties now, namely that class methods were already transformed into pattern matches, and that all of the dictionaries are statically known. Which means, we have created several places in which we can now <em>case of known case!</em></p>
<p>For example, let’s consider the <code>get</code> in <code>countdown</code>. It now looks something like this:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb16-1" title="1">  v <span class="ot">&lt;-</span> <span class="kw">case</span> <span class="dt">MonadState</span> (<span class="dt">StateT</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> implOfPureForIO (s, s)) <span class="fu">...</span> <span class="kw">of</span></a>
<a class="sourceLine" id="cb16-2" title="2">         <span class="dt">MonadState</span> getMethod _ _ <span class="ot">-&gt;</span> getMethod</a></code></pre></div>
<p>which can obviously be simplified to</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb17-1" title="1">  v <span class="ot">&lt;-</span> <span class="dt">StateT</span> <span class="fu">$</span> \s <span class="ot">-&gt;</span> implOfPureForIO (s, s)</a></code></pre></div>
<p>This is already a great improvement! But it gets better, recall that we’re binding in the <code>StateT</code> monad, which in turn is calling bind in <code>IO</code>. But bind in <code>IO</code> is itself implemented as a pattern match, and so case-of-known-constructor applies there too!</p>
<p>The end result is that GHC spins for a while, alternatingly specializing, inlining, case-of-known-casing, and performing a few other optimizations. Each of these in turn opens up additional opportunities for the others to fire. After a few iterations of this, the resulting code is often <em>orders of magnitude</em> faster!</p>
<h2 id="coming-in-8.10.1">Coming in 8.10.1…</h2>
<p>Everything described above is how the compiler behaves today in GHC 8.6.5 (and has, since like 2007 or something.) However, when digging into the performance of my free monad library <a href="https://hackage.haskell.org/package/polysemy"><code>polysemy</code></a>, I noticed that code written against my library wasn’t benefiting from the specialization pass! As a result, my library was performing anywhere between 10x and 1000x <em>worse</em> than <code>mtl</code>, even though <em>the eventual code being run was identical to <code>mtl</code>.</em></p>
<p>Like our experiments above into <code>mtl</code>, I was paying a performance cost for abstraction, even though the concrete program was identical.</p>
<p>Some investigation by the indefatigable <a href="https://mpickering.github.io/">mpickering</a> pointed out that the specializer was failing to specialize. As it happens, the specializer is more than happy to optimize away dictionaries that are passed as the <em>first</em> non-type arguments to a function, but no others.</p>
<p>That means it will go home early if it runs into a function whose signature is of the form:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><a class="sourceLine" id="cb18-1" title="1"><span class="ot">foo ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="kw">forall</span> a<span class="fu">.</span> <span class="dt">Eq</span> a <span class="ot">=&gt;</span> <span class="fu">...</span></a></code></pre></div>
<p>Again, humans would never write such a thing, but the optimizer is more than happy to spit these things out. Additionally, code like this often shows up whenever you use a newtype to get around GHC’s annoying error that it “does not (yet) support impredicative polymorphism”.</p>
<p>Anyway, all of this is to say that in 8.10.1, the specialization pass is <a href="https://gitlab.haskell.org/ghc/ghc/merge_requests/668">now smart enough</a> to specialize functions like <code>foo</code>. As a result, we should see very real performance improvements in libraries like <code>polysemy</code> and <code>lens</code>, and, excitingly, <em>any programs which use them!</em></p>
<section class="footnotes">
<hr />
<ol>
<li id="fn1"><p>The meaning of the flags is — <code>-O</code>: enable optimizations; <code>-fno-specialise</code>: disable the specialization pass.<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p><code>-fspecialise</code> is included in <code>-O</code>.<a href="#fnref2" class="footnote-back">↩</a></p></li>
</ol>
</section>
        ]]>
      </content>
    </entry>
    <entry>
      <title>Announcing Polysemy</title>
      <id>blog/polysemy/index.html</id>
      <link href='blog/polysemy/index.html'/>
      <published>2019-04-10T17:33:00Z</published>
      <updated>2019-04-10T17:33:00Z</updated>

      <content type="html">
        <![CDATA[
        <p><a href="/blog/freer-yet-too-costly/">Just kidding.</a> Turns out I couldn’t put it down.</p>
<p>I want to announce my new library <a href="https://github.com/isovector/polysemy#readme"><code>polysemy</code></a> — it’s higher-order, no-boilerplate, zero-cost free monads.</p>
<p>I’ve been working nonstop on this for a few months now, so the commentary for what the heck is going on will come after a little vacation.</p>
<p>Stay tuned.</p>
        ]]>
      </content>
    </entry>
</feed>

