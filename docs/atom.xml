<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns='http://www.w3.org/2005/Atom' xmlns:g='http://base.google.com/ns/1.0'>
  <title>Reasonably Polymorphic</title>
  <updated>2022-02-27T13:08:00Z</updated>
  <author><name>Sandy Maguire</name></author>
  <id>http://reasonablypolymorphic.com</id>
  <link rel='self' href='atom.xml'/>

    <entry>
      <title>Review: A Very Elementary Introduction to Sheaves</title>
      <id>blog/review-sheafs/index.html</id>
      <link href='blog/review-sheafs/index.html'/>
      <published>2022-02-27T13:08:00Z</published>
      <updated>2022-02-27T13:08:00Z</updated>

      <content type="html">
        <![CDATA[
        <pre><code>{-# OPTIONS --type-in-type #-}

module Blog.sheafs where

open import Data.Integer hiding (_&lt;_)
open import Data.Integer.Properties using (*-zeroˡ; ≤-reflexive; ≤-trans)
open import Data.Vec hiding (restrict; reverse)
open import Categories
open import Category.LIN
open import Category.SET
open import Category.AGRP
open import Category.MyFunctor
import Relation.Binary.PropositionalEquality as Eq

open Eq using (_≡_; cong; sym; refl)
open LinMap</code></pre>
<p>A while back I reviewed some paper (maybe codata? — too lazy to check) and came away thinking “I should learn more about presheaves.” The first paper I found is <a href="https://arxiv.org/pdf/2202.01379.pdf">A Very Elementary Introduction to Sheaves</a> by Mark Agrios, and mildly interestingly, was published less than three weeks ago.</p>
<p>The paper is called “very elementary,” and in the first sentence states it “is a very non-rigorous, loose, and extremely basic introduction to sheaves,” and it delivers on these promises. There is a section on metaphorically what a sheaf is, and then two somewhat-worked examples.</p>
<p>After reading through the paper, I feel like I have a very rough idea of what a sheaf is, and thought that this would be an excellent opportunity to flex my category theory muscles. That is, can I correctly generalize from these two examples to a solid category theoretical definition of a sheaf? I’m not sure, but this is a unique opportunity, so it’s worth a shot.</p>
<h2 id="the-metaphor">The Metaphor</h2>
<p>The central metaphor of the paper is that a sheaf enriches some mathematical structure, much like a garden enriches a plot of dirt. There are lots of gardens you could make on a plot of dirt, and then you can harvest things from them. I guess this makes sense to the author, but it doesn’t particularly help me. I suspect this is an example of the monad tutorial fallacy in the wild: after thinking really hard about an idea for a while, the author came up with a metaphor that really works for them. But, this metaphor is more an artifact of their thinking process than it is descriptive of the idea itself. Anyway, either way, I wasn’t able to extract much meaning here.</p>
<h2 id="example-graphs">Example: Graphs</h2>
<p>We can build a (pre-?)sheaf over a graph. By playing fast and loose with our types like mathematicians are so wont to do, we can model the edge <span class="math inline">\(e_{ij} : V_i \to V_j\)</span> in a graph as an “intersection of the nodes it connects.” The paper writes <span class="math inline">\(e_{ij} &lt; v_i, v_j\)</span>. I’m not super sure what that means, but I think it’s saying that given some graph <span class="math inline">\(G = (V, E)\)</span>, we can say <span class="math inline">\(e_{ij} \subseteq v_i \cup v_j\)</span>? Except that this doesn’t typecheck, since <code>v_i</code> is an element of a set, not a set itself. I don’t know.</p>
<p>Anyway, the important thing here seems to be that there is a preorder between edges and vertices. So let’s quickly define a <code>Preorder</code>:</p>
<pre><code>record Preorder : Set where
  field
    Carrier : Set
    _&lt;_ : Carrier → Carrier → Set
    &lt;-refl : (a : Carrier) → a &lt; a
    &lt;-trans : {a b c : Carrier} → a &lt; b → b &lt; c → a &lt; c</code></pre>
<p>and then just forget about the whole graph thing, because I am not convinced it is a meaningful presentation. Instead, we’ll cheat, and just build exactly the object we want to discuss.</p>
<pre><code>data Ex : Set where
  v1  : Ex
  v2  : Ex
  e12 : Ex</code></pre>
<p>corresponding to this rather boring graph:</p>
<pre class="quiver"><code>\[\begin{tikzcd}
  v1 &amp;&amp; {} &amp;&amp; v2
  \arrow[&quot;e12&quot;&#39;, from=1-1, to=1-5]
\end{tikzcd}\]</code></pre>
<p>We can then build a <code class="sourceCode agda">Preorder</code> on <code class="sourceCode agda">Ex</code> with explicit cases for <code class="sourceCode agda">e12</code> being less than its vertices:</p>
<pre><code>data Ex&lt; : Ex → Ex → Set where
  e12&lt;v1 : Ex&lt; e12 v1
  e12&lt;v2 : Ex&lt; e12 v2</code></pre>
<p>and two cases to satisfy the preorder laws:</p>
<pre><code>  ex&lt;-refl : (x : Ex) → Ex&lt; x x</code></pre>
<p>and then mechanically hook everything up:</p>
<pre><code>module _ where
  open Preorder
  ex-preorder : Preorder
  ex-preorder .Carrier = Ex
  ex-preorder ._&lt;_ = Ex&lt;
  ex-preorder .&lt;-refl = ex&lt;-refl
  ex-preorder .&lt;-trans e12&lt;v1 (ex&lt;-refl .v1) = e12&lt;v1
  ex-preorder .&lt;-trans e12&lt;v2 (ex&lt;-refl .v2) = e12&lt;v2
  ex-preorder .&lt;-trans (ex&lt;-refl _) e12&lt;v1 = e12&lt;v1
  ex-preorder .&lt;-trans (ex&lt;-refl _) e12&lt;v2 = e12&lt;v2
  ex-preorder .&lt;-trans (ex&lt;-refl x) (ex&lt;-refl _) = ex&lt;-refl x</code></pre>
<p>The paper goes on to say we have some sheaf <code>F</code>, which maps <code class="sourceCode agda">Ex</code>s to “just about anything,” this codomain being called the <em>stalk.</em> For now, let’s assume it’s to <code class="sourceCode agda"><span class="dt">Set</span></code>.</p>
<p>Furthermore, the sheaf <code>F</code> also has a “second mechanism,” which in our example maps an edge <span class="math inline">\(e_{ij} : v_i \to v_j\)</span> to two functions:</p>
<p><span class="math display">\[
F_{v_i;e_{ij}} : F(v_i) \to F(e_{ij}) \\
F_{v_j;e_{ij}} : F(v_j) \to F(e_{ij})
\]</span></p>
<p>This is where some of the frustration in only being given examples comes in. Why are these in the definition of a sheaf? The only thing that could possibly make any sense to me is that this comes from a more general construction:</p>
<pre class="text"><code>restrict : (x y : Ex) → x &lt; y → Stalk y → Stalk x</code></pre>
<p>which states we have a mapping from <span class="math inline">\(F(y)\)</span> to <span class="math inline">\(F(x)\)</span> if and only if we have <span class="math inline">\(x &lt; y\)</span>. These <code>restrict</code> things are called <em>restriction maps</em>.</p>
<p>What’s further confusing is the following point:</p>
<blockquote>
<p>Since each stalk is a vector space, it is natural to have our restriction maps be linear transformations described by matrices.</p>
</blockquote>
<p>Why linear transformations, and not just arbitrary functions? When I hear “linear transformation” I think homomorphism, or more probably, morphism in some category. Which then probably means the <code>Stalk</code> isn’t a function to <code class="sourceCode agda"><span class="dt">Set</span></code>, it’s a mapping into a category.</p>
<p>OK, so that all seems straightforward enough. Let’s try to formalize it.</p>
<pre><code>module Sheaf (pre : Preorder) (C : Category) where
  open Preorder pre
  open Category C

  record Sheaf : Set where
    field
      Stalk : Carrier → Obj
      restrict : {x y : Carrier} → x &lt; y → Stalk y ~&gt; Stalk x</code></pre>
<p>which seems reasonable. The paper now gives us a specific sheaf, with <code class="sourceCode agda">restrict</code> <code class="sourceCode agda">e12&lt;v1</code> being the linear map encoded by the matrix:</p>
<p><span class="math display">\[
\begin{bmatrix}
1 &amp; -1 \\
0 &amp; 2
\end{bmatrix}
\]</span></p>
<p>which we can write as a morphism in <code class="sourceCode agda">LIN</code> (the category of linear algebra, with objects as vector spaces, and morphisms as linear maps):</p>
<!--
```
module _ where
  open Category LIN
  open Sheaf ex-preorder LIN
  open Sheaf.Sheaf

  postulate
    trustMe : ∀ {A : Set} {a b : A} → a ≡ b
    sorry : ∀ {A : Set} → A
```
-->
<pre><code>  e12~&gt;v1 : 2 ~&gt; 2
  e12~&gt;v1 .linmap (x ∷ y ∷ []) =
    (x - y)   ∷
    (+ 2 * y) ∷
             []
  e12~&gt;v1 .preserves-+ u v = trustMe
  e12~&gt;v1 .preserves-* a v = trustMe</code></pre>
<p>and <code class="sourceCode agda">restrict</code> <code class="sourceCode agda">e12&lt;v2</code> being the linear map encoded by the matrix:</p>
<p><span class="math display">\[
\begin{bmatrix}
3 &amp; 1 &amp; -1 \\
2 &amp; 0 &amp; 2
\end{bmatrix}
\]</span></p>
<p>written as:</p>
<pre><code>  e12~&gt;v2 : 3 ~&gt; 2
  e12~&gt;v2 .linmap (x ∷ y ∷ z ∷ []) =
    (+ 3 * x + y - z)   ∷
    (+ 2 * x + + 2 * z) ∷
                       []
  e12~&gt;v2 .preserves-+ u v = trustMe
  e12~&gt;v2 .preserves-* a v = trustMe</code></pre>
<p>Thus, we can finally build the example <code>Sheaf</code>:</p>
<pre><code>  ex : Sheaf
  ex .Stalk v1  = 2
  ex .Stalk v2  = 3
  ex .Stalk e12 = 2
  ex .restrict e12&lt;v1 = e12~&gt;v1
  ex .restrict e12&lt;v2 = e12~&gt;v2
  ex .restrict (ex&lt;-refl z) = id</code></pre>
<p>What’s with the <code class="sourceCode agda">Stalk</code> of <code class="sourceCode agda">v1</code> being 2, you might ask? Remember, the stalk is an object in some category, in this case <code class="sourceCode agda">LIN</code>. Objects in <code class="sourceCode agda">LIN</code> are natural numbers, corresponding to the length of vectors.</p>
<h3 id="sections-and-global-sections">Sections and Global Sections</h3>
<p>Here’s where our categorical generalization of the paper goes a bit haywire. The paper defines a <em>section</em> as picking an element from each <code class="sourceCode agda">Stalk</code> of the sheaf. He picks, for example:</p>
<p><span class="math display">\[
\begin{bmatrix}
2 \\ 1
\end{bmatrix}
\in \text{Stalk } v1
\]</span></p>
<p><span class="math display">\[
\begin{bmatrix}
3 \\ -1 \\ 0
\end{bmatrix}
\in \text{Stalk } v2
\]</span></p>
<p>and</p>
<p><span class="math display">\[
\begin{bmatrix}
1 \\ -1
\end{bmatrix}
\in \text{Stalk } e12
\]</span></p>
<p>which is all fine and dandy, except that when we categorize, our objects no longer have internal structure. Fortunately, we can use “generalized elements,” a.k.a., morphisms out of the <code class="sourceCode agda">terminal</code> object.</p>
<!--
```
module BadSections
         {pre : Preorder}
         {C : Category}
         (term : HasTerminal C)
         (sheaf : Sheaf.Sheaf pre C) where
  open HasTerminal term
  open Preorder pre
  open Sheaf.Sheaf sheaf
  open Category C
```
-->
<pre><code>  Section : Carrier → Set
  Section c = terminal ~&gt; Stalk c</code></pre>
<p>That is, a <code class="sourceCode agda">Section</code> is a mapping from every element in the <code class="sourceCode agda">Preorder</code> to a generalized element of its <code class="sourceCode agda">Stalk</code>. We can evaluate a <code class="sourceCode agda">Section</code> by checking the commutativity of all <code class="sourceCode agda">restrict</code>s. That is, we’d like the following diagram to commute:</p>
<pre class="quiver"><code>\[\begin{tikzcd}
  &amp;&amp; {0} \\
  \\
  {\text{Stalk } v_1} &amp;&amp;&amp;&amp; {\text{Stalk } e_{12}}
  \arrow[&quot;{\text{Section }v_1}&quot;&#39;, from=1-3, to=3-1]
  \arrow[&quot;{\text{Section } e_{12}}&quot;, from=1-3, to=3-5]
  \arrow[&quot;{\text{restrict } e_{12}&lt;v_1}&quot;&#39;, from=3-1, to=3-5]
\end{tikzcd}\]</code></pre>
<p>Doing this in Agda is hard because it wants lots of dumb arithmetic proofs, so instead we’ll make ourselves content with some by-hand math:</p>
<p><span class="math display">\[
r \circ S v1
=  \begin{bmatrix}
      1 &amp; -1 \\
      0 &amp; 2
    \end{bmatrix}
    \begin{bmatrix}
      2 \\ 1
    \end{bmatrix}
=  \begin{bmatrix}
      1 \\
      2
    \end{bmatrix}
\neq
    \begin{bmatrix}
    1 \\ -1
    \end{bmatrix}
\]</span></p>
<p>So, our chosen <code class="sourceCode agda">Section</code> doesn’t commute. That is, it doesn’t respect the global equalities, thus it is not a <em>global section.</em> Sounds like something worth formalizing:</p>
<pre><code>  record GlobalSection : Set where
    field
      section : forall (c : Carrier) → Section c
      commutes
        : {x y : Carrier}
        → (x&lt;y : x &lt; y)
        → restrict x&lt;y ∘ section y ≈ section x</code></pre>
<p>All that’s left is to find a <code class="sourceCode agda">GlobalSection</code> of our weird graph category:</p>
<!--
```
module BadEx where
  open Preorder
  open Category LIN
  open Sheaf ex-preorder LIN
  open Sheaf.Sheaf
```
-->
<p>– TODO(sandy): make this cleaner</p>
<p>Unfortunately, this formalization doesn’t quite work out; there are no arrows out of <code class="sourceCode agda">terminal</code>:</p>
<pre><code>  boring-arrows
      : (f : 0 ~&gt; 1)
      → (x : Vec ℤ 0)
      → f .linmap x ≡ + 0 ∷ []
  boring-arrows f [] with f .linmap [] in eq
  ... | x ∷ [] rewrite sym eq =
    begin
      f .linmap []                 ≡⟨⟩
      f .linmap (map (+ 0 *_) [])  ≡⟨ f .preserves-* (+ 0) _ ⟩
      map (+ 0 *_) (f .linmap [])  ≡⟨ cong (map (+ 0 *_)) eq ⟩
      map (+ 0 *_) (x ∷ [])        ≡⟨⟩
      (+ 0 * x) ∷ []               ≡⟨ cong (_∷ []) (*-zeroˡ +0) ⟩
      +0 ∷ []
    ∎
    where open Eq.≡-Reasoning</code></pre>
<p>So, that’s no good. We’ve modeled <code class="sourceCode agda">Section</code> incorrectly, as the generalized element approach doesn’t work, since we are unable to follow the example.</p>
<p>What are some other ways to go from an <code class="sourceCode agda">Obj</code> to a <code class="sourceCode agda"><span class="dt">Set</span></code>? Maybe we could try modeling this as a functor to <code class="sourceCode agda">SET</code> instead:</p>
<!--
```
module _ where
  open _=>_
  open import Relation.Binary.PropositionalEquality using (refl)
```
-->
<pre><code>  ex-func : LIN =&gt; SET
  ex-func .F-Obj x = Vec ℤ x
  ex-func .F-map f = f .linmap
  ex-func .F-map-id _ _ = refl
  ex-func .F-map-∘ g f a = refl</code></pre>
<p>And we can try again with <code>Section</code>s:</p>
<p>and then we can say a <code>Section</code> is an element of the action of <code class="sourceCode agda">Func</code>:</p>
<!--
```
import Category.MyFunctor
module Sections
         {pre : Preorder}
         {C : Category}
         (Func : C Category.MyFunctor.=> SET)
         (sheaf : Sheaf.Sheaf pre C) where
  open Preorder pre
  open Sheaf.Sheaf sheaf
  open Category.MyFunctor._=>_ Func
  open Category SET
  open import Relation.Binary.PropositionalEquality using (_≡_)
```
-->
<pre><code>  Section : Carrier → Set
  Section c = F-Obj (Stalk c)</code></pre>
<p>and a <code>GlobalSection</code>, which recall, is a globally-coherent assignment of sections:</p>
<pre><code>  record GlobalSection : Set where
    field
      section : forall (c : Carrier) → Section c
      commutes
        : {x y : Carrier}
        → (x&lt;y : x &lt; y)
        → F-map (restrict x&lt;y) (section y) ≡ section x</code></pre>
<!--
```
module GoodEx where
  open Sheaf ex-preorder LIN
  open Sheaf.Sheaf ex
  open Sections ex-func ex
  open GlobalSection
  open Category.MyFunctor._=>_ ex-func
```
-->
<pre><code>  soln : GlobalSection
  soln .section v1 = + 2 ∷ + 1 ∷ []
  soln .section v2 = -[1+ 1 ] ∷ + 10 ∷ + 3 ∷ []
  soln .section e12 = + 1 ∷ + 2 ∷ []
  soln .commutes e12&lt;v1 = refl
  soln .commutes e12&lt;v2 = refl
  soln .commutes (ex&lt;-refl _) = refl</code></pre>
<p>Sure enough, this was a global section:</p>
<p><span class="math display">\[
\begin{bmatrix}
2 \\ 1
\end{bmatrix}
\in \text{Stalk } v1
\]</span></p>
<p><span class="math display">\[
\begin{bmatrix}
-2 \\ 10 \\ 3
\end{bmatrix}
\in \text{Stalk } v2
\]</span></p>
<p>and</p>
<p><span class="math display">\[
\begin{bmatrix}
1 \\ 2
\end{bmatrix}
\in \text{Stalk } e12
\]</span></p>
<h2 id="example-continuous-intervals">Example: Continuous Intervals</h2>
<p>The paper presents a second example as well. Maybe it’s just that I’m less well-versed in the subject matter, but this example feels significantly more incoherent than the first. I tried to work through it, and the formalization above was sufficiently powerful to do what I needed, but I didn’t understand the example or what it was trying to accomplish. There was some Abelian group stuff that never actually got used.</p>
<p>Rather than clean this section up, I’m instead going to spend the time before my publication deadline writing about what I learned about pre-sheafs after hitting the wall, and asking for help.</p>
<h2 id="extracuricular-presheafs">Extracuricular Presheafs</h2>
<p>So let’s talk about what all of this sheaf business above is trying to do. The ever helpful Reed Mullanix came to my rescue with a few helpful intuitions. To paraphrase him (if there are any mistakes in the following, they are my mistakes, not his):</p>
<blockquote>
<p>Think about a sensor network. You have some physical space, with a series of sensors attached in specific places. Maybe you have a microphone in the hallway, and a camera at the front door, and a thermometer in the bedroom. Each of these sensors is <em>locally correct</em>, that is, we can be reasonably sure that if the thermometer says 37C, it is in fact 37C.</p>
<p>A presheaf is a mapping from this collection of sensors to a world in which we can reason about the total space. For example, we might want to get an idea of what’s going on in the basement, where we have no sensors, but which is part of our house nevertheless.</p>
<p>And a global section over that presheaf is a globally consistent take on the system. It’s some mapping into the hypothesis space that <em>agrees with all of the measurements.</em> If we know it’s 37C in the bedroom, we’re probably not going to see snow in the front-door camera.</p>
</blockquote>
<p>Okay, so what’s all this preorder stuff about? I think it’s actually just a poor man’s category. We can lift any preorder into a category by considering the <code>&lt;</code> relationship to be a morphism:</p>
<pre><code>module PreorderToCategory (P : Preorder) where
  open Preorder P
  open Category

  open import Data.Unit using (⊤; tt)

  cat : Category
  cat .Obj = Carrier
  cat ._~&gt;_ = _&lt;_
  cat ._≈_ f g = ⊤
  cat .≈-equiv = sorry
  cat .id {A = A} = &lt;-refl A
  cat ._∘_ g f = &lt;-trans f g
  cat .∘-cong = λ _ _ → tt
  cat .id-r f = tt
  cat .id-l f = tt
  cat .∘-assoc h g f = tt</code></pre>
<p>and now that we have a <code class="sourceCode agda">Category</code>, we can avoid the whole <code class="sourceCode agda">Sheaf</code> / <code class="sourceCode agda">GlobalSection</code> by giving a functor into <code class="sourceCode agda">SET</code>. Well, almost, because <code class="sourceCode agda">restrict</code> goes the opposite direction. So instead, we can build an opposite category:</p>
<pre><code>module Op (C : Category) where
  open Category

  data OpArr : Obj C → Obj C → Set where
    reverse : {X Y : Obj C} → C [ X , Y ] → OpArr Y X

  op : Category
  op .Obj = C .Obj
  op ._~&gt;_ = OpArr
  op ._≈_ (reverse f) (reverse g) = C ._≈_ f g
  op .≈-equiv {A} {B} = sorry
  op .id = reverse (C .id)
  op ._∘_ (reverse g) (reverse f) = reverse (C ._∘_ f g)
  op .∘-cong = sorry
  op .id-r (reverse f) = C .id-l f
  op .id-l (reverse f) = C .id-r f
  op .∘-assoc (reverse h) (reverse g) (reverse f) =
    setoid C .isEquivalence .S.IsEquivalence.sym (C .∘-assoc f g h)
    where
      open import Relation.Binary.Bundles using (Setoid)
      open Setoid using (isEquivalence)
      import Relation.Binary.Structures as S</code></pre>
<p>Now, we can express a presheaf as a functor:</p>
<pre><code>module _ where
  open import Category.MyFunctor
  open Op

  Presheaf : Category → Set
  Presheaf C = op C =&gt; SET</code></pre>
<p>or our specific example from earlier:</p>
<pre><code>module _ where
  open PreorderToCategory ex-preorder
  open _=&gt;_
  open import Data.Nat using (ℕ)
  open Op

  Z : ℕ → Set
  Z = Vec ℤ

  ex&#39; : Presheaf cat
  ex&#39; .F-Obj v1 = Z 2
  ex&#39; .F-Obj v2 = Z 3
  ex&#39; .F-Obj e12 = Z 2
  ex&#39; .F-map (reverse e12&lt;v1) = e12~&gt;v1 .linmap
  ex&#39; .F-map (reverse e12&lt;v2) = e12~&gt;v2 .linmap
  ex&#39; .F-map (reverse (ex&lt;-refl _)) a = a
  ex&#39; .F-map-id A a = refl
  ex&#39; .F-map-∘ (reverse e12&lt;v1) (reverse (ex&lt;-refl _)) a = refl
  ex&#39; .F-map-∘ (reverse e12&lt;v2) (reverse (ex&lt;-refl _)) a = refl
  ex&#39; .F-map-∘ (reverse (ex&lt;-refl _)) (reverse e12&lt;v1) a = refl
  ex&#39; .F-map-∘ (reverse (ex&lt;-refl _)) (reverse e12&lt;v2) a = refl
  ex&#39; .F-map-∘ (reverse (ex&lt;-refl _)) (reverse (ex&lt;-refl _)) a = refl</code></pre>
<p>which leaves only the question of what a <code>GlobalSection</code> is under this representation.</p>
<p>I got stumped on this one for a while too, but again, Reed to the rescue, who points out that in our preorder, <code>&lt;</code> corresponds to a “smaller” space. Thus, we want to find a mapping out of the biggest space, which corresponds to a top element in the order, or a terminal object in the category. The terminal object is going to be the “total space” in consideration (in our sensor example, eg.) and the functor laws will ensure consistency.</p>
<pre><code>GlobalSection
    : {C : Category}
    → (pre : Presheaf C)
    → (t : HasTerminal C)
    → Set
GlobalSection pre t =
  pre ._=&gt;_.F-Obj (t .HasTerminal.terminal)</code></pre>
<p>Unfortunately, this is a problem for our worked example — we don’t <em>have</em> a terminal object! But that’s OK, it’s easy to trivially construct one by just adding a top:</p>
<pre class="quiver"><code>\[\begin{tikzcd}
  &amp; terminal \\
  v1 &amp;&amp; v2 \\
  &amp; e12
  \arrow[from=3-2, to=2-1]
  \arrow[from=3-2, to=2-3]
  \arrow[from=2-3, to=1-2]
  \arrow[from=2-1, to=1-2]
\end{tikzcd}\]</code></pre>
<p>and by picking an object in <code class="sourceCode agda">SET</code> to map it to for our presheaf. There are some interesting choices here; we could just pick <code class="sourceCode agda">⊤</code>, which is interesting in how boring a choice it is. Such a thing trivially satisfies all of the requirements, but it doesn’t tell us much about the world. This is the metaphorical equivalent of explaining our sensors’ readings as “anything is possible!”</p>
<p>More interestingly, we could pick <code>F-Obj terminal</code> to be <code>ℤ2 × ℤ3 × ℤ2</code>, corresponding to the product of <code>F-Obj v1</code>, <code>F-Obj v2</code> and <code>F-Obj e12</code>. We can satisfy the functor laws by projecting from the <code>F-Obj term</code> down to one of its components. And, best of all, it gives us a place to stick the values from our worked example.</p>
<p>I’d love to code this up in more detail, but unfortunately I’m out of time. That’s the flaw of trying to get through one paper a week, the deadline is strict whether you’re ready for it or not.</p>
<p>This whole post is a literate Agda file. I’m currently in the process of writing an Agda blogging backend for the site, so hopefully if you come back in a week or so, everything here should be hyperlinked and interactive.</p>
        ]]>
      </content>
    </entry>
    <entry>
      <title>Automatic Ring Solving</title>
      <id>blog/ring-solving/index.html</id>
      <link href='blog/ring-solving/index.html'/>
      <published>2022-02-16T12:33:00Z</published>
      <updated>2022-02-16T12:33:00Z</updated>

      <content type="html">
        <![CDATA[
        <p>Today’s sorta-review is of <a href="https://github.com/oisdk/agda-ring-solver-report/blob/master/report.pdf">Automatically and Efficiently Illustrating Polynomial Equations in Agda</a> by <a href="https://doisinkidney.com/">Donnacha Oisin Kidney</a>. I say it’s sorta a review because I had to write some annoying proofs recently, and discovered that Agda has a ring solver that automates annoying proofs. For example, it can solve things like <code>(a + b) * (a + b) = a^2 + 2*a*b + b^2</code>, which is rather amazing if you think about it. I got curious about how this is possible, and came across AaEIPEiA, quickly skimmed it for the rough approach, and then decided to write my own ring solver. As a result, this post is certainly inspired by AaEIPiA, but my implementation is extremely naive compared to the one presented in the paper. Kidney’s paper is very good, and I apologize for not doing it justice here.</p>
<p>So, some background. Agda lets you write types that correspond to equalities, and values of those types are proofs of those equalities. For example, we can write the following type:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="ot">(</span>x <span class="ot">:</span> ℕ<span class="ot">)</span> <span class="ot">→</span> <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span> * <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span> ≡ <span class="ot">(</span>x * x<span class="ot">)</span> + <span class="ot">(</span><span class="dv">1</span> + <span class="dv">1</span><span class="ot">)</span> * x + <span class="dv">1</span></span></code></pre></div>
<p>You probably wouldn’t write this for its own sake, but it might come up as a lemma of something else you’re trying to prove. However, actually proving this equality is a huge amount of busywork, that takes forever, and isn’t actually interesting because we all know that this equality holds. For example, the proof might look something like this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>  begin</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>    <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span> * <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a>  ≡⟨ *-+-distrib <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span> x <span class="dv">1</span> ⟩</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a>    <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span> * x + <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span> * <span class="dv">1</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true"></a>  ≡⟨ cong <span class="ot">(\</span>φ <span class="ot">-&gt;</span> <span class="ot">((</span>x + <span class="dv">1</span><span class="ot">)</span> * x + φ<span class="ot">))</span> $ *-1-id-r <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span> ⟩</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true"></a>    <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span> * x + <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true"></a>  ≡⟨ cong <span class="ot">(\</span>φ <span class="ot">-&gt;</span> φ + <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">))</span> $ *-comm <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span> x ⟩</span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true"></a>    x * <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span> + <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true"></a>  ≡⟨ cong <span class="ot">(\</span>φ <span class="ot">-&gt;</span> φ + <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">))</span> $ *-+-distrib x x <span class="dv">1</span> ⟩</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true"></a>    <span class="ot">(</span>x * x + x * <span class="dv">1</span><span class="ot">)</span> + <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true"></a>  ≡⟨ ? ⟩</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true"></a>    <span class="co">-- kill me</span></span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true"></a>  ≡⟨ ? ⟩</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true"></a>    <span class="ot">(</span>x * x<span class="ot">)</span> + <span class="ot">(</span><span class="dv">1</span> + <span class="dv">1</span><span class="ot">)</span> * x + <span class="dv">1</span></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true"></a>  ∎</span></code></pre></div>
<p>It’s SO MUCH WORK to do <em>nothing!</em> This is not an interesting proof! A ring solver lets us reduce the above proof to:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>  begin</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>    <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span> * <span class="ot">(</span>x + <span class="dv">1</span><span class="ot">)</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>  ≡⟨ solve ⟩</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a>    <span class="ot">(</span>x * x<span class="ot">)</span> + <span class="ot">(</span><span class="dv">1</span> + <span class="dv">1</span><span class="ot">)</span> * x + <span class="dv">1</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>  ∎</span></code></pre></div>
<p>or, even more tersely:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>  solve</span></code></pre></div>
<p>So that’s the goal here. Automate stupid, boring proofs so that we as humans can focus on the interesting bits of the problem.</p>
<h2 id="i-dont-even-know-what-a-ring-is">I Don’t Even Know What a Ring Is</h2>
<p>Why is this called a ring solver? I don’t exactly know, but a ring is some math thing. My guess is that it’s the abstract version of an algebra containing addition and multiplication, with all the usual rules.</p>
<p>And looking at it, sure enough! A ring is a set with two monoids on it, one corresponding to addition, and the other to multiplication. Importantly, we require that multiplication distributes over addition.</p>
<p>Rings technically have additive inverses, but I didn’t end up implementing (or needing them.) However, I did require commutativity of both addition and multiplication — more on this later.</p>
<p>The ring laws mean that algebra works in the way we expect arithmetic to work. We can shuffle things around, and probably all have enough experience solving these sorts of problems with pen and paper. But what’s the actual algorithm here?</p>
<h2 id="how-do-you-solve-a-ring">How Do You Solve A Ring?</h2>
<p>At first blush, this sounds like a hard problem! It feels like we need to see if there’s a way to turn some arbitrary expression into some other arbitrary expression. And that is indeed true, but it’s made easier when you realize that polynomials have a normal form as a sum of products of descending powers. For example, this is in normal form:</p>
<pre><code>5*x^2 - 3*x + 0</code></pre>
<p>The problem thus simplifies to determining if two expressions have the same normal form. Thus, we can construct a proof that each expression is equal to its normal form, and then compose those proofs together to show the unnormalized forms are equal.</p>
<p>My implementation is naive, and only works for expressions with a single variable, but I think the approach generalizes if you can find a suitable normal form for multiple variables.</p>
<p>All of this sounds like a good tack, but the hard part is convincing ourselves (and perhaps more importantly, Agda,) that the stated relationship holds. As it happens, we require three equivalent types:</p>
<ul>
<li><code>A</code>, the ring we’re actually trying to solve</li>
<li><code>Poly</code>, a syntactic representation of the ring operations</li>
<li><code>Horner</code>, the type of <code>A</code>-normal forms</li>
</ul>
<p><code>Poly</code> and <code>Horner</code> are indexed by <code>A</code>, but I’ve left that out for presentation purposes. Furthermore, they’re also both indexed by the degree of the polynomial, that is, the biggest power they contain. I’m not sure this was necessary, but it helped me make sure my math was right when I was figuring out how to multiply <code>Horner</code>s.</p>
<p>At a high level, solving a ring equality is really a statement about how <code>A</code> is related to <code>Poly</code> and <code>Horner</code>. We can construct an A-expression by substituting an <code>A</code> for all the variables in a <code>Poly</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>construct <span class="ot">:</span> <span class="ot">{</span>n <span class="ot">:</span> ℕ<span class="ot">}</span> <span class="ot">→</span> Poly n <span class="ot">→</span> A <span class="ot">→</span> A</span></code></pre></div>
<p>and we can normalize any syntactic expression:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>normalize <span class="ot">:</span> <span class="ot">{</span>n <span class="ot">:</span> ℕ<span class="ot">}</span> <span class="ot">→</span> Poly n <span class="ot">→</span> Horner n</span></code></pre></div>
<p>thus we can solve a ring equation by hoisting a proof of equality of its normal forms into a proof of equality of its construction:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>solve</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>    <span class="ot">:</span> <span class="ot">{</span>n <span class="ot">:</span> ℕ<span class="ot">}</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>    <span class="ot">→</span> <span class="ot">(</span>x y <span class="ot">:</span> Poly n<span class="ot">)</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>    <span class="ot">→</span> normalize x ≡ normalize y</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a>    <span class="ot">→</span> <span class="ot">(</span>a <span class="ot">:</span> A<span class="ot">)</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>    <span class="ot">→</span> construct x a ≡ construct y a</span></code></pre></div>
<p>This approach is a bit underwhelming, since we need to explicitly construct syntactic objects (in <code>Poly</code>) corresponding to the expressions we’re trying to solve (in <code>A</code>). But this is something we can solve with Agda’s macro system, by creating the <code>Poly</code>s by inspecting the actual AST, so we’ll consider the approach good enough. Today’s post is about understanding how to do ring solving, not about how to engineer a nice user-facing interface.</p>
<p>The actual implementation of <code>solve</code> is entirely straight-forward:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>solve x y eq a <span class="ot">=</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>  begin</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>    construct x a             ≡⟨ construct-is-normal x a ⟩</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>    evaluate <span class="ot">(</span>normalize x<span class="ot">)</span> a  ≡⟨ cong <span class="ot">(\</span>φ <span class="ot">→</span> evaluate φ a<span class="ot">)</span> eq ⟩</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>    evaluate <span class="ot">(</span>normalize y<span class="ot">)</span> a  ≡⟨ sym $ construct-is-normal y a ⟩</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>    construct y a</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>  ∎</span></code></pre></div>
<p>given a lemma that <code>construct</code> is equal to evaluating the normal form:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>construct-is-normal</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>    <span class="ot">:</span> <span class="ot">{</span>N <span class="ot">:</span> ℕ<span class="ot">}</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>    <span class="ot">→</span> <span class="ot">(</span>x <span class="ot">:</span> Poly N<span class="ot">)</span></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>    <span class="ot">→</span> <span class="ot">(</span>a <span class="ot">:</span> A<span class="ot">)</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>    <span class="ot">→</span> construct x a ≡ evaluate <span class="ot">(</span>normalize x<span class="ot">)</span> a</span></code></pre></div>
<p>The implementation of this is pretty straightforward too, requiring only that we have <code>+</code> and <code>*</code> homomorphisms between <code>Horner</code> and <code>A</code>:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a>+A-+H-homo</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>    <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>m n<span class="ot">}</span> j k a</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>    <span class="ot">→</span> evaluate <span class="ot">{</span>m<span class="ot">}</span> j a +A evaluate <span class="ot">{</span>n<span class="ot">}</span> k a ≡ evaluate <span class="ot">(</span>j +H k<span class="ot">)</span> a</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true"></a>*A-*H-homo</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true"></a>    <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>m n<span class="ot">}</span> j k a</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true"></a>    <span class="ot">→</span> evaluate <span class="ot">{</span>m<span class="ot">}</span> j a *A evaluate <span class="ot">{</span>n<span class="ot">}</span> k a ≡ evaluate <span class="ot">(</span>j *H k<span class="ot">)</span> a</span></code></pre></div>
<p>These two lemmas turn out to be the hard part.</p>
<h2 id="but-first-types">But First, Types</h2>
<p>Before we get into all of that, let’s first discuss what each of the types looks like. We have <code>Poly</code>, which again, is an initial encoding of the ring algebra:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="kw">data</span> Poly <span class="ot">:</span> ℕ <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>  con <span class="ot">:</span> A <span class="ot">→</span> Poly <span class="dv">0</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>  var <span class="ot">:</span> Poly <span class="dv">1</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>  <span class="ot">_</span>:+<span class="ot">_</span> <span class="ot">:</span> <span class="ot">{</span>m n <span class="ot">:</span> ℕ<span class="ot">}</span> <span class="ot">→</span> Poly m <span class="ot">→</span> Poly n <span class="ot">→</span> Poly <span class="ot">(</span>m ⊔ n<span class="ot">)</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a>  <span class="ot">_</span>:*<span class="ot">_</span> <span class="ot">:</span> <span class="ot">{</span>m n <span class="ot">:</span> ℕ<span class="ot">}</span> <span class="ot">→</span> Poly m <span class="ot">→</span> Poly n <span class="ot">→</span> Poly <span class="ot">(</span>m + n<span class="ot">)</span></span></code></pre></div>
<p>We can reify the meaning of <code>Poly</code> by giving a transformation into <code>A</code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a>construct <span class="ot">:</span> <span class="ot">{</span>N <span class="ot">:</span> ℕ<span class="ot">}</span> <span class="ot">→</span> Poly N <span class="ot">→</span> A <span class="ot">→</span> A</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>construct <span class="ot">(</span>con x<span class="ot">)</span> a <span class="ot">=</span> x</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>construct var a <span class="ot">=</span> a</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>construct <span class="ot">(</span>p :+ p2<span class="ot">)</span> a <span class="ot">=</span> construct p a +A construct p2 a</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a>construct <span class="ot">(</span>p :* p2<span class="ot">)</span> a <span class="ot">=</span> construct p a *A construct p2 a</span></code></pre></div>
<p>Our other core type is <code>Horner</code>, which is an encoding of the Horner normal form of a polynomial:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="kw">data</span> Horner <span class="ot">:</span> ℕ <span class="ot">→</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>  PC <span class="ot">:</span> A <span class="ot">→</span> Horner <span class="dv">0</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>  PX <span class="ot">:</span> <span class="ot">{</span>n <span class="ot">:</span> ℕ<span class="ot">}</span> <span class="ot">→</span> A <span class="ot">→</span> Horner n <span class="ot">→</span> Horner <span class="ot">(</span>suc n<span class="ot">)</span></span></code></pre></div>
<p><code>Horner</code> requires some discussion. Horner normal form isn’t the same normal form presented earlier, instead, it’s a chain of linear multiplications. For example, we earlier saw this:</p>
<pre><code>5*x^2 - 3*x + 0</code></pre>
<p>in Horner normal form, this would be written as</p>
<pre><code>0 + x * (3 + x * 5)</code></pre>
<p>The idea is we can write any polynomial inductively by nesting the bigger terms as sums inside of multiplications against <code>x</code>. We can encode the above as a <code>Horner</code> like this:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>PX <span class="dv">0</span> <span class="ot">(</span>PX <span class="dv">3</span> <span class="ot">(</span>PC <span class="dv">5</span><span class="ot">))</span></span></code></pre></div>
<p>and then reify the meaning of <code>Horner</code> with respect to <code>A</code> via <code>evaluate</code>:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a>evaluate <span class="ot">:</span> <span class="ot">{</span>n <span class="ot">:</span> ℕ<span class="ot">}</span> <span class="ot">→</span> Horner n <span class="ot">→</span> A <span class="ot">→</span> A</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a>evaluate <span class="ot">(</span>PC x<span class="ot">)</span> v <span class="ot">=</span> x</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a>evaluate <span class="ot">(</span>PX x xs<span class="ot">)</span> v <span class="ot">=</span> x +A <span class="ot">(</span>v *A evaluate xs v<span class="ot">)</span></span></code></pre></div>
<h2 id="operations-on-horners">Operations on Horners</h2>
<p>We can define addition over <code>Horner</code> terms, which is essentially <code>zipWith (+A)</code>:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="ot">_</span>+H<span class="ot">_</span> <span class="ot">:</span> <span class="ot">{</span>m n <span class="ot">:</span> ℕ<span class="ot">}</span> <span class="ot">→</span> Horner m <span class="ot">→</span> Horner n <span class="ot">→</span> Horner <span class="ot">(</span>m ⊔ n<span class="ot">)</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true"></a><span class="ot">_</span>+H<span class="ot">_</span> <span class="ot">(</span>PC x<span class="ot">)</span>    <span class="ot">(</span>PC y<span class="ot">)</span>    <span class="ot">=</span> PC <span class="ot">(</span>x +A y<span class="ot">)</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true"></a><span class="ot">_</span>+H<span class="ot">_</span> <span class="ot">(</span>PC x<span class="ot">)</span>    <span class="ot">(</span>PX y ys<span class="ot">)</span> <span class="ot">=</span> PX <span class="ot">(</span>x +A y<span class="ot">)</span> ys</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true"></a><span class="ot">_</span>+H<span class="ot">_</span> <span class="ot">(</span>PX x xs<span class="ot">)</span> <span class="ot">(</span>PC y<span class="ot">)</span>    <span class="ot">=</span> PX <span class="ot">(</span>x +A y<span class="ot">)</span> xs</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true"></a><span class="ot">_</span>+H<span class="ot">_</span> <span class="ot">(</span>PX x xs<span class="ot">)</span> <span class="ot">(</span>PX y ys<span class="ot">)</span> <span class="ot">=</span> PX <span class="ot">(</span>x +A y<span class="ot">)</span> <span class="ot">(</span>xs +H ys<span class="ot">)</span></span></code></pre></div>
<p>We can also implement scalar transformations over <code>Horner</code>, which is exactly a monomorphic <code>fmap</code>:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a>scalMapHorner <span class="ot">:</span> <span class="ot">{</span>m <span class="ot">:</span> ℕ<span class="ot">}</span> <span class="ot">→</span> <span class="ot">(</span>A <span class="ot">→</span> A<span class="ot">)</span> <span class="ot">→</span> Horner m <span class="ot">→</span> Horner m</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a>scalMapHorner f <span class="ot">(</span>PC x<span class="ot">)</span> <span class="ot">=</span> PC <span class="ot">(</span>f x<span class="ot">)</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a>scalMapHorner f <span class="ot">(</span>PX x xs<span class="ot">)</span> <span class="ot">=</span> PX <span class="ot">(</span>f x<span class="ot">)</span> <span class="ot">(</span>scalMapHorner f xs<span class="ot">)</span></span></code></pre></div>
<p>and finally, we can define multiplication over <code>Horner</code> terms:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a><span class="ot">_</span>*H<span class="ot">_</span> <span class="ot">:</span> <span class="ot">{</span>m n <span class="ot">:</span> ℕ<span class="ot">}</span> <span class="ot">→</span> Horner m <span class="ot">→</span> Horner n <span class="ot">→</span> Horner <span class="ot">(</span>m + n<span class="ot">)</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a><span class="ot">_</span>*H<span class="ot">_</span> <span class="ot">(</span>PC x<span class="ot">)</span> y <span class="ot">=</span> scalMapHorner <span class="ot">(</span>x *A<span class="ot">_)</span> y</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a><span class="ot">_</span>*H<span class="ot">_</span> <span class="ot">(</span>PX <span class="ot">{</span>m<span class="ot">}</span> x xs<span class="ot">)</span> <span class="ot">(</span>PC y<span class="ot">)</span> <span class="ot">=</span> scalMapHorner <span class="ot">(_</span>*A y<span class="ot">)</span> <span class="ot">(</span>PX x xs<span class="ot">)</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a><span class="ot">_</span>*H<span class="ot">_</span> <span class="ot">(</span>PX <span class="ot">{</span>m<span class="ot">}</span> x xs<span class="ot">)</span> yy <span class="ot">=</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a>  scalMapHorner <span class="ot">(</span>x *A<span class="ot">_)</span> yy +H PX #0 <span class="ot">(</span>xs *H yy<span class="ot">)</span></span></code></pre></div>
<p>The first two cases here are straightforward, just <code>scalMapHorner</code>-multiply in the constant value and go on your way. The <code>PX-PX</code> case is rather complicated however, but corresponds to the <code>*-+-distrib</code> law:</p>
<pre><code>*-+-distrib : ∀ x xs yy → (x + xs) * yy ≡ x * yy +A xs * yy</code></pre>
<p>We take advantage of the fact that we know <code>x</code> is a scalar, by immediately multiplying it in via <code>scalMapHorner</code>.</p>
<h2 id="tying-it-all-together">Tying it All Together</h2>
<p>As alluded to earlier, all that’s left is to show <code>evaluate</code>-homomorphisms for <code>+H</code>/<code>+A</code> and <code>*H</code>/<code>*A</code>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a>+A-+H-homo</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a>    <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>m n<span class="ot">}</span> j k a</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a>    <span class="ot">→</span> evaluate <span class="ot">{</span>m<span class="ot">}</span> j a +A evaluate <span class="ot">{</span>n<span class="ot">}</span> k a ≡ evaluate <span class="ot">(</span>j +H k<span class="ot">)</span> a</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a>*A-*H-homo</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true"></a>    <span class="ot">:</span> <span class="ot">∀</span> <span class="ot">{</span>m n<span class="ot">}</span> j k a</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true"></a>    <span class="ot">→</span> evaluate <span class="ot">{</span>m<span class="ot">}</span> j a *A evaluate <span class="ot">{</span>n<span class="ot">}</span> k a ≡ evaluate <span class="ot">(</span>j *H k<span class="ot">)</span> a</span></code></pre></div>
<p>There’s nothing interesting in these proofs, it’s just three hundred ironic lines of tedious, boring proofs, of the sort that we are trying to automate away.</p>
<p>Given these, we can implement <code>construct-is-normal</code></p>
<div class="sourceCode" id="cb24"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a>construct-is-normal</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a>    <span class="ot">:</span> <span class="ot">{</span>N <span class="ot">:</span> ℕ<span class="ot">}</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a>    <span class="ot">→</span> <span class="ot">(</span>x <span class="ot">:</span> Poly N<span class="ot">)</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a>    <span class="ot">→</span> <span class="ot">(</span>a <span class="ot">:</span> A<span class="ot">)</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a>    <span class="ot">→</span> construct x a ≡ evaluate <span class="ot">(</span>normalize x<span class="ot">)</span> a</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true"></a>construct-is-normal <span class="ot">(</span>con x<span class="ot">)</span> a <span class="ot">=</span> refl</span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true"></a>construct-is-normal var a <span class="ot">=</span> refl</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true"></a>construct-is-normal <span class="ot">(</span>x :+ y<span class="ot">)</span> a</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true"></a>  <span class="kw">rewrite</span> construct-is-normal x a</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true"></a>        <span class="ot">|</span> construct-is-normal y a</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true"></a>        <span class="ot">|</span> +A-+H-homo <span class="ot">(</span>normalize x<span class="ot">)</span> <span class="ot">(</span>normalize y<span class="ot">)</span> a</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true"></a>        <span class="ot">=</span> refl</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true"></a>construct-is-normal <span class="ot">(</span>x :* y<span class="ot">)</span> a</span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true"></a>  <span class="kw">rewrite</span> construct-is-normal x a</span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true"></a>        <span class="ot">|</span> construct-is-normal y a</span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true"></a>        <span class="ot">|</span> *A-*H-homo <span class="ot">(</span>normalize x<span class="ot">)</span> <span class="ot">(</span>normalize y<span class="ot">)</span> a</span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true"></a>        <span class="ot">=</span> refl</span></code></pre></div>
<p>Nice!</p>
<p>The homomorphism proofs are left as an exercise to the reader, or you can go look at the <a href="https://github.com/isovector/reviews/blob/master/agda-src/RingSolving.agda">code</a> if you want to skip doing it.</p>
<h2 id="agda-woes">Agda Woes</h2>
<p>My implementation isn’t 100% complete, I still need to prove that <code>*H</code> is commutative:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a>*H-comm <span class="ot">:</span> <span class="ot">∀</span> j k <span class="ot">→</span> j *H k ≡ k *H j</span></code></pre></div>
<p>which shouldn’t be hard, because it <em>is</em> commutative. Unfortunately, Agda has gone into hysterics, and won’t even typecheck the type of <code>*H-comm</code>, because it can’t figure out that <code>m + n = n + m</code> (the implicit indices on the result of <code>*H</code>). As far as I can tell, there is no easy fix here; there’s some weird <code>cong</code>-like thing for types called <code>subst</code>, but it seems to infect a program and push these weird-ass constraints everywhere.</p>
<p>This is extremely frustrating, because it’s literally the last thing to prove after 300 grueling lines of proof. And it’s also true and isn’t even hard to show. It’s just that I can’t get Agda to accept the type of the proof because it’s an idiot that doesn’t know about additive commutativity. After a few hours of fighting with getting this thing to typecheck, I just said fuck it and postulated <code>*H-comm</code>.</p>
<p>Stupid Agda.</p>
<p>If you know what I’ve done wrong to deserve this sort of hell, please let me know. It would be nice to be able to avoid problems like this in the future, or resolve them with great ease.</p>
<h2 id="conclusion">Conclusion</h2>
<p>So, that’s it! Modulo a postulate, we’ve managed to implement a ring-solver by showing the equivalence of three different representations of the same data. Just to convince ourselves that it works:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a>test-a <span class="ot">:</span> Poly <span class="dv">2</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a>test-a <span class="ot">=</span> <span class="ot">(</span>var :+ con #1<span class="ot">)</span> :* <span class="ot">(</span>var :+ con #1<span class="ot">)</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true"></a>test-b <span class="ot">:</span> Poly <span class="dv">2</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true"></a>test-b <span class="ot">=</span> var :* var :+ two :* var :+ con #1</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true"></a>    two <span class="ot">=</span> con #1 :+ con #1</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true"></a></span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true"></a>success</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true"></a>    <span class="ot">:</span> <span class="ot">(</span>x <span class="ot">:</span> A<span class="ot">)</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true"></a>    <span class="ot">→</span> <span class="ot">(</span>x +A #1<span class="ot">)</span> *A <span class="ot">(</span>x +A #1<span class="ot">)</span> ≡ <span class="ot">(</span>x *A x<span class="ot">)</span> +A <span class="ot">(</span>#1 +A #1<span class="ot">)</span> *A x +A #1</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true"></a>success x <span class="ot">=</span> solve test-a test-b refl x</span></code></pre></div>
<p>which Agda happily accepts!</p>
<p>I don’t exactly know offhand how to generalize this to multivariate polynomials, but I think the trick is to just find a normal form for them.</p>
<p>As usual, the code for this post is <a href="https://github.com/isovector/reviews/blob/master/agda-src/RingSolving.agda">available on Github.</a></p>
        ]]>
      </content>
    </entry>
    <entry>
      <title>Review: Codata in Action</title>
      <id>blog/review-codata/index.html</id>
      <link href='blog/review-codata/index.html'/>
      <published>2022-02-10T18:57:00Z</published>
      <updated>2022-02-10T18:57:00Z</updated>

      <content type="html">
        <![CDATA[
        <p>Today we’re looking at <a href="https://www.microsoft.com/en-us/research/uploads/prod/2020/01/CoDataInAction.pdf">Codata in Action</a> by Downen, Sullivan, Ariola and Peyton Jones. Please excuse my lack of any sort of theme as I review papers, I’m just picking things that seem interesting to me. This paper in particular was recommended to me by <a href="https://jonathanlorimer.dev/">Jonathan Lorimer</a> in the inaugural edition of the <a href="https://anchor.fm/cofree-coffee">Cofree Coffee Cast</a>, which is an excellent podcast that I may or may not be involved in.</p>
<p>So anyway, today we’re looking at codata. What’s that? Essentially, lazy records. By virtue of being lazy, Haskell makes the differentiation between data and codata rather hard to spot. The claim is that functional languages are big on data, object-oriented languages really like codata, and that everything you can do with one can be emulated by the other, which is useful if you’d like to compile FP to OOP, or vice versa.</p>
<p>Codata, like the name implies, have a lot of duals with regular ol’ data. The paper introduces a bunch of parallels between the two:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">Data</th>
<th style="text-align: center;">Codata</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Concerned with construction</td>
<td style="text-align: center;">Concerned with destruction</td>
</tr>
<tr class="even">
<td style="text-align: center;">Define the types of constructors</td>
<td style="text-align: center;">Define the types of destructors</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Directly observable</td>
<td style="text-align: center;">Observable only via their interface</td>
</tr>
<tr class="even">
<td style="text-align: center;">Common in FP</td>
<td style="text-align: center;">Common in OOP</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Initial algebras</td>
<td style="text-align: center;">Terminal coalgebras</td>
</tr>
<tr class="even">
<td style="text-align: center;">Algebraic data structures</td>
<td style="text-align: center;">Abstract data structures</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>data</code></td>
<td style="text-align: center;"><code>class</code></td>
</tr>
</tbody>
</table>
<p>The paper’s claim is that codata is a very useful tool for doing real-world work, and that we are doing ourselves a disservice by not making it first-class:</p>
<blockquote>
<p>While codata types can be seen in the shadows behind many examples of programming—often hand-compiled away by the programmer—not many functional languages have support for them.</p>
</blockquote>
<p>That’s a particularly interesting claim; that we’re all already using codata, but it’s hidden away inside of an idiom rather than being a first-class citizen. I’m always excited to see the ghosts behind the patterns I am already using.</p>
<h2 id="examples-of-codata">Examples of Codata</h2>
<p>The paper gives a big list of codata that we’re all already using without knowing it:</p>
<h3 id="churchboehmberarducci-encodings">Church/Boehm–Berarducci encodings</h3>
<p>Instead of writing</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Bool</span> <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>  <span class="dt">True</span><span class="ot"> ::</span> <span class="dt">Bool</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>  <span class="dt">False</span><span class="ot"> ::</span> <span class="dt">Bool</span></span></code></pre></div>
<p>I can instead do the usual Church encoding:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>codata <span class="dt">Bool</span> <span class="kw">where</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="ot">  if ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>which I might express more naturally in Haskell via:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="ot">ifThenElse ::</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>ifThenElse <span class="dt">True</span>  t _ <span class="ot">=</span> t</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a>ifThenElse <span class="dt">False</span> _ f <span class="ot">=</span> f</span></code></pre></div>
<p>(I suspect this is that “hand-compiling away” that the authors were talking about)</p>
<p>However, in the codata presentation, I can recover <code>true</code> and <code>false</code> by building specific objects that fiddle with their arguments just right (using <a href="">copatterns</a> from a few weeks ago):</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="dt">True</span> <span class="op">:</span> <span class="dt">Bool</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a><span class="kw">if</span> <span class="dt">True</span> t _ <span class="ot">=</span> t</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a><span class="dt">False</span> <span class="op">:</span> <span class="dt">Bool</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true"></a><span class="kw">if</span> <span class="dt">False</span> _ f <span class="ot">=</span> f</span></code></pre></div>
<p>That’s neat, I guess!</p>
<p>As a follow-up, we can try talking about <code>Tree</code>s. Rather than the usual <code>data</code> definition:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Tree</span> t <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>  <span class="dt">Leaf</span><span class="ot"> ::</span> t <span class="ot">-&gt;</span> <span class="dt">Tree</span> t</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>  <span class="dt">Branch</span><span class="ot"> ::</span> <span class="dt">Tree</span> t <span class="ot">-&gt;</span> <span class="dt">Tree</span> t <span class="ot">-&gt;</span> <span class="dt">Tree</span> t</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true"></a><span class="ot">walk ::</span> (t <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Tree</span> t <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>we can do it in codata:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>codata <span class="dt">Tree</span> t <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a><span class="ot">  walk ::</span> <span class="dt">Tree</span> t <span class="ot">-&gt;</span> (t <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>and reconstruct the “constructors:”</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="dt">Leaf</span><span class="ot"> x ::</span> t <span class="ot">-&gt;</span> <span class="dt">Tree</span> t</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>walk (<span class="dt">Leaf</span> t) mk _ <span class="ot">=</span> mk t</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a><span class="dt">Branch</span><span class="ot"> ::</span> <span class="dt">Tree</span> t <span class="ot">-&gt;</span> <span class="dt">Tree</span> t <span class="ot">-&gt;</span> <span class="dt">Tree</span> t</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>walk (<span class="dt">Branch</span> l r) mk comb <span class="ot">=</span> comb (walk l mk comb) (walk r mk comb)</span></code></pre></div>
<p>The presentation in the paper hand-compiles <code>Tree!data</code> into two declarations:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>codata <span class="dt">TreeVisitor</span> t a <span class="kw">where</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>  {<span class="ot"> visitLeaf   ::</span> <span class="dt">TreeVisitor</span> t a <span class="ot">-&gt;</span> t <span class="ot">-&gt;</span> a</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>  ,<span class="ot"> visitBranch ::</span> <span class="dt">TreeVisitor</span> t a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>  }</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true"></a></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true"></a>codata <span class="dt">Tree</span> t <span class="kw">where</span></span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true"></a><span class="ot">  walk ::</span> <span class="dt">Tree</span> t <span class="ot">-&gt;</span> <span class="dt">TreeVisitor</span> t a <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>which is the same thing, but with better named destructors.</p>
<h3 id="demand-driven-programming-laziness">Demand-Driven Programming / Laziness</h3>
<p>You know the problem. You’re programming some search, and want to have a stopping depth. Maybe you’re writing a chessai and don’t want to wait until the ends of time for the search to finish. Easy enough, right? Just add an integer that counts down whenever you recurse:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="ot">search ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Position</span> <span class="ot">-&gt;</span> [<span class="dt">Position</span>]</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>search <span class="dv">0</span> _ <span class="ot">=</span> []</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>search n as <span class="ot">=</span> <span class="co">-- do lots of work</span></span></code></pre></div>
<p>So you set <code>n</code> to something that seems reasonable, and get your moves back. But then you realize you had more time to kill, so you’d like to resume the search where you left off. But there’s no good way to do this, and starting back from the beginning would involve wasting a lot of effort. You can certainly program around it, but again, it’s hand-compiling away codata.</p>
<p>Instead, we can express the problem differently:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>codata <span class="dt">Rose</span> a <span class="kw">where</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>  {<span class="ot"> node ::</span> <span class="dt">Rose</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a>  ,<span class="ot"> children ::</span> <span class="dt">Rose</span> a <span class="ot">-&gt;</span> [<span class="dt">Rose</span> a]</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>  }</span></code></pre></div>
<p>Recall that codata is built-in lazy, so by repeatedly following <code>children</code> we can further explore the tree state. In OOP I guess we’d call this a generator or an iterator or something. Probably a factory of some sort.</p>
<p>But once we have <code>Rose</code> we can implement pruning:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="ot">prune ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Rose</span> <span class="dt">Position</span> <span class="ot">-&gt;</span> <span class="dt">Rose</span> <span class="dt">Position</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>node (prune n t) <span class="ot">=</span> node t</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>children (prune <span class="dv">0</span> t) <span class="ot">=</span> []</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>children (prune n t) <span class="ot">=</span> <span class="fu">fmap</span> (prune (n <span class="op">-</span> <span class="dv">1</span>)) <span class="op">$</span> children t</span></code></pre></div>
<p>I <em>really</em> like copattern matching.</p>
<h3 id="abstract-data-types">Abstract Data Types</h3>
<p>You know how we have extentional and intentional definitions for sets? Like, compare:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">Set</span> a <span class="ot">=</span> <span class="dt">Set</span> {<span class="ot"> unSet ::</span> [a] }</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a><span class="fu">lookup</span><span class="ot"> ::</span> <span class="dt">Set</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a><span class="fu">lookup</span> s t <span class="ot">=</span> <span class="fu">elem</span> t <span class="op">$</span> unset s</span></code></pre></div>
<p>vs</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">Set</span> a <span class="ot">=</span> <span class="dt">Set</span> {<span class="ot"> lookup ::</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span> }</span></code></pre></div>
<p>That latter version is the Church-encoded version. Instead we can give an interface for both sorts of sets as codata, defined by their <em>interface</em> as sets. This is everyday OOP stuff, but a little weird in FP land:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a>codata <span class="dt">Set</span> a <span class="kw">where</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>  {<span class="ot"> isEmpty ::</span> <span class="dt">Set</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>  ,<span class="ot"> lookup ::</span> <span class="dt">Set</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Bool</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a>  ,<span class="ot"> insert ::</span> <span class="dt">Set</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a>  ,<span class="ot"> union ::</span> <span class="dt">Set</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a <span class="ot">-&gt;</span> <span class="dt">Set</span> a</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a>  }</span></code></pre></div>
<p>My dudes this is just an interface for how you might want to interact with a Set. We can implement the listy version from above:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="ot">listySet ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Set</span> a</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>isEmpty (listySet ls) <span class="ot">=</span> <span class="fu">null</span> ls</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a><span class="fu">lookup</span> (listySet ls) a <span class="ot">=</span> <span class="fu">elem</span> a ls</span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a>insert (listySet ls) a <span class="ot">=</span> listSet (a <span class="op">:</span> ls)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a>union (listySet ls) s <span class="ot">=</span> <span class="fu">foldr</span> insert s ls</span></code></pre></div>
<p>but we can also implement an infinitely big set akin to our functiony-version:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a><span class="ot">evensUnion ::</span> <span class="dt">Set</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Set</span> <span class="dt">Int</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>isEmpty (evensUnion s) <span class="ot">=</span> <span class="dt">False</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a><span class="fu">lookup</span> (evensUnion s) a <span class="ot">=</span> <span class="fu">mod</span> a <span class="dv">2</span> <span class="op">==</span> <span class="dv">0</span> <span class="op">||</span> <span class="fu">lookup</span> a s</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>insert (evensUnion s) a <span class="ot">=</span> evensUnion <span class="op">$</span> insert s a</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>union (evensUnion s) s&#39; <span class="ot">=</span> evensUnion <span class="op">$</span> union s s&#39;</span></code></pre></div>
<p>This thing is a little odd, but <code>evensUnion</code> is the set of the even numbers unioned with some other set. The built-in unioning is necessary to be able to extend this thing. Maybe we might call it a decorator pattern in OOP land?</p>
<h3 id="pre-and-post-conditions">Pre and Post Conditions</h3>
<p>One last example, using type indices to represent the state of something. The paper gives sockets:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">State</span> <span class="ot">=</span> <span class="dt">Raw</span> <span class="op">|</span> <span class="dt">Bound</span> <span class="op">|</span> <span class="dt">Live</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Socket</span><span class="ot"> ::</span> <span class="dt">State</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a>codata <span class="dt">Socket</span> i <span class="kw">where</span></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a>  {<span class="ot"> bind    ::</span> <span class="dt">Socket</span> <span class="dt">&#39;Raw</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Socket</span> <span class="dt">&#39;Bound</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a>  ,<span class="ot"> connect ::</span> <span class="dt">Socket</span> <span class="dt">&#39;Bound</span> <span class="ot">-&gt;</span> <span class="dt">Socket</span> <span class="dt">&#39;Live</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true"></a>  ,<span class="ot"> send    ::</span> <span class="dt">Socket</span> <span class="dt">&#39;Live</span> <span class="ot">-&gt;</span> <span class="dt">String</span> <span class="ot">-&gt;</span> ()</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true"></a>  ,<span class="ot"> recv    ::</span> <span class="dt">Socket</span> <span class="dt">&#39;Live</span> <span class="ot">-&gt;</span> <span class="dt">String</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true"></a>  ,<span class="ot"> close   ::</span> <span class="dt">Socket</span> <span class="dt">&#39;Live</span> <span class="ot">-&gt;</span> ()</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true"></a>  }</span></code></pre></div>
<p>The type indices here ensure that we’ve bound the socket before connecting to it, and connected to it before we can send or receive.</p>
<p>Contrast this against what we can do with GADTs, which tell us how something was built, not how it can be used.</p>
<h2 id="converting-between-data-and-codata">Converting Between Data and Codata</h2>
<p>Unsurprisingly, data and codata are two sides of the same coin: we can compile one to the other and vice versa.</p>
<h3 id="data-to-codata">Data to Codata</h3>
<p>Going from data to codata is giving a final encoding for the thing; as we’ve seen, this corresponds to the Boehm-Berarducci encoding. The trick is to replace the type with a function. Each data constructor corresponds to an argument of the function, the type of which is another function that returns <code>a</code>, and as arguments takes each argument to the data constructor. To tie the knot, replace the recursive bits with <code>a</code>.</p>
<p>Let’s take a look at a common type:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">List</span> a <span class="ot">=</span> <span class="dt">Nil</span> <span class="op">|</span> <span class="dt">Cons</span> a (<span class="dt">List</span> a)</span></code></pre></div>
<p>We will encode this as a function, that returns some new type variable. Let’s call it <code>x</code>:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a><span class="op">...</span> <span class="ot">-&gt;</span> x</span></code></pre></div>
<p>and then we need to give eliminators for each case:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a>elim_nil <span class="ot">-&gt;</span> elim_cons <span class="ot">-&gt;</span> x</span></code></pre></div>
<p>and then replace each eliminator with a function that takes its arguments, and returns <code>x</code>. For <code>Nil</code>, there are no arguments, so it’s just:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a>x <span class="ot">-&gt;</span> elim_cons <span class="ot">-&gt;</span> x</span></code></pre></div>
<p>and then we do the same thing for <code>Cons :: a -&gt; List a -&gt; List a</code>:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a>x <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">List</span> a <span class="ot">-&gt;</span> x) <span class="ot">-&gt;</span> x</span></code></pre></div>
<p>of course, there is no <code>List a</code> type anymore, so we replace that with <code>x</code> too:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a>x <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> x <span class="ot">-&gt;</span> x) <span class="ot">-&gt;</span> x</span></code></pre></div>
<p>And thus we have our codata-encoded list. For bonus points, we can do a little shuffling and renaming:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a>(a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b</span></code></pre></div>
<p>which looks very similar to our old friend <code>foldr</code>:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a><span class="fu">foldr</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> b</span></code></pre></div>
<p>In fact, a little more reshuffling shows us that <code>foldr</code> is exactly the codata transformation we’ve been looking for:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a><span class="fu">foldr</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> ((a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b)</span></code></pre></div>
<p>Cool. The paper calls this transformation the “visitor pattern” which I guess makes sense; in order to call this thing we need to give instructions for what to do in every possible case.</p>
<p>This is an encoding of the type itself! But we also need codata encodings for the data constructors. The trick is to just ignore the “handlers” in the type that don’t correspond to your constructor. For example:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a><span class="dt">Nil</span><span class="ot"> ::</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true"></a><span class="dt">Nil</span> _ nil <span class="ot">=</span> nil</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true"></a></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true"></a><span class="dt">Cons</span></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true"></a><span class="ot">    ::</span> a</span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true"></a>    <span class="ot">-&gt;</span> ((a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b)</span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true"></a>    <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> b <span class="ot">-&gt;</span> b)</span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true"></a>    <span class="ot">-&gt;</span> b</span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true"></a>    <span class="ot">-&gt;</span> b</span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true"></a><span class="dt">Cons</span> <span class="fu">head</span> <span class="fu">tail</span> cons nil <span class="ot">=</span> cons nil (<span class="fu">tail</span> cons nil)</span></code></pre></div>
<p>Really, these write themselves once you have an eye for them. One way to think about it is that the handlers are “continuations” for how you want to continue. This is the dreaded CPS transformation!</p>
<h3 id="codata-to-data">Codata to Data</h3>
<p>Let’s go the other way too. Appropriately, we can use codata streams:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a>codata <span class="dt">Stream</span> a <span class="kw">where</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true"></a>  {<span class="ot"> head ::</span> <span class="dt">Stream</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true"></a>  ,<span class="ot"> tail ::</span> <span class="dt">Stream</span> a <span class="ot">-&gt;</span> <span class="dt">Stream</span> a</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true"></a>  }</span></code></pre></div>
<p>I’m winging it here, but it’s more fun to figure out how to transform this than to get the information from the paper.</p>
<p>The obvious approach here is to just turn this thing directly into a record by dropping the <code>Stream a -&gt;</code> part of each field:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Stream</span> a <span class="ot">=</span> <span class="dt">Stream</span></span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true"></a>  {<span class="ot"> head ::</span> a</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true"></a>  ,<span class="ot"> tail ::</span> <span class="dt">Stream</span> a</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true"></a>  }</span></code></pre></div>
<p>While this works in Haskell, it doesn’t play nicely with strict languages. So, we can just lazify it by sticking each one behind a function:</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Stream</span> a <span class="ot">=</span> <span class="dt">Stream</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true"></a>  {<span class="ot"> head ::</span> () <span class="ot">-&gt;</span> a</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true"></a>  ,<span class="ot"> tail ::</span> () <span class="ot">-&gt;</span> <span class="dt">Stream</span> a</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true"></a>  }</span></code></pre></div>
<p>Looks good to me. But is this what the paper does? It mentions that we can <code>tabulate</code> a function, e.g., represent <code>Bool -&gt; String</code> as <code>(String, String)</code>. It doesn’t say much more than this, but we can do our own research. Peep the <code>Representable</code> class from <a href="https://hackage.haskell.org/package/adjunctions-4.4/docs/Data-Functor-Rep.html#t:Representable">adjunctions</a>:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">Distributive</span> f <span class="ot">=&gt;</span> <span class="dt">Representable</span> f <span class="kw">where</span></span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true"></a>  <span class="kw">type</span> <span class="dt">Rep</span><span class="ot"> f ::</span> <span class="op">*</span></span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true"></a><span class="ot">  tabulate ::</span> (<span class="dt">Rep</span> f <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> f a</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true"></a><span class="ot">  index    ::</span> f a <span class="ot">-&gt;</span> <span class="dt">Rep</span> f <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>This thing is exactly the transformation we’re looking for; we can “represent” some structure <code>f a</code> as a function <code>Rep f -&gt; a</code>, and tabulating gets us back the thing we had in the first place.</p>
<p>So the trick here is then to determine <code>f</code> for the <code>Rep f</code> that corresponds to our <code>codata</code> structure. Presumably that thing is exactly the record we worked out above.</p>
<p>What’s interesting about this approach is that it’s exactly <a href="https://www.haskellforall.com/2012/05/scrap-your-type-classes.html">scrap-your-typeclasses.</a> And it’s exactly how typeclasses are implemented in Haskell. And last I looked, it’s the approach that Elm recommends doing instead of having typeclasses. Which makes sense why it’s annoying in Elm, because the language designers are forcing us to hand-compile our code! But I don’t need to beat that dead horse any further.</p>
<h2 id="thoughts">Thoughts</h2>
<p>Something that piqued my interest is a quote from the paper:</p>
<blockquote>
<p>Functional langauges are typically rich in data types … but a paucity of codata types (usually just function types.)</p>
</blockquote>
<p>This is interesting, because functions are the only non-trivial source of contravariance in Haskell. Contravariance is the co- version of (the poorly named, IMO) covariance. Which is a strong suggestion that functions are a source of contravariance <em>because they are codata,</em> rather than contravariance being a special property of functions themselves.</p>
<p>I asked my super smart friend <a href="https://totbwf.github.io/">Reed Mullanix</a> (who also has a great podcast episode), and he said something I didn’t understand about presheafs and functors. Maybe presheafs would make a good next paper.</p>
<h2 id="conclusions">Conclusions</h2>
<p>This was a helpful paper to to wrap my head around all this codata stuff that smart people in my circles keep talking about. None of it is <em>new,</em> but as a concept it helps solidify a lot of disparate facts I had rattling around in my brain. Doing this final tagless encoding of data types gives us a fast CPS thing that is quick as hell to run because it gets tail-optimized and doesn’t need to build any intermediary data structures, and gets driven by its consumer. The trade-off is that CPS stuff is a damn mind-melter.</p>
<p>At Zurihac 2018, I met some guy (whose name I can’t remember, sorry!) who was working on a new language that supported this automatic transformation between data and codata. I don’t remember anything about it, except he would just casually convert between data and codata whenever was convenient, and the compiler would do the heavy lifting of making everything work out. It was cool. I wish I knew what I was talking about.</p>
        ]]>
      </content>
    </entry>
    <entry>
      <title>Followup to Sorting with Bialgebras</title>
      <id>blog/bialgebra-followup/index.html</id>
      <link href='blog/bialgebra-followup/index.html'/>
      <published>2022-02-08T12:57:00Z</published>
      <updated>2022-02-08T12:57:00Z</updated>

      <content type="html">
        <![CDATA[
        <p>Last week I was pretty down on the results of my <a href="/blog/bialgebras/">exploration into Sorting with Bialgebras</a>. I didn’t want to get into the habit of slamming through a paper just to not understand it, so I figured I’d take a hit on my yearly goal and spend this week getting the results up to snuff.</p>
<p>I started by really trying to wrap my head around how exactly the <code>ana . cata</code> pattern works. So I wrote out a truly massive number of trace statements, and stared at them until they made some amount of sense. Here’s what’s going on:</p>
<p><code>ana</code> takes an <code>a</code> and unfolds it into an <code>F a</code>, recursively repeating until it terminates by producing a non-inductive <code>F</code>-term. So here <code>F</code> is a <code>Sorted</code>. And then we need to give a folding function for <code>cata</code>. This fold happens in <code>Unsorted</code>, and thus has type <code>Unsorted (Sorted (Mu Unsorted)) -&gt; Sorted (Mu Unsorted)</code>. The idea here is that the <code>cata</code> uses its resulting <code>Sorted</code> to pull forward the smallest element it’s seen so far. Once the <code>cata</code> is finished, the <code>ana</code> gets a term <code>Sorted (Mu Unsorted)</code>, where the <code>Sorted</code> term is the head of the synthesized list, and the <code>Mu Unsorted</code> is the next “seed” to recurse on. This <code>Mu Unsorted</code> is one element smaller than it was last time around, so the recursion eventually terminates.</p>
<p>OK, so that’s all well and good. But what does <code>ana . para</code> do here? Same idea, except that the fold also gets a <code>Mu Unsorted</code> term, corresponding to the unsorted tail of the list — aka, before it’s been folded by <code>para</code>.</p>
<p>The paper doesn’t have much to say about <code>para</code>:</p>
<blockquote>
<p>in a paramorphism, the algebra also gets the remainder of the list. This extra parameter can be seen as a form of an as-pattern and is typically used to match on more than one element at a time or to detect that we have reached the final element.</p>
</blockquote>
<p>That’s all well and good, but it’s unclear how this can help us. The difference between <code>naiveIns</code> and <code>ins</code> is:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a>naiveIns</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="ot">    ::</span> <span class="dt">Ord</span> a</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>    <span class="ot">=&gt;</span> <span class="dt">Unsorted</span> a (<span class="dt">Sorted</span> a x)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>    <span class="ot">-&gt;</span> <span class="dt">Sorted</span> a (<span class="dt">Unsorted</span> a x)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>naiveIns <span class="dt">UNil</span> <span class="ot">=</span> <span class="dt">SNil</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>naiveIns (a <span class="op">:&gt;</span> <span class="dt">SNil</span>) <span class="ot">=</span> a <span class="op">:!</span> <span class="dt">UNil</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a>naiveIns (a <span class="op">:&gt;</span> b <span class="op">:!</span> x)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>  <span class="op">|</span> a <span class="op">&lt;=</span> b    <span class="ot">=</span> a <span class="op">:!</span> b <span class="op">:&gt;</span> x</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> b <span class="op">:!</span> a <span class="op">:&gt;</span> x</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a>ins</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a><span class="ot">    ::</span> <span class="dt">Ord</span> a</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a>    <span class="ot">=&gt;</span> <span class="dt">Unsorted</span> a (c, <span class="dt">Sorted</span> a x)</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a>    <span class="ot">-&gt;</span> <span class="dt">Sorted</span> a (<span class="dt">Either</span> c (<span class="dt">Unsorted</span> a x))</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true"></a>ins <span class="dt">UNil</span> <span class="ot">=</span> <span class="dt">SNil</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true"></a>ins (a <span class="op">:&gt;</span> (x, <span class="dt">SNil</span>)) <span class="ot">=</span> a <span class="op">:!</span> <span class="dt">Left</span> x</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true"></a>ins (a <span class="op">:&gt;</span> (x, b <span class="op">:!</span> x&#39;))</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true"></a>  <span class="op">|</span> a <span class="op">&lt;=</span> b    <span class="ot">=</span> a <span class="op">:!</span> <span class="dt">Left</span> x</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true"></a>  <span class="op">|</span> <span class="fu">otherwise</span> <span class="ot">=</span> b <span class="op">:!</span> <span class="dt">Right</span> (a <span class="op">:&gt;</span> x&#39;)</span></code></pre></div>
<p>Ignore the <code>Left/Right</code> stuff. The only difference here is whether we use <code>x</code> or <code>x'</code> in the last clause, where <code>x</code> is the original, unsorted tail, and <code>x'</code> is the somewhat-sorted tail. It’s unclear to me how this can possibly help improve performance; we still need to have traversed the entire tail in order to find the smallest element. Maybe there’s something about laziness here, in that we shouldn’t need to rebuild the tail, but we’re going to be sharing the tail-of-tail regardless, so I don’t think this buys us anything.</p>
<p>And this squares with my confusion last week; this “caching” just doesn’t seem to do anything. In fact, the paper doesn’t even say it’s caching. All it has to say about our original <code>naiveIns</code>:</p>
<blockquote>
<p>Why have we labelled our insertion sort as naïve? This is because we are not making use of the fact that the incoming list is ordered— compare the types of <code>bub</code> and <code>naiveIns</code>. We will see how to capitalise on the type of <code>naiveIns</code> in Section 5.</p>
</blockquote>
<p>and then in section 5:</p>
<blockquote>
<p>The sole difference between sel and bub (Section 3) is in the case where a 6 b: <code>sel</code> uses the remainder of the list, supplied by the paramorphism, rather than the result computed so far. This is why <code>para sel</code> is the true selection function, and fold bub is the naïve variant, if you will.</p>
</blockquote>
<p>OK, fair, that checks out with what came out of my analysis. The <code>ana . para</code> version does use the tail of the original list, while <code>ana . cata</code> uses the version that might have already done some shuffling. But this is work we needed to do anyway, and moves us closer to a sorted list, so it seems insane to throw it away!</p>
<p>The best argument I can come up with here is that the <code>ana . para</code> version is dual to <code>cata . apo</code>, which signals whether the recursion should stop early. That one sounds genuinely useful to me, so maybe the paper does the <code>ana . para</code> thing just out of elegance.</p>
<p>Unfortunately, <code>cata . apo</code> doesn’t seem to be a performance boost in practice. In fact, both <code>cata . ana</code> and <code>ana . cata</code> perform significantly better than <code>cata . apo</code> and <code>ana . para</code>. Even more dammingly, the latter two perform better when they ignore the unique abilities that <code>apo</code> and <code>para</code> provide.</p>
<p>Some graphs are worth a million words:</p>
<center>
<img src="/images/bialgebra/o0-by-size.png">
</center>
<center>
<img src="/images/bialgebra/o0-by-algo.png">
</center>
<p>These are performance benchmarks for <code>-00</code>, using <code>Data.List.sort</code> as a control (“sort”). The big numbers on the left are the size of the input. “bubble” is the naive version of “selection.” Additionally, the graphs show the given implementations of <code>quickSort</code> and <code>treeSort</code>, as well as the two variations I was wondering about in the last post (here called <code>quickTree</code> and <code>treeQuick</code>.)</p>
<p>The results are pretty damming. In <em>all</em> cases, bubble-sort is the fastest of the algorithms presented in the paper. That’s, uh, not a good sign.</p>
<p>Furthermore, the “no caching” versions of “insertion” and “selection” both perform better than their caching variants. They are implemented by just ignoring the arguments that we get from <code>apo</code> and <code>para</code>, and simulating being <code>ana</code> and <code>cata</code> respectively. That means: whatever it is that <code>apo</code> and <code>para</code> are doing is <em>strictly worse</em> than not doing it.</p>
<p>Not a good sign.</p>
<p>But maybe this is all just a result of being run on <code>-O0</code>. Let’s try turning on optimizations and seeing what happens:</p>
<center>
<img src="/images/bialgebra/o2-by-size.png">
</center>
<center>
<img src="/images/bialgebra/o2-by-algo.png">
</center>
<p>About the same. Uh oh.</p>
<p>I don’t know what to blame this on. Maybe the constant factors are bad, or it’s a runtime thing, or I fucked up something in the implementation, or maybe the paper just doesn’t do what it claims. It’s unclear. But <a href="https://github.com/isovector/reviews/blob/d4dfc42aa2b993a6b0d536a6d96bef4e86f30f65/app/Main.hs#L19-L30">here’s my code</a>, in case you want to take a look and tell me if I screwed something up. The criterion reports are available for <a href="/graphs/bialgebra-o0.html"><code>-O0</code></a> and <a href="/graphs/bialgebra-o2.html"><code>-O2</code></a> (slightly different than in the above photos, since I had to rerun them.)</p>
        ]]>
      </content>
    </entry>
    <entry>
      <title>Review: Sorting with Bialgebras and Distributive Laws</title>
      <id>blog/bialgebras/index.html</id>
      <link href='blog/bialgebras/index.html'/>
      <published>2022-02-05T17:59:00Z</published>
      <updated>2022-02-05T17:59:00Z</updated>

      <content type="html">
        <![CDATA[
        <p>Today’s paper is <a href="http://www.cs.ox.ac.uk/people/daniel.james/sorting/sorting.pdf">Sorting with Bialgebras and Distributive Laws</a> by Hinze et al. The main thrust of the paper is that many well-known sorting algorithms are categorical duals of one another! As seems to be usual for the papers I review, there’s a lot of <a href="/blog/recursion-schemes">recursion scheme</a> stuff here, so go read that first if you’re unfamiliar with it.</p>
<p>Something that’s stymied me while working through <em>Sorting with Bialgebras</em> is that whatever it is we’re doing here, it’s not observable. All sorting functions are extentionally equal — so the work being done here is necessarily below the level of equality. This doesn’t jive well with how I usually think about programming, and has made it very hard for me to see exactly what the purpose of all of this is. But I digress.</p>
<h2 id="bubblesort-and-naive-insertion-sort">Bubblesort and Naive Insertion Sort</h2>
<p>Hinze et al. begin by showing us that insertion sort and bubble sort have terse implementations:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="ot">insertSort ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>insertSort <span class="ot">=</span> <span class="fu">foldr</span> insert []</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="ot">selectSort ::</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> [a] <span class="ot">-&gt;</span> [a]</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>selectSort <span class="ot">=</span> unfoldr select</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a><span class="ot">    select ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (a, [a])</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a>    select [] <span class="ot">=</span> <span class="dt">Nothing</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a>    select as <span class="ot">=</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a>      <span class="kw">let</span> x <span class="ot">=</span> <span class="fu">minimum</span> as</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a>          xs <span class="ot">=</span> delete x as</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a>       <span class="kw">in</span> <span class="dt">Just</span> (x, xs)</span></code></pre></div>
<p>and that there are two dualities here, <code>foldr</code> is dual to <code>unfoldr</code>, and <code>insert :: Ord a =&gt; a -&gt; [a] -&gt; [a]</code> is dual to <code>select :: Ord a =&gt; [a] -&gt; Maybe (a, [a])</code>.</p>
<p>The rest of the paper is pulling on this thread to see where it goes. As a first step, it’s noted that <code>foldr</code> and <code>unfoldr</code> are hiding a lot of interesting details, so instead we will divide the sorting problem into two halves: a catamorphism to tear down the unsorted list, and an anamorphism to build up the sorted version.</p>
<p>Begin by defining <code>Mu</code> and <code>Nu</code>, which are identical in Haskell. The intention here is that we can tear down <code>Mu</code>s, and build up <code>Nu</code>s:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">Mu</span> f <span class="ot">=</span> <span class="dt">Mu</span> {<span class="ot"> unMu ::</span> f (<span class="dt">Mu</span> f) }</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">Nu</span> f <span class="ot">=</span> <span class="dt">Nu</span> {<span class="ot"> unNu ::</span> f (<span class="dt">Nu</span> f) }</span></code></pre></div>
<p>as witnessed by <code>cata</code> and <code>ana</code>:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="ot">cata ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (f a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Mu</span> f <span class="ot">-&gt;</span> a</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>cata f <span class="ot">=</span> f <span class="op">.</span> <span class="fu">fmap</span> (cata f) <span class="op">.</span> unMu</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true"></a><span class="ot">ana ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f a) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Nu</span> f</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true"></a>ana f <span class="ot">=</span> <span class="dt">Nu</span> <span class="op">.</span> <span class="fu">fmap</span> (ana f) <span class="op">.</span> f</span></code></pre></div>
<p>We’ll also need a pattern functor to talk about lists:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">ListF</span> (<span class="ot">t ::</span> <span class="dt">Tag</span>) a k <span class="ot">=</span> <span class="dt">Nil</span> <span class="op">|</span> a <span class="op">:&gt;</span> k</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>, <span class="dt">Functor</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true"></a><span class="kw">infixr</span> <span class="dv">5</span> <span class="op">:&gt;</span></span></code></pre></div>
<p>This <code>Tag</code> thing is of my own devising, it’s a phantom type to track whether or not our list is sorted:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Tag</span> <span class="ot">=</span> <span class="dt">UnsortedTag</span> <span class="op">|</span> <span class="dt">SortedTag</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a></span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Unsorted</span> <span class="ot">=</span> <span class="dt">ListF</span> <span class="dt">&#39;UnsortedTag</span></span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Sorted</span> <span class="ot">=</span> <span class="dt">ListF</span> <span class="dt">&#39;SortedTag</span></span></code></pre></div>
<p>Note that in Haskell, nothing ensures that <code>Sorted</code> values are actually sorted! This is just some extra machinery to get more informative types.</p>
<p>With everything in place, we can now write the type of a sorting function:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">SortingFunc</span> a <span class="ot">=</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">Mu</span> (<span class="dt">Unsorted</span> a) <span class="ot">-&gt;</span> <span class="dt">Nu</span> (<span class="dt">Sorted</span> a)</span></code></pre></div>
<p>that is, a sorting function is something that tears down an unsorted list, and builds up a sorted list in its place. Makes sense, and the extra typing helps us keep track of which bits are doing what.</p>
<p>Most of the paper stems from the fact that we can implement a <code>SortingFunc</code> in two ways. We can either:</p>
<ol type="1">
<li>write a <code>cata</code> that tears down the <code>Mu</code> by building up a <code>Nu</code> via <code>ana</code>, or</li>
<li>write an <code>ana</code> that builds up the <code>Nu</code> that tears down the <code>Mu</code> via <code>cata</code></li>
</ol>
<p>Let’s look at the first case:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="ot">naiveInsertSort ::</span> <span class="dt">SortingFunc</span> a</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>naiveInsertSort <span class="ot">=</span> cata <span class="op">$</span> ana _</span></code></pre></div>
<p>this hole has type</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a>               <span class="dt">Unsorted</span> a (<span class="dt">Nu</span> (<span class="dt">Sorted</span> a))</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>  <span class="ot">-&gt;</span> <span class="dt">Sorted</span> a (<span class="dt">Unsorted</span> a (<span class="dt">Nu</span> (<span class="dt">Sorted</span> a)))</span></code></pre></div>
<p>which we can think of as having stuck an element on the front of an otherwise sorted list, and then needing to push that unsortedness one layer deeper. That does indeed sound like insertion sort: take a sorted list, and then traverse through it, sticking the unsorted element in the right place. It’s “naive” because the recursion doesn’t stop once it’s in the right place — since the remainder of the list is already sorted, it’s OK to stop.</p>
<p>The paper deals with this issue later.</p>
<p>Let’s write a function with this type:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a>naiveIns</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a><span class="ot">    ::</span> <span class="dt">Ord</span> a</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>    <span class="ot">=&gt;</span> <span class="dt">Unsorted</span> a (<span class="dt">Nu</span> (<span class="dt">Sorted</span> a))</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>    <span class="ot">-&gt;</span> <span class="dt">Sorted</span> a (<span class="dt">Unsorted</span> a (<span class="dt">Nu</span> (<span class="dt">Sorted</span> a)))</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>naiveIns <span class="dt">Nil</span>                 <span class="ot">=</span> <span class="dt">Nil</span></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true"></a>naiveIns (a <span class="op">:&gt;</span> <span class="dt">Nu</span> <span class="dt">Nil</span>)       <span class="ot">=</span> a <span class="op">:&gt;</span> <span class="dt">Nil</span></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true"></a>naiveIns (a <span class="op">:&gt;</span> <span class="dt">Nu</span> (b <span class="op">:&gt;</span> x))</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true"></a>  <span class="op">|</span> a <span class="op">&lt;=</span> b                   <span class="ot">=</span> a <span class="op">:&gt;</span> b <span class="op">:&gt;</span> x</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true"></a>  <span class="op">|</span> <span class="fu">otherwise</span>                <span class="ot">=</span> b <span class="op">:&gt;</span> a <span class="op">:&gt;</span> x</span></code></pre></div>
<p>The first two cases are uninteresting. But the cons-cons case is — we need to pick whichever of the two elements is smaller, and stick it in front. In doing so, we have sorted the first element in the list, and pushed the unsortedness deeper.</p>
<p>This all makes sense to me. But I find the dual harder to think about. Instead of making a <code>cata . ana</code>, let’s go the other way with an <code>ana . cata</code>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="ot">bubbleSort ::</span> <span class="dt">SortingFunc</span> a</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>bubbleSort <span class="ot">=</span> ana <span class="op">$</span> cata _</span></code></pre></div>
<p>this hole now has type:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a>     <span class="dt">Unsorted</span> a (<span class="dt">Sorted</span> a (<span class="dt">Mu</span> (<span class="dt">Unsorted</span> a)))</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>  <span class="ot">-&gt;</span> <span class="dt">Sorted</span> a (<span class="dt">Mu</span> (<span class="dt">Unsorted</span> a))</span></code></pre></div>
<p>which is now an unsorted element in front of a sorted element, in front of the remainder of an unsorted list. What does it mean to be a single sorted element? Well, it must be the smallest element in the otherwise unsorted list. Thus, the smallest element in a list bubbles its way to the front.</p>
<p>On my first reading of this, I thought to myself “that sure sounds a lot like selection sort!” But upon close reading later, it’s not. Insertion sort knows where to put the smallest element it’s found, and does that in constant time. Bubble sort instead swaps adjacent elements, slowly getting the smallest element closer and closer to the front.</p>
<p>Let’s implement a function with this type:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a>bub</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a><span class="ot">    ::</span> <span class="dt">Ord</span> a</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>    <span class="ot">=&gt;</span> <span class="dt">Unsorted</span> a (<span class="dt">Sorted</span> a (<span class="dt">Mu</span> (<span class="dt">Unsorted</span> a)))</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>    <span class="ot">-&gt;</span> <span class="dt">Sorted</span> a (<span class="dt">Mu</span> (<span class="dt">Unsorted</span> a))</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a>bub <span class="dt">Nil</span>            <span class="ot">=</span> <span class="dt">Nil</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true"></a>bub (a <span class="op">:&gt;</span> <span class="dt">Nil</span>)     <span class="ot">=</span> a <span class="op">:&gt;</span> <span class="dt">Mu</span> <span class="dt">Nil</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true"></a>bub (a <span class="op">:&gt;</span> b <span class="op">:&gt;</span> x)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true"></a>  <span class="op">|</span> a <span class="op">&lt;=</span> b         <span class="ot">=</span> a <span class="op">:&gt;</span> <span class="dt">Mu</span> (b <span class="op">:&gt;</span> x)</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true"></a>  <span class="op">|</span> <span class="fu">otherwise</span>      <span class="ot">=</span> b <span class="op">:&gt;</span> <span class="dt">Mu</span> (a <span class="op">:&gt;</span> x)</span></code></pre></div>
<p>While <code>naiveIns</code> pushes unsorted elements inwards, <code>bub</code> pulls sorted elements outwards. But, when you look at the implementations of <code>bub</code> and <code>naiveIns</code>, they’re awfully similar! This is the main thrust of the paper — we can factor out a common core of <code>naiveIns</code> and <code>bub</code>:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a>swap</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a><span class="ot">    ::</span> <span class="dt">Ord</span> a</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>    <span class="ot">=&gt;</span> <span class="dt">Unsorted</span> a (<span class="dt">Sorted</span> a x)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>    <span class="ot">-&gt;</span> <span class="dt">Sorted</span> a (<span class="dt">Unsorted</span> a x)</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a>swap <span class="dt">Nil</span>            <span class="ot">=</span> <span class="dt">Nil</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true"></a>swap (a <span class="op">:&gt;</span> <span class="dt">Nil</span>)     <span class="ot">=</span> a <span class="op">:&gt;</span> <span class="dt">Nil</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true"></a>swap (a <span class="op">:&gt;</span> b <span class="op">:&gt;</span> x)</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true"></a>  <span class="op">|</span> a <span class="op">&lt;=</span> b          <span class="ot">=</span> a <span class="op">:&gt;</span> b <span class="op">:&gt;</span> x</span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true"></a>  <span class="op">|</span> <span class="fu">otherwise</span>       <span class="ot">=</span> b <span class="op">:&gt;</span> a <span class="op">:&gt;</span> x</span></code></pre></div>
<p>It wasn’t immediately clear to me why this works, since the types of <code>bub</code> and <code>ins</code> seem to be more different than this. But when we compare them, this is mostly an artifact of the clunky fixed-point encodings:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="co">-- type of bub</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>   <span class="dt">Unsorted</span> a (<span class="dt">Sorted</span> a (<span class="dt">Mu</span> (<span class="dt">Unsorted</span> a)))</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a><span class="ot">-&gt;</span> <span class="dt">Sorted</span> a (<span class="dt">Mu</span> (<span class="dt">Unsorted</span> a))</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true"></a></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true"></a><span class="co">-- unroll a Mu:</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true"></a></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true"></a>   <span class="dt">Unsorted</span> a (<span class="dt">Sorted</span> a (<span class="dt">Mu</span> (<span class="dt">Unsorted</span> a)))</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true"></a><span class="ot">-&gt;</span> <span class="dt">Sorted</span> a (<span class="dt">Unsorted</span> a (<span class="dt">Mu</span> (<span class="dt">Unsorted</span> a)))</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true"></a></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true"></a><span class="co">-- let x ~ Mu (Unsorted a)</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true"></a></span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true"></a>   <span class="dt">Unsorted</span> a (<span class="dt">Sorted</span> a x)</span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true"></a><span class="ot">-&gt;</span> <span class="dt">Sorted</span> a (<span class="dt">Unsorted</span> a x)</span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true"></a></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true"></a><span class="co">-- let x ~ Nu (Sorted a)</span></span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true"></a></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true"></a>   <span class="dt">Unsorted</span> a (<span class="dt">Sorted</span> a (<span class="dt">Nu</span> (<span class="dt">Sorted</span> a))</span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true"></a><span class="ot">-&gt;</span> <span class="dt">Sorted</span> a (<span class="dt">Unsorted</span> a (<span class="dt">Nu</span> (<span class="dt">Sorted</span> a)))</span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true"></a></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true"></a><span class="co">-- unroll a Nu</span></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true"></a></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true"></a>   <span class="dt">Unsorted</span> a (<span class="dt">Sorted</span> a (<span class="dt">Nu</span> (<span class="dt">Sorted</span> a)))</span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true"></a><span class="ot">-&gt;</span> <span class="dt">Sorted</span> a (<span class="dt">Unsorted</span> a (<span class="dt">Nu</span> (<span class="dt">Sorted</span> a)))</span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true"></a></span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true"></a><span class="co">-- type of naiveIns</span></span></code></pre></div>
<p>The only difference here is we are no longer packing <code>Mu</code>s and unpacking <code>Nu</code>s. We can pull that stuff out:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="ot">bubbleSort&#39;&#39; ::</span> <span class="dt">SortingFunc</span> a</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>bubbleSort&#39;&#39; <span class="ot">=</span> ana <span class="op">$</span> cata <span class="op">$</span> <span class="fu">fmap</span> <span class="dt">Mu</span> <span class="op">.</span> swap</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true"></a><span class="ot">naiveInsertSort&#39;&#39; ::</span> <span class="dt">SortingFunc</span> a</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true"></a>naiveInsertSort&#39;&#39; <span class="ot">=</span> cata <span class="op">$</span> ana <span class="op">$</span> swap <span class="op">.</span> <span class="fu">fmap</span> unNu</span></code></pre></div>
<p>and thus have shown that <code>bubbleSort''</code> and <code>naiveInsertSort''</code> are duals of one another.</p>
<h2 id="bialgebras">Bialgebras</h2>
<p>Allegedly, this stuff is all “just a bialgebra.” So, uh, what’s that? The authors draw a bunch of cool looking commutative diagrams that I would love to try to prove, but my attempts to do this paper in Agda were stymied by <code>Mu</code> and <code>Nu</code> being too recursive. So instead we’ll have to puzzle through it like peasants instead.</p>
<p>The universal mapping property of initial algebras (here, <code>Mu</code>) is the following:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a>cata f <span class="op">.</span> <span class="dt">Mu</span> <span class="ot">=</span> f <span class="op">.</span> <span class="fu">fmap</span> (cata f)</span></code></pre></div>
<p>and dually, for terminal coalgebras (<code>Nu</code>):</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>unNu <span class="op">.</span> ana f <span class="ot">=</span> <span class="fu">fmap</span> (ana f) <span class="op">.</span> f</span></code></pre></div>
<p>Let’s work on the <code>cata</code> diagram, WLOG. This UMP gives us:</p>
<pre><code>                     fmap (cata bub)
Unsorted (Mu Unsorted)  ---------&gt;  Unsorted (Sorted (Mu Unsorted))
         |                                      |
     Mu  |                                      |  bub
         v                                      v
   Mu Unsorted  ----------------------&gt;  Sorted (Mu Unsorted)
                     cata bub</code></pre>
<p>but as we saw in <code>bubbleSort''</code>, <code>bub = fmap Mu . swap</code>, thus:</p>
<pre><code>                     fmap (cata bub)
Unsorted (Mu Unsorted)  ---------&gt;  Unsorted (Sorted (Mu Unsorted))
         |                                      |
         |                                      |  swap
         |                                      v
     Mu  |                        Sorted (Unsorted (Mu Unsorted))
         |                                      |
         |                                      |  fmap Mu
         v                                      v
   Mu Unsorted  ----------------------&gt;  Sorted (Mu Unsorted)
                     cata bub</code></pre>
<p>If we let <code>c = cata bub</code> and <code>a = Mu</code>, this diagram becomes</p>
<pre><code>                          fmap c
Unsorted (Mu Unsorted)  ---------&gt;  Unsorted (Sorted (Mu Unsorted))
         |                                      |
         |                                      |  swap
         |                                      v
      a  |                        Sorted (Unsorted (Mu Unsorted))
         |                                      |
         |                                      |  fmap a
         v                                      v
   Mu Unsorted  ----------------------&gt;  Sorted (Mu Unsorted)
                          c</code></pre>
<p>and allgedly, this is the general shape of an <code>f</code>-<em>bialgebra</em>:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a>c <span class="op">.</span> a <span class="ot">=</span> <span class="fu">fmap</span> a <span class="op">.</span> f <span class="op">.</span> <span class="fu">fmap</span> c</span></code></pre></div>
<p>where <code>a : forall x. F x -&gt; x</code> and <code>c : forall x. x -&gt; G x</code>, thus <code>f : forall x. F (G x) -&gt; G (F x)</code>. In Agda:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a><span class="kw">record</span> Bialgebra</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a>       <span class="ot">{</span>F G <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">→</span> <span class="dt">Set</span><span class="ot">}</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true"></a>       <span class="ot">{</span>F-functor <span class="ot">:</span> Functor F<span class="ot">}</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true"></a>       <span class="ot">{</span>G-functor <span class="ot">:</span> Functor G<span class="ot">}</span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true"></a>       <span class="ot">(</span>f <span class="ot">:</span> <span class="ot">{</span>X <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">→</span> F <span class="ot">(</span>G X<span class="ot">)</span> <span class="ot">→</span> G <span class="ot">(</span>F X<span class="ot">))</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true"></a>  <span class="kw">field</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true"></a>    a <span class="ot">:</span> <span class="ot">{</span>X <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">→</span> F X <span class="ot">→</span> X</span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true"></a>    c <span class="ot">:</span> <span class="ot">{</span>X <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">→</span> X <span class="ot">→</span> G X</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true"></a>    bialgebra-proof</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true"></a>      <span class="ot">:</span> <span class="ot">{</span>X <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true"></a>      <span class="ot">→</span> c <span class="ot">{</span>X<span class="ot">}</span> ∘ a ≡ map G-functor a ∘ f ∘ map F-functor c</span></code></pre></div>
<p>where we can build two separate <code>Bialgebra swap</code>s:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a>bubbleSort <span class="ot">:</span> Bialgebra swap</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a>Bialgebra<span class="ot">.</span>a bubbleSort <span class="ot">=</span> cata bub</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a>Bialgebra<span class="ot">.</span>c bubbleSort <span class="ot">=</span> Mu</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a>Bialgebra<span class="ot">.</span>bialgebra-proof bubbleSort <span class="ot">=</span> <span class="co">-- left as homework</span></span></code></pre></div>
<p>and</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a>naiveInsertSort <span class="ot">:</span> Bialgebra swap</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a>Bialgebra<span class="ot">.</span>a naiveInsertSort <span class="ot">=</span> unNu</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a>Bialgebra<span class="ot">.</span>c naiveInsertSort <span class="ot">=</span> ana bub</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a>Bialgebra<span class="ot">.</span>bialgebra-proof naiveInsertSort <span class="ot">=</span> <span class="co">-- left as homework</span></span></code></pre></div>
<p>I’m not entirely confident about this, since as said earlier, I don’t have this formalized in Agda. It’s a shame, because this looks like it would be a lot of fun to do. We’re left with a final diagram, equaqting <code>cata (ana naiveIns)</code> and <code>ana (cata bub)</code>:</p>
<pre><code>                  ?fmap (cata (ana naiveIns))?
 Unsorted (Mu Unsorted)  - - - - -&gt;  Unsorted (Nu Sorted)
          |                                      |
      Mu  |                                      |  ana naiveIns
          v           cata (ana naiveIns)        v
      Mu Unsorted  - - - - - -|| - - - - -&gt;  Nu Sorted
          |             ana (cata bub)           |
cata bub  |                                      |  unNu
          v                                      v
   Sorted (Mu Unsorted)  - - - - - -&gt;  Sorted (Nu Sorted)
                   ?fmap (ana (cata bub)?</code></pre>
<p>The morphisms surrounded by question marks aren’t given in the paper, but I’ve attempted to fill them in. The ones I’ve given complete the square, but they’re the opposite of what I’d expect from the initial algebra / terminal coalgebra UMPs. This is something to come back to, I think, but is rather annoying since Agda would just tell me the damn answer.</p>
<h2 id="paramorphisms-and-apomorphisms">Paramorphisms and Apomorphisms</h2>
<p>Standard recursion scheme machinery:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a><span class="ot">para ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (f (<span class="dt">Mu</span> f, a) <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Mu</span> f <span class="ot">-&gt;</span> a</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a>para f <span class="ot">=</span> f <span class="op">.</span> <span class="fu">fmap</span> (<span class="fu">id</span> <span class="op">&amp;&amp;&amp;</span> para f) <span class="op">.</span> unMu</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true"></a><span class="ot">apo ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> f (<span class="dt">Either</span> (<span class="dt">Nu</span> f) a)) <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Nu</span> f</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true"></a>apo f <span class="ot">=</span> <span class="dt">Nu</span> <span class="op">.</span> <span class="fu">fmap</span> (<span class="fu">either</span> <span class="fu">id</span> (apo f)) <span class="op">.</span> f</span></code></pre></div>
<p>The idea is that <code>para</code>s can look at all the structure that hasn’t yet been folded, while <code>apo</code>s can exit early by giving a <code>Left</code>.</p>
<h2 id="insertion-and-selection-sort">Insertion and Selection Sort</h2>
<p>The paper brings us back to insertion sort. Instead of writing the naive version as a <code>cata . ana</code>, we will now try writing it as a <code>cata . apo</code>. Under this new phrasing, we get the type:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a>     <span class="dt">Unsorted</span> a (<span class="dt">Nu</span> (<span class="dt">Sorted</span> a))</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true"></a>  <span class="ot">-&gt;</span> <span class="dt">Sorted</span> a (<span class="dt">Either</span> (<span class="dt">Nu</span> (<span class="dt">Sorted</span> a))</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true"></a>                      (<span class="dt">Unsorted</span> a (<span class="dt">Nu</span> (<span class="dt">Sorted</span> a))))</span></code></pre></div>
<p>which is quite a meaningful type. Now, our type can signal that the resuling list is already sorted all the way through, or that we had to push an unsorted value inwards. As a result, <code>ins</code> looks exactly like <code>bub</code>, except that we can stop early in most cases, safe in the knowledge that we haven’t changed the sortedness of the rest of the list. The <code>b &lt; a</code> case is the only one which requires further recursion.</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a>ins</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true"></a><span class="ot">    ::</span> <span class="dt">Ord</span> a</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true"></a>    <span class="ot">=&gt;</span> <span class="dt">Unsorted</span> a (<span class="dt">Nu</span> (<span class="dt">Sorted</span> a))</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true"></a>    <span class="ot">-&gt;</span> <span class="dt">Sorted</span> a (<span class="dt">Either</span> (<span class="dt">Nu</span> (<span class="dt">Sorted</span> a))</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true"></a>                        (<span class="dt">Unsorted</span> a (<span class="dt">Nu</span> (<span class="dt">Sorted</span> a))))</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true"></a>ins <span class="dt">Nil</span>                 <span class="ot">=</span> <span class="dt">Nil</span></span>
<span id="cb28-7"><a href="#cb28-7" aria-hidden="true"></a>ins (a <span class="op">:&gt;</span> <span class="dt">Nu</span> <span class="dt">Nil</span>)       <span class="ot">=</span> a <span class="op">:&gt;</span> <span class="dt">Left</span> (<span class="dt">Nu</span> <span class="dt">Nil</span>)</span>
<span id="cb28-8"><a href="#cb28-8" aria-hidden="true"></a>ins (a <span class="op">:&gt;</span> <span class="dt">Nu</span> (b <span class="op">:&gt;</span> x))</span>
<span id="cb28-9"><a href="#cb28-9" aria-hidden="true"></a>  <span class="op">|</span> a <span class="op">&lt;=</span> b              <span class="ot">=</span> a <span class="op">:&gt;</span> <span class="dt">Left</span> (<span class="dt">Nu</span> (b <span class="op">:&gt;</span> x))  <span class="co">-- already sorted!</span></span>
<span id="cb28-10"><a href="#cb28-10" aria-hidden="true"></a>  <span class="op">|</span> <span class="fu">otherwise</span>           <span class="ot">=</span> b <span class="op">:&gt;</span> <span class="dt">Right</span> (a <span class="op">:&gt;</span> x)</span></code></pre></div>
<p>Let’s think now about selection sort. Which should be an <code>ana . para</code> by duality, with the resulting type:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a>     <span class="dt">Unsorted</span> a ( <span class="dt">Mu</span> (<span class="dt">Unsorted</span> a)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true"></a>                , <span class="dt">Sorted</span> a (<span class="dt">Mu</span> (<span class="dt">Unsorted</span> a))</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true"></a>                )</span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true"></a>  <span class="ot">-&gt;</span> <span class="dt">Sorted</span> a (<span class="dt">Mu</span> (<span class="dt">Unsorted</span> a))</span></code></pre></div>
<p>It’s much harder for me to parse any sort of meaning out of this type. Now our input has both all the unsorted remaining input, as well as a single term bubbling up. I actually can’t figure out how this helps us; presumably it’s something about laziness and not needing to do something with the sorted side’s unsorted tail? But I don’t know. Maybe a reader can drop a helpful comment.</p>
<p>Anyway, the paper gives us <code>sel</code> which implements the type:</p>
<pre><code>sel
    :: Ord a
    =&gt; Unsorted a ( Mu (Unsorted a)
                  , Sorted a (Mu (Unsorted a))
                  )
    -&gt; Sorted a (Mu (Unsorted a))
sel Nil                  = Nil
sel (a :&gt; (x, Nil))      = a :&gt; x
sel (a :&gt; (x, b :&gt; x&#39;))
  | a &lt;= b               = a :&gt; x
  | otherwise            = b :&gt; Mu (a :&gt; x&#39;)</code></pre>
<p>Getting an intution here as to why the <code>otherwise</code> case uses <code>x'</code> instead of <code>x</code> is an exercise left to the reader, who can hopefully let me in on the secret.</p>
<p>As before, we can pull a bialgebra out of <code>ins</code> and <code>sel</code>. This time, the input side uses the <code>(,)</code>, and the output uses <code>Either</code>, and I suppose we get the best of both worlds: early stopping, and presumably whatever caching comes from <code>(,)</code>:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true"></a>swop</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true"></a><span class="ot">    ::</span> <span class="dt">Ord</span> a</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true"></a>    <span class="ot">=&gt;</span> <span class="dt">Unsorted</span> a (x, <span class="dt">Sorted</span> a x)</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true"></a>    <span class="ot">-&gt;</span> <span class="dt">Sorted</span> a (<span class="dt">Either</span> x (<span class="dt">Unsorted</span> a x))</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true"></a>swop <span class="dt">Nil</span>                    <span class="ot">=</span> <span class="dt">Nil</span></span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true"></a>swop (a <span class="op">:&gt;</span> (x, <span class="dt">Nil</span>))        <span class="ot">=</span> a <span class="op">:&gt;</span> (<span class="dt">Left</span> x)</span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true"></a>swop (a <span class="op">:&gt;</span> (x, (b <span class="op">:&gt;</span> x&#39;)))</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true"></a>  <span class="op">|</span> a <span class="op">&lt;=</span> b                  <span class="ot">=</span> a <span class="op">:&gt;</span> <span class="dt">Left</span> x</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true"></a>  <span class="op">|</span> <span class="fu">otherwise</span>               <span class="ot">=</span> b <span class="op">:&gt;</span> <span class="dt">Right</span> (a <span class="op">:&gt;</span> x&#39;)</span></code></pre></div>
<p>This time our bialgebras are:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true"></a>insertSort <span class="ot">:</span> Bialgebra swop</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true"></a>Bialgebra<span class="ot">.</span>a insertSort <span class="ot">=</span> apo ins</span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true"></a>Bialgebra<span class="ot">.</span>c insertSort <span class="ot">=</span> id &amp;&amp;&amp; unNu</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true"></a>Bialgebra<span class="ot">.</span>bialgebra-proof insertSort <span class="ot">=</span> <span class="co">-- left as homework</span></span></code></pre></div>
<p>and</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true"></a>selectSort <span class="ot">:</span> Bialgebra swop</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true"></a>Bialgebra<span class="ot">.</span>a selectSort <span class="ot">=</span> para sel</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true"></a>Bialgebra<span class="ot">.</span>c selectSort <span class="ot">=</span> either id Mu</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true"></a>Bialgebra<span class="ot">.</span>bialgebra-proof selectSort <span class="ot">=</span> <span class="co">-- left as homework</span></span></code></pre></div>
<h2 id="quicksort-and-treesort">Quicksort and Treesort</h2>
<p>Lots of the same techniques, and I’m running out of time, so we’ll go quickly. The key insight thus far is that select sort and insert sort both suck. How do we go faster than <span class="math inline">\(O(n^2)\)</span>? Quicksort, and Treesort!</p>
<p>What’s interesting to me is I never considered Quicksort to be a tree-sorting algorithm. But of course it is; it’s recursively dividing an array in half, sorting each, and then putting them back together. But that fact is obscured by all of this “pivoting” nonsense; it’s just a <a href="https://www.youtube.com/watch?v=oaIMMclGuog">tree algorithm projected onto arrays</a>.</p>
<p>Hinze et al. present specialized versions of Quicksort and Treesort, but we’re just going to skip to the bialgebra bits:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Tree</span> a k <span class="ot">=</span> <span class="dt">Empty</span> <span class="op">|</span> <span class="dt">Node</span> k a k</span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true"></a>  <span class="kw">deriving</span> (<span class="dt">Eq</span>, <span class="dt">Ord</span>, <span class="dt">Show</span>, <span class="dt">Functor</span>)</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true"></a></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true"></a>sprout</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true"></a><span class="ot">    ::</span> <span class="dt">Ord</span> a</span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true"></a>    <span class="ot">=&gt;</span> <span class="dt">Unsorted</span> a (x, <span class="dt">Tree</span> a x)</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true"></a>    <span class="ot">-&gt;</span> <span class="dt">Tree</span> a (<span class="dt">Either</span> x (<span class="dt">Unsorted</span> a x))</span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true"></a>sprout <span class="dt">Nil</span>                <span class="ot">=</span> <span class="dt">Empty</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true"></a>sprout (a <span class="op">:&gt;</span> (x, <span class="dt">Empty</span>))  <span class="ot">=</span> <span class="dt">Node</span> (<span class="dt">Left</span> x) a (<span class="dt">Left</span> x)</span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true"></a>sprout (a <span class="op">:&gt;</span> (x, (<span class="dt">Node</span> l b r)))</span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true"></a>  <span class="op">|</span> a <span class="op">&lt;=</span> b                <span class="ot">=</span> <span class="dt">Node</span> (<span class="dt">Right</span> (a <span class="op">:&gt;</span> l)) b (<span class="dt">Left</span> r)</span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true"></a>  <span class="op">|</span> <span class="fu">otherwise</span>             <span class="ot">=</span> <span class="dt">Node</span> (<span class="dt">Left</span> l) b (<span class="dt">Right</span> (a <span class="op">:&gt;</span> r))</span></code></pre></div>
<p>This is the creation of a binary search tree. <code>Left</code> trees don’t need to be manipulated, and <code>Right</code> ones need to have the new unsorted element pushed down. The other half of the problem is to extract elements from the BST:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true"></a>wither</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true"></a><span class="ot">    ::</span> <span class="dt">Tree</span> a (x, <span class="dt">Sorted</span> a x)</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true"></a>    <span class="ot">-&gt;</span> <span class="dt">Sorted</span> a (<span class="dt">Either</span> x (<span class="dt">Tree</span> a x))</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true"></a>wither <span class="dt">Empty</span>                        <span class="ot">=</span> <span class="dt">Nil</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true"></a>wither (<span class="dt">Node</span> (_, <span class="dt">Nil</span>) a (r, _))     <span class="ot">=</span> a <span class="op">:&gt;</span> <span class="dt">Left</span> r</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true"></a>wither (<span class="dt">Node</span> (_, b <span class="op">:&gt;</span> l&#39;) a (r, _)) <span class="ot">=</span> b <span class="op">:&gt;</span> <span class="dt">Right</span> (<span class="dt">Node</span> l&#39; a r)</span></code></pre></div>
<p>I think I understand what’s going on here. We have a tree with nodes <code>a</code> and “subtrees” <code>Sorted a x</code>, where remember, <code>x</code> ties the knot. Thus, in the first level of the tree, our root node is the pivot, and then the left “subtree” is the subtree itself, plus a view on it corresponding to the smallest element in it. That is, in <code>(x, Sorted a x)</code>, the <code>fst</code> is the tree, and the <code>snd</code> is the smallest element that has already been pulled out.</p>
<p>So, if we have a left cons, we want to return that, since it’s necessarily smaller than our root. But we continue (via <code>Right</code>) with a new tree, using the same root and right sides, letting the recursion scheme machinery reduce that into its smallest term.</p>
<p>But I must admit that I’m hand-waving on this one. I suspect better understanding would come from getting better intutions behind <code>para</code> and <code>apo</code>.</p>
<p>Let’s tie things off then, since I’ve clearly hit my limit of understanding on this paper for this week. While having a deadline is a nice forcing function to actually go through papers, it’s not always the best for deeply understanding them! Alas, something to think about for the future.</p>
<p>We’re given two implementations of <code>grow</code>:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true"></a>grow,<span class="ot"> grow&#39; ::</span> <span class="dt">Mu</span> <span class="dt">Unsorted</span> <span class="ot">-&gt;</span> <span class="dt">Nu</span> <span class="dt">Tree</span></span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true"></a>grow  <span class="ot">=</span> ana  <span class="op">.</span> para <span class="op">$</span> <span class="fu">fmap</span> (<span class="fu">either</span> <span class="fu">id</span> unNu) <span class="op">.</span> sprout</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true"></a>grow&#39; <span class="ot">=</span> cata <span class="op">.</span> apo  <span class="op">$</span> sprout <span class="op">.</span> <span class="fu">fmap</span> (<span class="fu">id</span> <span class="op">&amp;&amp;&amp;</span> <span class="dt">Mu</span>)</span></code></pre></div>
<p>as well as two for <code>flatten</code>:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true"></a>flatten,<span class="ot"> flatten&#39; ::</span> <span class="dt">Mu</span> <span class="dt">Tree</span> <span class="ot">-&gt;</span> <span class="dt">Nu</span> <span class="dt">Sorted</span></span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true"></a>grow  <span class="ot">=</span> cata <span class="op">.</span> apo  <span class="op">$</span> wither <span class="op">.</span> <span class="fu">fmap</span> (<span class="fu">id</span> <span class="op">&amp;&amp;&amp;</span> unNu)</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true"></a>grow&#39; <span class="ot">=</span> ana  <span class="op">.</span> para <span class="op">$</span> <span class="fu">fmap</span> (<span class="fu">either</span> <span class="fu">id</span> <span class="dt">Mu</span>) <span class="op">.</span> wither</span></code></pre></div>
<p>and then finally, give us <code>quickSort</code> and <code>treeSort</code>:</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true"></a>quickSort,<span class="ot"> treeSort ::</span> <span class="dt">SortingFunc</span> a</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true"></a>quickSort <span class="ot">=</span> flatten  <span class="op">.</span> downcast <span class="op">.</span> grow</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true"></a>treeSort  <span class="ot">=</span> flatten&#39; <span class="op">.</span> downcast <span class="op">.</span> grow&#39;</span></code></pre></div>
<p>where <code>downcast</code> was given earlier as:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true"></a><span class="ot">downcast ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> <span class="dt">Nu</span> f <span class="ot">-&gt;</span> <span class="dt">Mu</span> f</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true"></a>downcast <span class="ot">=</span> <span class="dt">Mu</span> <span class="op">.</span> <span class="fu">fmap</span> downcast <span class="op">.</span> unNu</span></code></pre></div>
<p>This is interesting, but comes with an obvious questions: what if we intermix <code>flatten</code> with <code>grow'</code>, and vice versa? Rather unexcitingly, they still sort the list, and don’t seem to have different asymptotics. As a collorary, we must thus be excited, and assume that these are two “new” sorting functions, at least, ones without names. I guess that’s not too surprising; there are probably infinite families of sorting functions.</p>
<h2 id="conclusions-notes-to-self">Conclusions / Notes to Self</h2>
<p>What a fun paper! I did a bad thing by jumping into Agda too quickly, hoping it would let me formalize the “this is a sorted list” stuff. But that turned out to be premature, since the <code>Sorted</code> wrapper is only ever a pair, and exists only to signal some information to the reader. Thus, I spent six hours working through the Agda stuff before realizing my deadline was coming up sooner than later.</p>
<p>Implicit in that paragraph is that I started implementing before I had read through the entire paper, which was unwise, as it meant I spent a lot of time on things that turned out to be completely unrelated. Note to self to not do this next time.</p>
<p>Also, it turns out I’m not as firm on recursion schemes as I thought! It’d be valuable for me to go through <code>para</code>s in much more depth than I have now, and to work harder at following the stuff in this paper. How do the authors keep everything straight? Do they just have more experience, or are they using better tools than I am?</p>
        ]]>
      </content>
    </entry>
    <entry>
      <title>Underlining the Bugs</title>
      <id>blog/underline-bugs/index.html</id>
      <link href='blog/underline-bugs/index.html'/>
      <published>2022-01-31T21:46:00Z</published>
      <updated>2022-01-31T21:46:00Z</updated>

      <content type="html">
        <![CDATA[
        <p>I had a magical Haskell experience today, and want to share the story.</p>
<p>My current big programming project is <a href="https://github.com/isovector/cornelis"><code>cornelis</code></a> — a vim plugin for interacting with Agda. The Agda compiler is really good at doing interactive programming, but until <code>cornelis</code>, all of this functionality has been locked away, only to be used by blessed emacs developers.</p>
<p>Tooling for (neo)vim has gotten really good since I last looked at it, and these days you can write plugins in a language of your choice. For anyone lucky enough to not appreciate how lovely this is, vimscript’s comparison operator checks a global flag to see if it should be case-sensitive or not. From that perspective, it’s truly a testament that <em>anyone</em> has managed to write <em>anything</em> for vim.</p>
<p>The Haskell library for talking to (neo)vim is <a href="https://github.com/neovimhaskell/nvim-hs">particularly excellent</a>, and I would strongly recommend it if you’re thinking about writing a vim plugin.</p>
<p>So anyway, the Agda compiler has this cool mode where you can send it queries about your code, and it gives back answers in JSON. For example, you might ask “what type does this thing have?” or “please case split this for me” and Agda will give you back answers. A plugin like <code>cornelis</code> or <code>agda-mode</code> (for emacs) can turn Agda’s responses into a lovely editing environment, where the computer does most of the work of programming for you.</p>
<p>Agda doesn’t actually make any changes for you, it just says things like “replace from characters 5 to 10 on line 17 with <code>foo</code>.” This is nice for editor integration, since Agda doesn’t assume anything about your editing environment.</p>
<p>Rather interestingly, Agda even does its <em>syntax</em> highlighting like this. You ask the compiler what colors things should have, and it responds. Editor plugins just need to attach that information to the buffer, and you never need to write another janky regex.</p>
<p>One of the first things I implemented in <code>cornelis</code> was this syntax highlighting. My first attempt looked something like this:</p>
<figure>
<img src="/images/underline/highlighting.png" alt="" /><figcaption>Syntax Highlighting</figcaption>
</figure>
<p>It’s… <em>almost</em> right. But those deep yellows should extend to the end of each line! However, notice that each of the light yellows on the left of the <code>:</code>s are right. So whatever’s going wrong here is getting reset every line.</p>
<p>Looking closely at the subscript 1 on <code>f</code> gives us a clue what’s going wrong — unicode characters are throwing off the highlighting ranges! Some swearing and digging into the vim documentation shows that vim expects its highlighting ranges to be <em>byte-indexed</em> for some insane reason. Agda uses a lot of unicode, and (rightly) reports locations by their character-index, not their byte-index.</p>
<p>The solution was to get the text being highlighted, and count its actual bytes in order to fix the numbers being sent to vim. Annoying, but workable. I left a comment and went on with my day.</p>
<p>The next day, I was working on another feature, which is essentially interacting with typed-holes. The idea is you move your cursor over the hole, and then ask Agda to do something with it. But, sometimes, Agda would yell at me and say there was no hole there! Sure enough, that sometimes was when there was a unicode character earlier on the line. Same bug, same fix.</p>
<p>Then the day after that, another bug caused by this unicode length stuff. OK, three strikes and you’re out. It was time to fix this bug once and for all. Fundamentally, the issue is that Agda-offsets don’t agree with Vim-offsets, which sounds like a type error to me. It seemed hard to patch the vim API, but I controlled all of the Agda-serialization stuff, so I <a href="https://github.com/isovector/cornelis/commit/d52708164d9e1e34a3ef941235d1396bacc937f7">made a patch</a>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="va">+ data OffsetType = Line | File</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a><span class="va">+</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a><span class="va">+ newtype Offset (a :: OffsetType) = Offset Int32</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a><span class="va">+   deriving stock Data</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a><span class="va">+   deriving newtype (Eq, Ord, Show, Read, FromJSON)</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a><span class="va">+</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true"></a><span class="va">+ type BufferOffset = Offset &#39;File</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true"></a><span class="va">+ type LineOffset = Offset &#39;Line</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true"></a>  data Position&#39; a = Pn</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true"></a>    { srcFile :: !a</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true"></a><span class="st">-   , posPos  :: !Int32</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true"></a><span class="va">+   , posPos  :: !BufferOffset</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true"></a>    , posLine :: !Int32</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true"></a><span class="st">-   , posCol  :: !Int32</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true"></a><span class="va">+   , posCol  :: !LineOffset</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true"></a>    }</span></code></pre></div>
<p>and then changed the types of the bug-fixing functions:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode diff"><code class="sourceCode diff"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="st">- toBytes :: Text -&gt; Int -&gt; Int</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a><span class="va">+ toBytes :: Text -&gt; Offset a -&gt; Int</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true"></a><span class="st">- fromBytes :: Text -&gt; Int -&gt; Int</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true"></a><span class="va">+ fromBytes :: Text -&gt; Int -&gt; Offset a</span></span></code></pre></div>
<p>After doing some plumbing to change all the function types to refer to <code>BufferOffset</code> and <code>LineOffset</code> rather than <code>Int</code>, I was left with a few type errors in the program: <em>corresponding exactly with the bug I had set out to fix, and two others I didn’t know about!</em></p>
<figure>
<img src="/images/underline/underline.png" alt="" /><figcaption>Underlined Bugs</figcaption>
</figure>
<p>Let me restate that. The computer <em>underlined the bugs</em> in my program. It found bugs in code I’d already written.</p>
<p>If this isn’t one of the best arguments for static typing, I can’t imagine what would be.</p>
        ]]>
      </content>
    </entry>
    <entry>
      <title>Review: Copatterns</title>
      <id>blog/review-copatterns/index.html</id>
      <link href='blog/review-copatterns/index.html'/>
      <published>2022-01-29T11:39:00Z</published>
      <updated>2022-01-29T11:39:00Z</updated>

      <content type="html">
        <![CDATA[
        <p>Another week, another paper review. This week my plan was to look at the word2vec paper, but I made the mistake of not looking into it early in the week, and by the time I did, it was extremely underwhelming. So instead, we’re going to take a look at Abel, Pientka, Thibodeau and Setzer’s <a href="http://www2.tcs.ifi.lmu.de/~abel/popl13.pdf">Copatterns: Programming Infinite Structures by Observations</a>.</p>
<p>In this paper, Abel et al. present <em>copatterns,</em> the categorical duals of pattern matching. I’d briefly encountered copatterns when playing with Agda, but thought it was just a funny syntax for building records. I didn’t look much into it — instead being distracted by all the cool things I could do with dependent types.</p>
<p>The paper presents copatterns, gives some motivating examples, and then does a bunch of type theory stuff to prove they play nicely. Today I’m going to look only at the first two sections, omitting the type theory stuff. Not because I’m not interested, but because I’d like to find a nice introductory paper to type theory stuff, rather than try to hammer it through my thick skull at the same time as trying to figure out what Abel et al. are trying to show me. Note to self, that would be a good paper to tackle for next week.</p>
<p>So, what is a copattern? While patterns let us map out of inductive types, copatterns let us map into coinductive types. Right, ok, but what does that really mean? Pattern matching lets us branch on the way a piece of data was built. But dually, copattern matching lets us branch to define a piece of codata.</p>
<p>Some examples will help.</p>
<p>The paper: “one should distinguish between finite, inductive data defined by constructors and infinite, coinductive data which is better described by observations… one can declare codatatypes via a list of their destructors.”</p>
<p>It’s a little hard to see this for me, coming from Haskell where laziness lets us play very fast and loose in the differences between data and codata. But fundamentally, data is built inductively: by taking smaller pieces, and assembling them into something bigger. Thus, data is always finite.</p>
<h2 id="streams">Streams</h2>
<p>Codata, however, is infinite, and accomplishes that by being built out of <em>bigger</em> pieces. The canonical example given to us is a <code>Stream</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">record</span> Stream <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true"></a>  <span class="kw">coinductive</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true"></a>  <span class="kw">constructor</span> <span class="ot">_</span>:&gt;<span class="ot">_</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true"></a>  <span class="kw">field</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true"></a>    head <span class="ot">:</span> A</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true"></a>    tail <span class="ot">:</span> Stream A</span></code></pre></div>
<p>In order to build a <code>Stream A</code>, <em>you must already have one.</em> There is no base case! That’s actually pretty wild, if you think about it!</p>
<p>Returning to the paper, we can think of <code>Stream</code>s as being opaque objects, equipped with two observations:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a>head <span class="ot">:</span> Stream A <span class="ot">-&gt;</span> A</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true"></a>tail <span class="ot">:</span> Stream A <span class="ot">-&gt;</span> Stream A</span></code></pre></div>
<p>and fact, any other observation on <code>Stream</code>s “factors out” into at least one of these observations (by virtue of their being the definition of <code>Stream</code>.) The paper gives an example of a stream producer that builds the stream <code>N, N-1, N-2, ..., 0, N, N-1 ...</code>. Their presentation leaves a bit to be desired, so I’ve changed it a little here:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a>cycleNats <span class="ot">:</span> Nat <span class="ot">-&gt;</span> Nat <span class="ot">-&gt;</span> Stream Nat</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a>cycleNats N x <span class="ot">=</span> ?</span></code></pre></div>
<p>where <code>N</code> is the <code>Nat</code> we’re counting down from, and <code>x</code> is the <code>Nat</code> we’re currently at. Here, we’d like to <em>build</em> a <code>Stream</code>, and the idea of copatterns is that we can define a function by defining every observation over it:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a>cycleNats <span class="ot">:</span> Nat <span class="ot">-&gt;</span> Nat <span class="ot">-&gt;</span> Stream Nat</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>Stream<span class="ot">.</span>head <span class="ot">(</span>cycleNats N x<span class="ot">)</span> <span class="ot">=</span> ?</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true"></a>Stream<span class="ot">.</span>tail <span class="ot">(</span>cycleNats N x<span class="ot">)</span> <span class="ot">=</span> ?</span></code></pre></div>
<p>Take a moment to think about what’s going on here, because it’s <em>fucking crazy</em> if you’re coming from Haskell like I am. We are defining <code>cycleNats</code> by giving two projections <em>out of it!</em> The <code>head</code> projection is easy to fill in:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a>cycleNats <span class="ot">:</span> Nat <span class="ot">-&gt;</span> Nat <span class="ot">-&gt;</span> Stream Nat</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>Stream<span class="ot">.</span>head <span class="ot">(</span>cycleNats <span class="ot">_</span> x<span class="ot">)</span> <span class="ot">=</span> x</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true"></a>Stream<span class="ot">.</span>tail <span class="ot">(</span>cycleNats N x<span class="ot">)</span> <span class="ot">=</span> ?</span></code></pre></div>
<p>but in the tail case, we want to wrap around from <code>x = zero</code> back to <code>x = N</code>. Thus, we can do a usual, everyday <strong>pattern</strong> match on <code>x</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a>cycleNats <span class="ot">:</span> Nat <span class="ot">-&gt;</span> Nat <span class="ot">-&gt;</span> Stream Nat</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>Stream<span class="ot">.</span>head <span class="ot">(</span>cycleNats <span class="ot">_</span> x<span class="ot">)</span> <span class="ot">=</span> x</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true"></a>Stream<span class="ot">.</span>tail <span class="ot">(</span>cycleNats N zero<span class="ot">)</span> <span class="ot">=</span> ?</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true"></a>Stream<span class="ot">.</span>tail <span class="ot">(</span>cycleNats N <span class="ot">(</span>suc x<span class="ot">))</span> <span class="ot">=</span> ?</span></code></pre></div>
<p>and can now give the <code>tail</code> projections of <code>cycleNats</code> in terms of <code>cycleNats</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a>cycleNats <span class="ot">:</span> Nat <span class="ot">-&gt;</span> Nat <span class="ot">-&gt;</span> Stream Nat</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>Stream<span class="ot">.</span>head <span class="ot">(</span>cycleNats <span class="ot">_</span> x<span class="ot">)</span> <span class="ot">=</span> x</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a>Stream<span class="ot">.</span>tail <span class="ot">(</span>cycleNats N zero<span class="ot">)</span> <span class="ot">=</span> cycleNats N N</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a>Stream<span class="ot">.</span>tail <span class="ot">(</span>cycleNats N <span class="ot">(</span>suc x<span class="ot">))</span> <span class="ot">=</span> cycleNats N x</span></code></pre></div>
<p>Amazingly, Agda accepts this program.</p>
<p>So what happened here? We defined a function that produces a coinductive type indirectly, by giving the projections <em>out</em> of the function. The copatterns build new function heads, in which we can do everyday pattern matching to help refine the cases further.</p>
<p>For the sake of comparison, I wanted to write <code>cycleNats</code> without copatterns, just to get a sense for it:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="pp">{-# TERMINATING #-}</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true"></a>cycleNats&#39; <span class="ot">:</span> Nat <span class="ot">-&gt;</span> Nat <span class="ot">-&gt;</span> Stream Nat</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true"></a>cycleNats&#39; N zero <span class="ot">=</span> zero :&gt; cycleNats&#39; N N</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true"></a>cycleNats&#39; N <span class="ot">(</span>suc x<span class="ot">)</span> <span class="ot">=</span> suc x :&gt; cycleNats&#39; N x</span></code></pre></div>
<p>For arcane reasons I don’t understand, I need to mark <code>cycleNats'</code> as <code>TERMINATING</code> (but it’s not) in order for Agda to let me do any reasoning over it.</p>
<p>Presented like this, the copattern version is definitely doing some work; it lets us factor out the shared logic for defining the <code>head</code>. The copattern version doesn’t yet feel natural to me, but that might be a byproduct of having my brain stuck in Haskell land for the better part of a decade.</p>
<h2 id="lift-instances-over-newtypes">Lift Instances over Newtypes</h2>
<p>We can write <code>Monad</code>s in Agda:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">record</span> Monad <span class="ot">(</span>M <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">-&gt;</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>  <span class="kw">constructor</span> is-monad</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true"></a>  <span class="kw">field</span></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true"></a>    pure <span class="ot">:</span> <span class="ot">{</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">-&gt;</span> A <span class="ot">-&gt;</span> M A</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true"></a>    <span class="ot">_</span>&gt;&gt;=<span class="ot">_</span> <span class="ot">:</span> <span class="ot">{</span>A B <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">-&gt;</span> M A <span class="ot">-&gt;</span> <span class="ot">(</span>A <span class="ot">-&gt;</span> M B<span class="ot">)</span> <span class="ot">-&gt;</span> M B</span></code></pre></div>
<p>and then define the <code>State</code> monad:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a>State <span class="ot">:</span> <span class="dt">Set</span> <span class="ot">-&gt;</span> <span class="dt">Set</span> <span class="ot">-&gt;</span> <span class="dt">Set</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>State S A <span class="ot">=</span> S <span class="ot">-&gt;</span> S × A</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true"></a>Monad-State <span class="ot">:</span> <span class="ot">{</span>S <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">-&gt;</span> Monad <span class="ot">(</span>State S<span class="ot">)</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true"></a>pure Monad-State a s <span class="ot">=</span> s , a</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true"></a><span class="ot">_</span>&gt;&gt;=<span class="ot">_</span> Monad-State ma f s <span class="ot">=</span></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true"></a>  <span class="kw">let</span> s&#39; , a <span class="ot">=</span> ma s</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true"></a>   <span class="kw">in</span> f a s&#39;</span></code></pre></div>
<p>where we have used a copattern to define the <code>Monad</code> methods for <code>Monad-State</code>. But, the paper says, what if we want to implement <code>State</code> as a new type, rather than just a type alias? Fine:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="kw">record</span> State&#39; <span class="ot">(</span>S <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">(</span>A <span class="ot">:</span> <span class="dt">Set</span><span class="ot">)</span> <span class="ot">:</span> <span class="dt">Set</span> <span class="kw">where</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true"></a>  <span class="kw">constructor</span> state</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true"></a>  <span class="kw">field</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true"></a>    runState <span class="ot">:</span> S <span class="ot">-&gt;</span> S × A</span></code></pre></div>
<p>If we’d like now to give an instance of <code>Monad</code> for <code>State'</code>, the straight-forward way is to explicitly use the constructor to build a <code>State'</code>:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a>Monad-State₁ <span class="ot">:</span> <span class="ot">{</span>S <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">-&gt;</span> Monad <span class="ot">(</span>State&#39; S<span class="ot">)</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>pure Monad-State₁ a <span class="ot">=</span> state <span class="ot">λ</span> s <span class="ot">-&gt;</span> s , a</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a><span class="ot">_</span>&gt;&gt;=<span class="ot">_</span> Monad-State₁ ma f <span class="ot">=</span> state <span class="ot">λ</span> s <span class="ot">-&gt;</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>  <span class="kw">let</span> s&#39; , a <span class="ot">=</span> runState ma s</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true"></a>   <span class="kw">in</span> runState <span class="ot">(</span>f a<span class="ot">)</span> s&#39;</span></code></pre></div>
<p>This is fine, but we’ve lost some symmetry with <code>Monad-State</code> — namely, we can no longer bind <code>s</code> on the left side of the equals sign, and we have this noisy <code>state</code> thing everywhere.</p>
<p>Instead, the paper points out, we can use a copattern binding to define <code>Monad</code> for <code>State' S</code>. Not, mind you, a copattern to match on the monad methods, but a copattern to match on <code>runState</code> inside of the monad methods:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a>Monad-State₂ <span class="ot">:</span> <span class="ot">{</span>S <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">-&gt;</span> Monad <span class="ot">(</span>State&#39; S<span class="ot">)</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a>runState <span class="ot">(</span>pure Monad-State₂ a<span class="ot">)</span> s <span class="ot">=</span> s , a</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a>runState <span class="ot">(_</span>&gt;&gt;=<span class="ot">_</span> Monad-State₂ ma f<span class="ot">)</span> s <span class="ot">=</span></span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true"></a>  <span class="kw">let</span> s&#39; , a <span class="ot">=</span> runState ma s</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true"></a>   <span class="kw">in</span> runState <span class="ot">(</span>f a<span class="ot">)</span> s&#39;</span></code></pre></div>
<p>This is <em>much</em> nicer than <code>Monad-State₁</code>! All of a sudden, <code>state</code> is gone, we can match <code>s</code> on the left side of the equals, and the whole thing looks a lot like <code>runState</code> over the original (type-synonymed) version of <code>Monad-State</code>.</p>
<p>What’s also interesting here is the composition of copatterns; we’re defining <code>Monad</code> by giving it in terms of <code>pure</code> and <code>_&gt;&gt;=</code>, and then defining <em>those</em> by way of observing them via <code>runState</code>. I hadn’t noticed or appreciated this the first time through the paper, so it seems like my review project is facilitating more learning than I would be doing otherwise.</p>
<h2 id="fibonacci-numbers">Fibonacci Numbers</h2>
<p>As another example, the authors show us how to construct the Fibonacci numbers. Consider the following definition, in Haskell:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a>fib <span class="op">:</span> [<span class="dt">Int</span>]</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>fib <span class="ot">=</span> <span class="dv">0</span> <span class="op">:</span> <span class="dv">1</span> <span class="op">:</span> <span class="fu">zipWith</span> (<span class="op">+</span>) fib (<span class="fu">tail</span> fib)</span></code></pre></div>
<p>We can implement this too (but over <code>Stream Nat</code>) with copatterns. But first, let’s define <code>zipWith</code>:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a>zipWith <span class="ot">:</span> <span class="ot">{</span>A B C <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">(</span>A <span class="ot">-&gt;</span> B <span class="ot">-&gt;</span> C<span class="ot">)</span> <span class="ot">-&gt;</span> Stream A <span class="ot">-&gt;</span> Stream B <span class="ot">-&gt;</span> Stream C</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>zipWith f sa sb <span class="ot">=</span> ?</span></code></pre></div>
<p>I think I’m starting to get the hang of this, so I tried defining it via a copattern, and the result was actually quite delightful:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a>zipWith <span class="ot">:</span> <span class="ot">{</span>A B C <span class="ot">:</span> <span class="dt">Set</span><span class="ot">}</span> <span class="ot">-&gt;</span> <span class="ot">(</span>A <span class="ot">-&gt;</span> B <span class="ot">-&gt;</span> C<span class="ot">)</span> <span class="ot">-&gt;</span> Stream A <span class="ot">-&gt;</span> Stream B <span class="ot">-&gt;</span> Stream C</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a>head <span class="ot">(</span>zipWith f sa sb<span class="ot">)</span> <span class="ot">=</span> f <span class="ot">(</span>head sa<span class="ot">)</span> <span class="ot">(</span>head sb<span class="ot">)</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>tail <span class="ot">(</span>zipWith f sa sb<span class="ot">)</span> <span class="ot">=</span> zipWith f <span class="ot">(</span>tail sa<span class="ot">)</span> <span class="ot">(</span>tail sb<span class="ot">)</span></span></code></pre></div>
<p>I really like how the copattern syntax makes clear the homomorpic nature of <code>zipWith</code>.</p>
<p>We can now give a copattern definition for <code>fib</code>, where we explicitly copattern match on the first two terms:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode agda"><code class="sourceCode agda"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>fib <span class="ot">:</span> Stream Nat</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a>head fib <span class="ot">=</span> zero</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>head <span class="ot">(</span>tail fib<span class="ot">)</span> <span class="ot">=</span> suc zero</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a>tail <span class="ot">(</span>tail fib<span class="ot">)</span> <span class="ot">=</span> zipWith <span class="ot">_</span>+<span class="ot">_</span> fib <span class="ot">(</span>tail fib<span class="ot">)</span></span></code></pre></div>
<p>Again, notice the composition of copatterns here, in last two cases.</p>
<p>I’m not sure how I feel about this definition; maybe it’s clearer to the math guys, but this one is a little harder for me to wrap my head around.</p>
<h2 id="conclusion">Conclusion</h2>
<p>The rest of the paper is type theory stuff. There are quite a lot of gammas and turnstiles, way more than I want to try tackling today. But nevertheless, <em>Copatterns</em> has given me a significantly better understanding of that “weird record syntax” I’d seen in Agda. I don’t yet love the copattern formulation of every example presented in the paper, but will admit that <code>Monad-State₂</code> and <code>zipWith</code> are particularly beautiful under copatterns.</p>
<p>As usual, <a href="https://gist.github.com/isovector/37a1c1e21a3618e4f4885482a1454396">the code is on Github.</a></p>
        ]]>
      </content>
    </entry>
    <entry>
      <title>Review: Clowns to the Left of Me, Jokers to the Right</title>
      <id>blog/clowns-jokers/index.html</id>
      <link href='blog/clowns-jokers/index.html'/>
      <published>2022-01-23T13:49:00Z</published>
      <updated>2022-01-23T13:49:00Z</updated>

      <content type="html">
        <![CDATA[
        <p>Another week, another paper. This week it’s McBride’s <a href="http://strictlypositive.org/CJ.pdf">Clowns to the Left of Me, Jokers to the Right</a> (CJ). At a high level, CJ generalizes the results from <a href="http://strictlypositive.org/diff.pdf">The Derivative of a Regular Type is its Type of One-Hole Contexts</a>, wondering about what happens to a zipper when we don’t require the elements on either side to have the same type. This turns out to be not just an idle curiosity; the technique can be used to automatically turn a <a href="/blog/recursion-schemes">catamorphism</a> into a tail-recursive function. Why is THAT useful? It lets us run functional programs on stock hardware.</p>
<p>The paper begins by reminding us that all algebraic types can be built out of compositions of functors. Furthermore, any recursive ADT can be represented as the fix-point of its base functor. For example, rather than writing</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Expr</span> <span class="ot">=</span> <span class="dt">Val</span> <span class="dt">Int</span> <span class="op">|</span> <span class="dt">Add</span> <span class="dt">Expr</span> <span class="dt">Expr</span></span></code></pre></div>
<p>we can instead pull the recursive inlining of <code>Expr</code> out into a type argument:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">ExprF</span> a <span class="ot">=</span> <span class="dt">ValF</span> <span class="dt">Int</span> <span class="op">|</span> <span class="dt">AddF</span> a a</span></code></pre></div>
<p>and then can tie the knot:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">Fix</span> f <span class="ot">=</span> <span class="dt">Fix</span> {<span class="ot"> unFix ::</span> f (<span class="dt">Fix</span> f) }</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true"></a></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true"></a><span class="kw">type</span> <span class="dt">Expr</span> <span class="op">~=</span> <span class="dt">Fix</span> <span class="dt">ExprF</span></span></code></pre></div>
<p>This is all standard <a href="/blog/recursion-schemes">bananas and barbed wires</a>, machinery, so refer to that if you’d like a deeper presentation than I’ve provided here.</p>
<p>Rather than go through the paper’s presentation of this section, I will merely point out that <code>GHC.Generics</code> witnesses the “all ADTs can be built out of functor composition,” and give <code>ExprF</code> a <code>Generic1</code> instance:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">ExprF</span> a <span class="ot">=</span> <span class="dt">ValF</span> <span class="dt">Int</span> <span class="op">|</span> <span class="dt">AddF</span> a a</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true"></a>  <span class="kw">deriving</span> stock (<span class="dt">Functor</span>, <span class="dt">Generic1</span>)</span></code></pre></div>
<h2 id="clowns-and-jokers">Clowns and Jokers</h2>
<p>The title of CJ is a throw-back to <a href="https://www.youtube.com/watch?v=8StG4fFWHqg">some boomer song</a>, whose lyrics go</p>
<blockquote>
<p>Clowns to the left of me! Jokers to the right! Here I am stuck in the middle with you.</p>
</blockquote>
<p>while this is an apt idea for what’s going on in the paper, it’s also an awful mnemonic for those of us who don’t have strong associations with the song. My mnemonic is that “clowns” come sooner in a lexicographical ordering than “jokers” do. Likewise, work you’ve already done comes before work you haven’t yet done, which is <em>really</em> what CJ is about.</p>
<p>So here’s the core idea of CJ: we can “dissect” a traversal into work we’ve already done, and work we haven’t yet done. The work we’ve already done can have a different type than the stuff left to do. These dissections are a rather natural way of representing a suspended computation. Along with the dissection itself is the ability to make progress. A dissection is spiritually a zipper with different types on either side, so we can make progress by transforming the focused element from “to-do” to “done”, and then focusing on the next element left undone.</p>
<p>CJ implements all of this as a typeclass with fundeps, but I prefer type families. And furthermore, since this is all generic anyway, why not implement it over <code>GHC.Generics</code>? So the game here is thus to compute the type of the dissection for each of the <code>Generic1</code> constructors.</p>
<p>Begin by building the associated type family. The dissected version of a functor is necessarily a bifunctor, since we want slots to store our clowns and our jokers:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">GDissectable</span> p <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true"></a>  <span class="kw">type</span> <span class="dt">GDissected</span><span class="ot"> p ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span></code></pre></div>
<p>As usual, we lift <code>GDissectable</code> over <code>M1</code>:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">GDissectable</span> f <span class="ot">=&gt;</span> <span class="dt">GDissectable</span> (<span class="dt">M1</span> _1 _2 f) <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true"></a>  <span class="kw">type</span> <span class="dt">GDissected</span> (<span class="dt">M1</span> _1 _2 f) <span class="ot">=</span> <span class="dt">GDissected</span> f</span></code></pre></div>
<p>Because a dissection is a separation of the work we have and haven’t done yet, the cases for <code>U1</code> and <code>K1</code> are uninspired — there is no work to do, since they’re constants!</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">GDissectable</span> <span class="dt">U1</span> <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true"></a>  <span class="kw">type</span> <span class="dt">GDissected</span> <span class="dt">U1</span> <span class="ot">=</span> <span class="dt">K2</span> <span class="dt">Void</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">GDissectable</span> (<span class="dt">K1</span> _1 a) <span class="kw">where</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true"></a>  <span class="kw">type</span> <span class="dt">GDissected</span> (<span class="dt">K1</span> _1 a) <span class="ot">=</span> <span class="dt">K2</span> <span class="dt">Void</span></span></code></pre></div>
<p>where <code>K2</code> is the constant bifunctor:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">K2</span> a x y <span class="ot">=</span> <span class="dt">K2</span> a</span></code></pre></div>
<p>A different way to think about these dissections is as generalized zippers, which are the derivatives of their underlying types. Since <code>U1</code> and <code>K1</code> are constants, their derivatives are zero, which we have shown here via <code>K2 Void</code>.</p>
<p>The <code>Par1</code> generic constructor is used to encode usages of the functor’s type parameter. Under the view of the derivative, this is a linear use of the variable, and thus its derivative is one:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true"></a><span class="kw">instance</span> <span class="dt">GDissectable</span> <span class="dt">Par1</span> <span class="kw">where</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true"></a>  <span class="kw">type</span> <span class="dt">GDissected</span> <span class="dt">Par1</span> <span class="ot">=</span> <span class="dt">K2</span> ()</span></code></pre></div>
<p>We’re left with sums and products. Sums are easy enough: the dissection of the sum is the sum of the dissections.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true"></a><span class="kw">instance</span> (<span class="dt">GDissectable</span> f, <span class="dt">GDissectable</span> g) <span class="ot">=&gt;</span> <span class="dt">GDissectable</span> (f <span class="op">:+:</span> g) <span class="kw">where</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true"></a>  <span class="kw">type</span> <span class="dt">GDissected</span> (f <span class="op">:+:</span> g) <span class="ot">=</span> <span class="dt">Sum2</span> (<span class="dt">GDissected</span> f) (<span class="dt">GDissected</span> g)</span></code></pre></div>
<p>where</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Sum2</span> f g a b <span class="ot">=</span> <span class="dt">L2</span> (f a b) <span class="op">|</span> <span class="dt">R2</span> (g a b)</span></code></pre></div>
<p>Again, this aligns with our notion of the derivative, as well as with our intuition. If I want to suspend a coproduct computation half way, I either have an <code>L1</code> I need to suspend, or I have an <code>R1</code>. Nifty.</p>
<p>Finally we come to products:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true"></a><span class="kw">instance</span> (<span class="dt">GDissectable</span> f, <span class="dt">GDissectable</span> g) <span class="ot">=&gt;</span> <span class="dt">GDissectable</span> (f <span class="op">:*:</span> g) <span class="kw">where</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true"></a>  <span class="kw">type</span> <span class="dt">GDissected</span> (f <span class="op">:*:</span> g) <span class="ot">=</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true"></a>    <span class="dt">Sum2</span> (<span class="dt">Product2</span> (<span class="dt">GDissected</span> f) (<span class="dt">Joker</span> g))</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true"></a>         (<span class="dt">Product2</span> (<span class="dt">Clown</span> f) (<span class="dt">GDissected</span> g))</span></code></pre></div>
<p>where</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Clown</span> p a b <span class="ot">=</span> <span class="dt">Clown</span> (p a)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Joker</span> p a b <span class="ot">=</span> <span class="dt">Joker</span> (p b)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Product2</span> f g a b <span class="ot">=</span> <span class="dt">Product2</span> (f a b) (g a b)</span></code></pre></div>
<p>Let’s reason by intuition here first. I have both an <code>f</code> and a <code>g</code> stuck together. If I’d like to suspend a traversal through this thing, either I am suspended in the <code>f</code>, with <code>g</code> not yet touched (<code>Joker g</code>), or I have made it through the <code>f</code> entirely (<code>Clown f</code>), and have suspended inside of <code>g</code>.</p>
<p>Rather unsurprisingly (but also surprisingly, depending on your point of view!), this corresponds exactly to the quotient chain rule:</p>
<p><span class="math display">\[
\frac{d}{dx}[f(x)\cdot{}g(x)] = f(x)\cdot{}g&#39;(x) + f&#39;(x)\cdot{}g(x)
\]</span></p>
<p>Curry-Howard strikes in the most interesting of places!</p>
<h2 id="getting-started">Getting Started</h2>
<p>With our dissected types defined, it’s now time to put them to use. The paper jumbles a bunch of disparate pieces together, but I’m going to split them up for my personal understanding. The first thing we’d like to be able to do is to begin traversing a structure, which is to say, to split it into its first <code>joker</code> and the resulting dissection.</p>
<p>We’ll make a helper structure:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Suspension</span> p k c j</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true"></a>  <span class="ot">=</span> <span class="dt">Done</span> (p c)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true"></a>  <span class="op">|</span> <span class="dt">More</span> j (k c j)</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true"></a>  <span class="kw">deriving</span> <span class="dt">Functor</span></span></code></pre></div>
<p>A <code>Suspension p k c j</code> is either a <code>p</code> fully saturated with clowns (that is, we’ve finished traversing it), or a joker and more structure (<code>k c j</code>) to be traversed. <code>k</code> will always be <code>GDissected p</code>, but for technical reasons, we’re going to need to keep it as a second type parameter.</p>
<p>Armed with <code>Suspension</code>, we’re ready to add our first method to <code>GDissectable</code>. <code>gstart</code> takes a fully-saturated <code>p j</code> and gives us back a suspension:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">GDissectable</span> p <span class="kw">where</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true"></a>  <span class="kw">type</span> <span class="dt">GDissected</span><span class="ot"> p ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true"></a><span class="ot">  gstart ::</span> p j <span class="ot">-&gt;</span> <span class="dt">Suspension</span> p (<span class="dt">GDissected</span> p) c j</span></code></pre></div>
<p>These instances are all pretty easy. Given a double natural transformation over <code>Suspension</code>:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true"></a>bihoist</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true"></a><span class="ot">    ::</span> (<span class="kw">forall</span> x<span class="op">.</span> p x <span class="ot">-&gt;</span> p&#39; x)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true"></a>    <span class="ot">-&gt;</span> (<span class="kw">forall</span> a b<span class="op">.</span> k a b <span class="ot">-&gt;</span> k&#39; a b)</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true"></a>    <span class="ot">-&gt;</span> <span class="dt">Suspension</span> p  k  c j</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true"></a>    <span class="ot">-&gt;</span> <span class="dt">Suspension</span> p&#39; k&#39; c j</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true"></a>bihoist _ g (<span class="dt">More</span> j kcj) <span class="ot">=</span> <span class="dt">More</span> j (g kcj)</span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true"></a>bihoist f _ (<span class="dt">Done</span> pc)    <span class="ot">=</span> <span class="dt">Done</span> (f pc)</span></code></pre></div>
<p><a href="https://haskellwingman.dev">Wingman</a> can write <code>U1</code>, <code>K1</code>, <code>Par1</code>, <code>M1</code> and <code>:+:</code> all for us:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true"></a>  gstart _ <span class="ot">=</span> <span class="dt">Done</span> <span class="dt">U1</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true"></a></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true"></a>  gstart (<span class="dt">K1</span> a) <span class="ot">=</span> <span class="dt">Done</span> (<span class="dt">K1</span> a)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true"></a>  gstart (<span class="dt">Par1</span> j) <span class="ot">=</span> <span class="dt">More</span> j (<span class="dt">K2</span> ())</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true"></a></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true"></a>  gstart (<span class="dt">M1</span> fj) <span class="ot">=</span> bihoist <span class="dt">M1</span> <span class="fu">id</span> <span class="op">$</span> gstart fj</span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true"></a></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true"></a>  gstart (<span class="dt">L1</span> fj) <span class="ot">=</span> bihoist <span class="dt">L1</span> <span class="dt">L2</span> <span class="op">$</span> gstart fj</span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true"></a>  gstart (<span class="dt">R1</span> gj) <span class="ot">=</span> bihoist <span class="dt">R1</span> <span class="dt">R2</span> <span class="op">$</span> gstart gj</span></code></pre></div>
<p>For products, <code>gstart</code> attempts to start the first element, and hoists its continuation if it got <code>More</code>. Otherwise, it starts the second element. This is done with a couple of helper functions:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true"></a>mindp</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true"></a><span class="ot">    ::</span> <span class="dt">GDissectable</span> g</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true"></a>    <span class="ot">=&gt;</span> <span class="dt">Suspension</span> f (<span class="dt">GDissected</span> f) c j</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true"></a>    <span class="ot">-&gt;</span> g j</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true"></a>    <span class="ot">-&gt;</span> <span class="dt">Suspension</span> (f <span class="op">:*:</span> g)</span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true"></a>                 (<span class="dt">Sum2</span> (<span class="dt">Product2</span> (<span class="dt">GDissected</span> f) (<span class="dt">Joker</span> g))</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true"></a>                       (<span class="dt">Product2</span> (<span class="dt">Clown</span> f) (<span class="dt">GDissected</span> g)))</span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true"></a>                 c j</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true"></a>mindp (<span class="dt">More</span> j pd) qj <span class="ot">=</span> <span class="dt">More</span> j <span class="op">$</span> <span class="dt">L2</span> <span class="op">$</span> <span class="dt">Product2</span> pd <span class="op">$</span> <span class="dt">Joker</span> qj</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true"></a>mindp (<span class="dt">Done</span> pc) qj <span class="ot">=</span> mindq pc (gstart qj)</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true"></a></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true"></a>mindq</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true"></a><span class="ot">    ::</span> f c</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true"></a>    <span class="ot">-&gt;</span> <span class="dt">Suspension</span> g (<span class="dt">GDissected</span> g) c j</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true"></a>    <span class="ot">-&gt;</span> <span class="dt">Suspension</span> (f <span class="op">:*:</span> g)</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true"></a>                 (<span class="dt">Sum2</span> (<span class="dt">Product2</span> (<span class="dt">GDissected</span> f) (<span class="dt">Joker</span> g))</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true"></a>                       (<span class="dt">Product2</span> (<span class="dt">Clown</span> f) (<span class="dt">GDissected</span> g)))</span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true"></a>                 c j</span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true"></a>mindq pc (<span class="dt">More</span> j qd) <span class="ot">=</span> <span class="dt">More</span> j <span class="op">$</span> <span class="dt">R2</span> <span class="op">$</span> <span class="dt">Product2</span> (<span class="dt">Clown</span> pc) qd</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true"></a>mindq pc (<span class="dt">Done</span> qc) <span class="ot">=</span> <span class="dt">Done</span> (pc <span class="op">:*:</span> qc)</span></code></pre></div>
<p>and then</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true"></a>  gstart (pj <span class="op">:*:</span> qj) <span class="ot">=</span> mindp (gstart <span class="op">@</span>f pj) qj</span></code></pre></div>
<h2 id="making-progress">Making Progress</h2>
<p>Getting started is nice, but it’s only the first step in the process. Once we have a <code>More</code> suspension, how do we move the needle? Enter <code>gproceed</code>, which takes a clown to fill the current hole and a suspension, and gives back a new suspension corresponding to the next joker.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">GDissectable</span> p <span class="kw">where</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true"></a>  <span class="kw">type</span> <span class="dt">GDissected</span><span class="ot"> p ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true"></a><span class="ot">  gstart ::</span> p j <span class="ot">-&gt;</span> <span class="dt">Suspension</span> p (<span class="dt">GDissected</span> p) c j</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true"></a><span class="ot">  gproceed ::</span> c <span class="ot">-&gt;</span> <span class="dt">GDissected</span> p c j <span class="ot">-&gt;</span> <span class="dt">Suspension</span> p (<span class="dt">GDissected</span> p) c j</span></code></pre></div>
<p>By pumping <code>gproceed</code>, we can make our way through a suspension, transforming each joker into a clown. Eventually our suspension will be <code>Done</code>, at which point we’ve traversed the entire data structure.</p>
<p>For the most part, <code>gproceed</code> is also Wingman-easy:</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true"></a>  <span class="co">-- U1</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true"></a>  gproceed _ (<span class="dt">K2</span> v) <span class="ot">=</span> absurd v</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true"></a></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true"></a>  <span class="co">-- K1</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true"></a>  gproceed _ (<span class="dt">K2</span> v) <span class="ot">=</span> absurd v</span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true"></a></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true"></a>  gproceed c _ <span class="ot">=</span> <span class="dt">Done</span> (<span class="dt">Par1</span> c)</span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true"></a></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true"></a>  gproceed fc <span class="ot">=</span> bihoist <span class="dt">M1</span> <span class="fu">id</span> <span class="op">.</span> gproceed fc</span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true"></a></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true"></a>  gproceed c (<span class="dt">L2</span> dis) <span class="ot">=</span> bihoist <span class="dt">L1</span> <span class="dt">L2</span> <span class="op">$</span> gproceed c dis</span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true"></a>  gproceed c (<span class="dt">R2</span> dis) <span class="ot">=</span> bihoist <span class="dt">R1</span> <span class="dt">R2</span> <span class="op">$</span> gproceed c dis</span></code></pre></div>
<p>Products are again a little tricky. If we’re still working on the left half, we want to proceed through it, unless we finish, in which case we want to start on the right half. When the right half finishes, we need to lift that success all the way through the product. Our helper functions <code>mindp</code> and <code>mindq</code> take care of this:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true"></a>  gproceed c (<span class="dt">L2</span> (<span class="dt">Product2</span> pd (<span class="dt">Joker</span> qj))) <span class="ot">=</span> mindp (gproceed <span class="op">@</span>f c pd) qj</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true"></a>  gproceed c (<span class="dt">R2</span> (<span class="dt">Product2</span> (<span class="dt">Clown</span> pc) qd)) <span class="ot">=</span> mindq pc (gproceed <span class="op">@</span>g c qd)</span></code></pre></div>
<h2 id="plugging-holes">Plugging Holes</h2>
<p>McBride points out that if we forget the distinction between jokers and clowns, what we have is a genuine zipper. In that case, we can just plug the existing hole, and give back a fully saturated type. This is witnessed by the final method of <code>GDissectable</code>, <code>gplug</code>:</p>
<div class="sourceCode" id="cb23"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true"></a><span class="kw">class</span> <span class="dt">GDissectable</span> p <span class="kw">where</span></span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true"></a>  <span class="kw">type</span> <span class="dt">GDissected</span><span class="ot"> p ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true"></a><span class="ot">  gstart ::</span> p j <span class="ot">-&gt;</span> <span class="dt">Suspension</span> p (<span class="dt">GDissected</span> p) c j</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true"></a><span class="ot">  gproceed ::</span> c <span class="ot">-&gt;</span> <span class="dt">GDissected</span> p c j <span class="ot">-&gt;</span> <span class="dt">Suspension</span> p (<span class="dt">GDissected</span> p) c j</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true"></a><span class="ot">  gplug ::</span> x <span class="ot">-&gt;</span> <span class="dt">GDissected</span> p x x <span class="ot">-&gt;</span> p x</span></code></pre></div>
<p>Again, things are Wingman-easy. This time, we can even synthesize the product case for free:</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true"></a>  <span class="co">-- U1</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true"></a>  gplug _ (<span class="dt">K2</span> vo) <span class="ot">=</span> absurd vo</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true"></a></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true"></a>  <span class="co">-- K1</span></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true"></a>  gplug _ (<span class="dt">K2</span> vo) <span class="ot">=</span> absurd vo</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true"></a></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true"></a>  gplug x _ <span class="ot">=</span> <span class="dt">Par1</span> x</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true"></a></span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true"></a>  gplug x dis <span class="ot">=</span> <span class="dt">M1</span> <span class="op">$</span> gplug x dis</span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true"></a></span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true"></a>  gplug x (<span class="dt">L2</span> dis) <span class="ot">=</span> <span class="dt">L1</span> (gplug x dis)</span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true"></a>  gplug x (<span class="dt">R2</span> dis) <span class="ot">=</span> <span class="dt">R1</span> (gplug x dis)</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true"></a></span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true"></a>  gplug x (<span class="dt">L2</span> (<span class="dt">Product2</span> f (<span class="dt">Joker</span> g))) <span class="ot">=</span> gplug x f <span class="op">:*:</span> g</span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true"></a>  gplug x (<span class="dt">R2</span> (<span class="dt">Product2</span> (<span class="dt">Clown</span> f) g)) <span class="ot">=</span> f <span class="op">:*:</span> gplug x g</span></code></pre></div>
<p>This sums up <code>GDissectable</code>.</p>
<h2 id="nongeneric-representations">Nongeneric Representations</h2>
<p><code>GDissectable</code> is great and all, but it would be nice to not need to deal with generic representations. This bit isn’t in the paper, but we can lift everything back into the land of real types by making a copy of <code>GDissectable</code>:</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true"></a><span class="kw">class</span> (<span class="dt">Functor</span> p, <span class="dt">Bifunctor</span> (<span class="dt">Dissected</span> p)) <span class="ot">=&gt;</span> <span class="dt">Dissectable</span> p <span class="kw">where</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true"></a>  <span class="kw">type</span> <span class="dt">Dissected</span><span class="ot"> p ::</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span> <span class="ot">-&gt;</span> <span class="dt">Type</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true"></a><span class="ot">  start ::</span> p j <span class="ot">-&gt;</span> <span class="dt">Suspension</span> p (<span class="dt">Dissected</span> p) c j</span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true"></a><span class="ot">  proceed ::</span> c <span class="ot">-&gt;</span> <span class="dt">Dissected</span> p c j <span class="ot">-&gt;</span> <span class="dt">Suspension</span> p (<span class="dt">Dissected</span> p) c j</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true"></a><span class="ot">  plug ::</span> x <span class="ot">-&gt;</span> <span class="dt">Dissected</span> p x x <span class="ot">-&gt;</span> p x</span></code></pre></div>
<p>and then a little machinery to do <code>-XDerivingVia</code>:</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">Generically</span> p a <span class="ot">=</span> <span class="dt">Generically</span> {<span class="ot"> unGenerically ::</span> p a }</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true"></a>  <span class="kw">deriving</span> <span class="dt">Functor</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true"></a><span class="kw">instance</span> ( <span class="dt">Generic1</span> p</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true"></a>         , <span class="dt">Functor</span> p</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true"></a>         , <span class="dt">Bifunctor</span> (<span class="dt">GDissected</span> (<span class="dt">Rep1</span> p))</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true"></a>         , <span class="dt">GDissectable</span> (<span class="dt">Rep1</span> p)</span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true"></a>         )</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true"></a>    <span class="ot">=&gt;</span> <span class="dt">Dissectable</span> (<span class="dt">Generically</span> p) <span class="kw">where</span></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true"></a>  <span class="kw">type</span> <span class="dt">Dissected</span> (<span class="dt">Generically</span> p) <span class="ot">=</span> <span class="dt">GDissected</span> (<span class="dt">Rep1</span> p)</span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true"></a>  start (<span class="dt">Generically</span> pj) <span class="ot">=</span></span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true"></a>    bihoist (<span class="dt">Generically</span> <span class="op">.</span> to1) <span class="fu">id</span> <span class="op">$</span> gstart <span class="op">$</span> from1 pj</span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true"></a>  proceed x <span class="ot">=</span> bihoist (<span class="dt">Generically</span> <span class="op">.</span> to1) <span class="fu">id</span> <span class="op">.</span> gproceed x</span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true"></a>  plug x <span class="ot">=</span> <span class="dt">Generically</span> <span class="op">.</span> to1 <span class="op">.</span> gplug x</span></code></pre></div>
<p>With this out of the way, we can now get <code>Dissectable</code> for free on <code>ExprF</code> from above:</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">ExprF</span> a <span class="ot">=</span> <span class="dt">ValF</span> <span class="dt">Int</span> <span class="op">|</span> <span class="dt">AddF</span> a a</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true"></a>  <span class="kw">deriving</span> stock (<span class="dt">Functor</span>, <span class="dt">Generic</span>, <span class="dt">Generic1</span>, <span class="dt">Show</span>)</span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true"></a>  <span class="kw">deriving</span> <span class="dt">Dissectable</span> via (<span class="dt">Generically</span> <span class="dt">ExprF</span>)</span></code></pre></div>
<h2 id="dissectable-fmap-sequence-and-catamorphisms">Dissectable Fmap, Sequence and Catamorphisms</h2>
<p>Given a <code>Dissectable</code> constraint, we can write a version of <code>fmap</code> that explicitly walks the traversal, transforming each element as it goes. Of course, this is silly, since we already have <code>Functor</code> for any <code>Dissectable</code>, but it’s a nice little sanity check:</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true"></a><span class="ot">tmap ::</span> <span class="kw">forall</span> p a b<span class="op">.</span> <span class="dt">Dissectable</span> p <span class="ot">=&gt;</span> (a <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> p a <span class="ot">-&gt;</span> p b</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true"></a>tmap fab <span class="ot">=</span> pump <span class="op">.</span> start</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true"></a><span class="ot">    pump ::</span> <span class="dt">Suspension</span> p (<span class="dt">Dissected</span> p) b a <span class="ot">-&gt;</span> p b</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true"></a>    pump (<span class="dt">More</span> a dis) <span class="ot">=</span> pump <span class="op">$</span> proceed (fab a) dis</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true"></a>    pump (<span class="dt">Done</span> j) <span class="ot">=</span> j</span></code></pre></div>
<p>We start the dissection, and then pump its suspension until we’re done, applying <code>fab</code> as we go.</p>
<p>Perhaps more interestingly, we can <em>almost</em> get <code>Traversable</code> with this machinery:</p>
<div class="sourceCode" id="cb29"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true"></a><span class="ot">tsequence ::</span> <span class="kw">forall</span> p f a<span class="op">.</span> (<span class="dt">Dissectable</span> p, <span class="dt">Monad</span> f) <span class="ot">=&gt;</span> p (f a) <span class="ot">-&gt;</span> f (p a)</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true"></a>tsequence <span class="ot">=</span> pump <span class="op">.</span> start</span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true"></a><span class="ot">    pump ::</span> <span class="dt">Suspension</span> p (<span class="dt">Dissected</span> p) a (f a) <span class="ot">-&gt;</span> f (p a)</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true"></a>    pump (<span class="dt">More</span> fa dis) <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb29-6"><a href="#cb29-6" aria-hidden="true"></a>      a <span class="ot">&lt;-</span> fa</span>
<span id="cb29-7"><a href="#cb29-7" aria-hidden="true"></a>      pump <span class="op">$</span> proceed a dis</span>
<span id="cb29-8"><a href="#cb29-8" aria-hidden="true"></a>    pump (<span class="dt">Done</span> pa) <span class="ot">=</span> <span class="fu">pure</span> pa</span></code></pre></div>
<p>It’s not quite <code>Traversable</code>, since it requires a <code>Monad</code> instance instead of merely <code>Applicative</code>. Why’s that? I don’t know, but <a href="https://monoidmusician.github.io/monoidmusician.html">MonoidMusician</a> suggested it’s because applicatives don’t care about the order in which you sequence them, but this <code>Dissectable</code> is very clearly an explicit ordering on the data dependencies in the container. Thanks MonoidMusician!</p>
<p>Finally, we can implement the stack-based, tail-recursive catamorphism that we’ve been promised all along. The idea is simple — we use the <code>Dissected</code> type as our stack, pushing them on as we unfold the functor fixpoint, and resuming them as we finish calls.</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true"></a><span class="ot">tcata ::</span> <span class="kw">forall</span> p v<span class="op">.</span> <span class="dt">Dissectable</span> p <span class="ot">=&gt;</span> (p v <span class="ot">-&gt;</span> v) <span class="ot">-&gt;</span> <span class="dt">Fix</span> p <span class="ot">-&gt;</span> v</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true"></a>tcata f t <span class="ot">=</span> load&#39; t []</span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true"></a>  <span class="kw">where</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true"></a>    load&#39;</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true"></a><span class="ot">        ::</span> <span class="dt">Fix</span> p</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true"></a>        <span class="ot">-&gt;</span> [<span class="dt">Dissected</span> p v (<span class="dt">Fix</span> p)]</span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true"></a>        <span class="ot">-&gt;</span> v</span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true"></a>    load&#39; (<span class="dt">Fix</span> t) stk <span class="ot">=</span> next (start t) stk</span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true"></a></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true"></a>    next</span>
<span id="cb30-11"><a href="#cb30-11" aria-hidden="true"></a><span class="ot">        ::</span> <span class="dt">Suspension</span> p (<span class="dt">Dissected</span> p) v (<span class="dt">Fix</span> p)</span>
<span id="cb30-12"><a href="#cb30-12" aria-hidden="true"></a>        <span class="ot">-&gt;</span> [<span class="dt">Dissected</span> p v (<span class="dt">Fix</span> p)]</span>
<span id="cb30-13"><a href="#cb30-13" aria-hidden="true"></a>        <span class="ot">-&gt;</span> v</span>
<span id="cb30-14"><a href="#cb30-14" aria-hidden="true"></a>    next (<span class="dt">More</span> p dis) stk <span class="ot">=</span> load&#39; p (dis <span class="op">:</span> stk)</span>
<span id="cb30-15"><a href="#cb30-15" aria-hidden="true"></a>    next (<span class="dt">Done</span> p) stk <span class="ot">=</span> unload&#39; (f p) stk</span>
<span id="cb30-16"><a href="#cb30-16" aria-hidden="true"></a></span>
<span id="cb30-17"><a href="#cb30-17" aria-hidden="true"></a>    unload&#39;</span>
<span id="cb30-18"><a href="#cb30-18" aria-hidden="true"></a><span class="ot">        ::</span> v</span>
<span id="cb30-19"><a href="#cb30-19" aria-hidden="true"></a>        <span class="ot">-&gt;</span> [<span class="dt">Dissected</span> p v (<span class="dt">Fix</span> p)]</span>
<span id="cb30-20"><a href="#cb30-20" aria-hidden="true"></a>        <span class="ot">-&gt;</span> v</span>
<span id="cb30-21"><a href="#cb30-21" aria-hidden="true"></a>    unload&#39; v [] <span class="ot">=</span> v</span>
<span id="cb30-22"><a href="#cb30-22" aria-hidden="true"></a>    unload&#39; v (pd <span class="op">:</span> stk) <span class="ot">=</span> next (proceed v pd) stk</span></code></pre></div>
<p>Compare this with the usual implementation of <code>cata</code>:</p>
<div class="sourceCode" id="cb31"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true"></a><span class="ot">cata ::</span> <span class="dt">Functor</span> f <span class="ot">=&gt;</span> (f a <span class="ot">-&gt;</span> a) <span class="ot">-&gt;</span> <span class="dt">Fix</span> f <span class="ot">-&gt;</span> a</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true"></a>cata f (<span class="dt">Fix</span> fc) <span class="ot">=</span> f <span class="op">$</span> <span class="fu">fmap</span> (cata f) fc</span></code></pre></div>
<p>which just goes absolutely ham, expanding nodes and fmapping over them, destroying any chance at TCO.</p>
<p>The paper also has something to say about free monads, but it wasn’t able to hold my attention. It’s an application of this stuff, though in my opinion the approach is much more interesting than its applications. So we can pretend the paper is done here.</p>
<p>But that’s not all…</p>
<h2 id="functor-composition">Functor Composition</h2>
<p>Although the paper doesn’t present it, there should also be here another instance of <code>GDissectable</code> for functor composition. Based on the composite chain rule, it should be:</p>
<div class="sourceCode" id="cb32"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true"></a><span class="kw">instance</span> (<span class="dt">Dissectable</span> f, <span class="dt">GDissectable</span> g) <span class="ot">=&gt;</span> <span class="dt">GDissectable</span> (f <span class="op">:.:</span> g) <span class="kw">where</span></span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true"></a>  <span class="kw">type</span> <span class="dt">GDissected</span> (f <span class="op">:.:</span> g) <span class="ot">=</span></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true"></a>    <span class="dt">Product2</span> (<span class="dt">Compose2</span> (<span class="dt">Dissected</span> f) g)</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true"></a>             (<span class="dt">GDissected</span> g)</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true"></a></span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true"></a><span class="kw">newtype</span> <span class="dt">Compose2</span> f g c j <span class="ot">=</span> <span class="dt">Compose2</span> (f (g c) (g j))</span></code></pre></div>
<p><code>GDissected</code> is clearly correct by the chain rule, but <code>Compose2</code> isn’t as clear. We stick the clowns in the left side of the composite of <code>f . g</code>, and the jokers on the right.</p>
<p>Intuitively, we’ve done the same trick here as the stack machine example. The first element of the <code>Product2</code> in <code>GDissected</code> keeps track of the context of the <code>f</code> traversal, and the second element is the <code>g</code> traversal we’re working our way through. Whenever the <code>g</code> finishes, we can get a new <code>g</code> by continuing the <code>f</code> traversal!</p>
<p>It’s important to note that I didn’t actually reason this out—I just wrote the chain rule from calculus and fought with everything until it typechecked. Then I rewrote my examples that used <code>:+:</code> and <code>:*:</code> to instead compose over <code>Either</code> and <code>(,)</code>, and amazingly <em>I got the same results!</em> Proof by typechecker!</p>
<p>After a truly devoted amount of time, I managed to work out <code>gstart</code> for composition as well.</p>
<div class="sourceCode" id="cb33"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true"></a>  gstart (<span class="dt">Comp1</span> fg) <span class="ot">=</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true"></a>    <span class="kw">case</span> start <span class="op">@</span>f <span class="op">$</span> fg <span class="kw">of</span></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true"></a>      <span class="dt">More</span> gj gd <span class="ot">-&gt;</span> continue gj gd</span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true"></a>      <span class="dt">Done</span> f <span class="ot">-&gt;</span> <span class="dt">Done</span> <span class="op">$</span> <span class="dt">Comp1</span> f</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true"></a>    <span class="kw">where</span></span>
<span id="cb33-6"><a href="#cb33-6" aria-hidden="true"></a>      continue</span>
<span id="cb33-7"><a href="#cb33-7" aria-hidden="true"></a><span class="ot">          ::</span> g j</span>
<span id="cb33-8"><a href="#cb33-8" aria-hidden="true"></a>          <span class="ot">-&gt;</span> <span class="dt">Dissected</span> f (g c) (g j)</span>
<span id="cb33-9"><a href="#cb33-9" aria-hidden="true"></a>          <span class="ot">-&gt;</span> <span class="dt">Suspension</span></span>
<span id="cb33-10"><a href="#cb33-10" aria-hidden="true"></a>               (f <span class="op">:.:</span> g)</span>
<span id="cb33-11"><a href="#cb33-11" aria-hidden="true"></a>               (<span class="dt">Product2</span> (<span class="dt">Compose2</span> (<span class="dt">Dissected</span> f) g) (<span class="dt">GDissected</span> g))</span>
<span id="cb33-12"><a href="#cb33-12" aria-hidden="true"></a>               c j</span>
<span id="cb33-13"><a href="#cb33-13" aria-hidden="true"></a>      continue gj gd <span class="ot">=</span></span>
<span id="cb33-14"><a href="#cb33-14" aria-hidden="true"></a>        <span class="kw">case</span> gstart gj <span class="kw">of</span></span>
<span id="cb33-15"><a href="#cb33-15" aria-hidden="true"></a>          <span class="dt">More</span> j gd&#39; <span class="ot">-&gt;</span></span>
<span id="cb33-16"><a href="#cb33-16" aria-hidden="true"></a>            <span class="dt">More</span> j <span class="op">$</span> <span class="dt">Product2</span> (<span class="dt">Compose2</span> gd) gd&#39;</span>
<span id="cb33-17"><a href="#cb33-17" aria-hidden="true"></a>          <span class="dt">Done</span> g <span class="ot">-&gt;</span></span>
<span id="cb33-18"><a href="#cb33-18" aria-hidden="true"></a>            <span class="kw">case</span> progress <span class="op">@</span>f g gd <span class="kw">of</span></span>
<span id="cb33-19"><a href="#cb33-19" aria-hidden="true"></a>              <span class="dt">More</span> gj gd <span class="ot">-&gt;</span> continue gj gd</span>
<span id="cb33-20"><a href="#cb33-20" aria-hidden="true"></a>              <span class="dt">Done</span> fg <span class="ot">-&gt;</span> <span class="dt">Done</span> <span class="op">$</span> <span class="dt">Comp1</span> fg</span></code></pre></div>
<p>The idea is that you start <code>f</code>, which gives you a <code>g</code> to start, and you need to keep starting <code>g</code> until you find one that isn’t immediately done.</p>
<p><code>gproceed</code> is similar, except dual. If all goes well, we can just proceed down the <code>g</code> we’re currently working on. The tricky part is now when we finish a <code>g</code> node, we need to keep proceeding down <code>f</code> nodes until we find one that admits a <code>More</code>:</p>
<div class="sourceCode" id="cb34"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true"></a>  gproceed c (<span class="dt">Product2</span> cfg<span class="op">@</span>(<span class="dt">Compose2</span> fg) gd) <span class="ot">=</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true"></a>    <span class="kw">case</span> gproceed <span class="op">@</span>g c gd <span class="kw">of</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true"></a>      <span class="dt">More</span> j gd <span class="ot">-&gt;</span> <span class="dt">More</span> j <span class="op">$</span> <span class="dt">Product2</span> cfg gd</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true"></a>      <span class="dt">Done</span> gc <span class="ot">-&gt;</span> finish gc</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true"></a>    <span class="kw">where</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true"></a>      <span class="co">-- finish</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true"></a>      <span class="co">--     :: g c</span></span>
<span id="cb34-8"><a href="#cb34-8" aria-hidden="true"></a>      <span class="co">--     -&gt; Suspension</span></span>
<span id="cb34-9"><a href="#cb34-9" aria-hidden="true"></a>      <span class="co">--          (f :.: g)</span></span>
<span id="cb34-10"><a href="#cb34-10" aria-hidden="true"></a>      <span class="co">--          (Product2 (Compose2 (Dissected f) g) (GDissected g))</span></span>
<span id="cb34-11"><a href="#cb34-11" aria-hidden="true"></a>      <span class="co">--          c j</span></span>
<span id="cb34-12"><a href="#cb34-12" aria-hidden="true"></a>      finish gc <span class="ot">=</span></span>
<span id="cb34-13"><a href="#cb34-13" aria-hidden="true"></a>        <span class="kw">case</span> proceed <span class="op">@</span>f gc fg <span class="kw">of</span></span>
<span id="cb34-14"><a href="#cb34-14" aria-hidden="true"></a>          <span class="dt">More</span> gj gd <span class="ot">-&gt;</span></span>
<span id="cb34-15"><a href="#cb34-15" aria-hidden="true"></a>            <span class="kw">case</span> gstart gj <span class="kw">of</span></span>
<span id="cb34-16"><a href="#cb34-16" aria-hidden="true"></a>              <span class="dt">More</span> j gd&#39; <span class="ot">-&gt;</span> <span class="dt">More</span> j <span class="op">$</span> <span class="dt">Product2</span> (<span class="dt">Compose2</span> gd) gd&#39;</span>
<span id="cb34-17"><a href="#cb34-17" aria-hidden="true"></a>              <span class="dt">Done</span> gc <span class="ot">-&gt;</span> finish gc</span>
<span id="cb34-18"><a href="#cb34-18" aria-hidden="true"></a>          <span class="dt">Done</span> f <span class="ot">-&gt;</span> <span class="dt">Done</span> <span class="op">$</span> <span class="dt">Comp1</span> f</span></code></pre></div>
<p>I’m particularly proud of this; not only did I get the type for <code>GDissected</code> right on my first try, I was also capable of working through these methods, which probably took upwards of two hours.</p>
<p><code>GHC.Generics</code> isn’t so kind as to just let us test it, however. Due to some quirk of the representation, we need to add an instance for <code>Rec1</code>, which is like <code>K1</code> but for types that use the functor argument. We can give an instance of <code>GDissectable</code> by transferring control back to <em><code>Dissectable</code></em>:</p>
<div class="sourceCode" id="cb35"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true"></a><span class="kw">instance</span> (<span class="dt">Generic1</span> f, <span class="dt">Dissectable</span> f) <span class="ot">=&gt;</span> <span class="dt">GDissectable</span> (<span class="dt">Rec1</span> f) <span class="kw">where</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true"></a>  <span class="kw">type</span> <span class="dt">GDissected</span> (<span class="dt">Rec1</span> f) <span class="ot">=</span> <span class="dt">Dissected</span> f</span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true"></a>  gstart (<span class="dt">Rec1</span> f) <span class="ot">=</span> bihoist <span class="dt">Rec1</span> <span class="fu">id</span> <span class="op">$</span> start f</span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true"></a>  gproceed c f <span class="ot">=</span> bihoist <span class="dt">Rec1</span> <span class="fu">id</span> <span class="op">$</span> proceed c f</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true"></a>  gplug x gd <span class="ot">=</span> <span class="dt">Rec1</span> <span class="op">$</span> plug x gd</span></code></pre></div>
<p>Now, a little work to be able to express <code>AddF</code> as a composition, rather than a product:</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">Pair</span> a <span class="ot">=</span> <span class="dt">Pair</span> a a</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true"></a>  <span class="kw">deriving</span> (<span class="dt">Functor</span>, <span class="dt">Show</span>, <span class="dt">Generic1</span>)</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true"></a>  <span class="kw">deriving</span> <span class="dt">Dissectable</span> via (<span class="dt">Generically</span> <span class="dt">Pair</span>)</span>
<span id="cb36-4"><a href="#cb36-4" aria-hidden="true"></a></span>
<span id="cb36-5"><a href="#cb36-5" aria-hidden="true"></a><span class="kw">deriving</span> via <span class="dt">Generically</span> (<span class="dt">Either</span> a) <span class="kw">instance</span> <span class="dt">Dissectable</span> (<span class="dt">Either</span> a)</span></code></pre></div>
<p>and we can rewrite <code>ExprF</code> as a composition of functors:</p>
<div class="sourceCode" id="cb37"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true"></a><span class="kw">data</span> <span class="dt">ExprF&#39;</span> a <span class="ot">=</span> <span class="dt">ExprF</span> (<span class="dt">Either</span> <span class="dt">Int</span> (<span class="dt">Pair</span> a))</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true"></a>  <span class="kw">deriving</span> stock (<span class="dt">Functor</span>, <span class="dt">Generic</span>, <span class="dt">Generic1</span>, <span class="dt">Show</span>)</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true"></a>  <span class="kw">deriving</span> <span class="dt">Dissectable</span> via (<span class="dt">Generically</span> <span class="dt">ExprF&#39;</span>)</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true"></a></span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true"></a><span class="kw">pattern</span> <span class="dt">ValF&#39;</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ExprF&#39;</span> a</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true"></a><span class="kw">pattern</span> <span class="dt">ValF&#39;</span> a <span class="ot">=</span> <span class="dt">ExprF</span> (<span class="dt">Left</span> a)</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true"></a></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true"></a><span class="kw">pattern</span> <span class="dt">AddF&#39;</span><span class="ot"> ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">ExprF&#39;</span> a</span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true"></a><span class="kw">pattern</span> <span class="dt">AddF&#39;</span> a b <span class="ot">=</span> <span class="dt">ExprF</span> (<span class="dt">Right</span> (<span class="dt">Pair</span> a b))</span></code></pre></div>
<p>Everything typechecks, and <code>tcata</code> gives us the same results for equivalent values over <code>ExprF</code> and <code>ExprF'</code>. As one final sanity check, we can compare the computer dissected types:</p>
<pre><code>*&gt; :kind! Dissected ExprF
Dissected ExprF :: * -&gt; * -&gt; *
= Sum2
    (K2 Void)
    (Sum2
       (Product2
          (K2 ())
          (Joker Par1))
       (Product2
          (Clown Par1)
          (K2 ())))

*&gt; :kind! Dissected ExprF&#39;
Dissected ExprF&#39; :: * -&gt; * -&gt; *
= Product2
    (Compose2 (Sum2 (K2 Void) (K2 ())) (Rec1 Pair))
    (Sum2
       (Product2
          (K2 ())
          (Joker Par1))
       (Product2
          (Clown Par1)
          (K2 ())))</code></pre>
<p>They’re not equal, but are they isomorphic? We should hope so! The first one is <code>Sum2 0 x</code>, which is clearly isomorphic to <code>x</code>. The second is harder:</p>
<p><code>Product (Compose2 (Sum2 (K2 Void) (K2 ())) (Rec1 Pair)) x</code></p>
<p>If that first argument to <code>Product</code> is 1, then these two types are isomorphic. So let’s see:</p>
<div class="sourceCode" id="cb39"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true"></a>    <span class="dt">Compose2</span> (<span class="dt">Sum2</span> (<span class="dt">K2</span> <span class="dt">Void</span>) (<span class="dt">K2</span> ())) (<span class="dt">Rec1</span> <span class="dt">Pair</span>)</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true"></a><span class="ot">=</span> symbolic rewriting</span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true"></a>    <span class="dt">Compose2</span> (<span class="dv">0</span> <span class="op">+</span> <span class="dv">1</span>) (<span class="dt">Rec1</span> <span class="dt">Pair</span>)</span>
<span id="cb39-4"><a href="#cb39-4" aria-hidden="true"></a><span class="ot">=</span> <span class="dv">0</span> is an identity for <span class="op">+</span></span>
<span id="cb39-5"><a href="#cb39-5" aria-hidden="true"></a>    <span class="dt">Compose2</span> <span class="dv">1</span> (<span class="dt">Rec1</span> <span class="dt">Pair</span>)</span>
<span id="cb39-6"><a href="#cb39-6" aria-hidden="true"></a><span class="ot">=</span> definition <span class="kw">of</span> <span class="dt">Compose2</span></span>
<span id="cb39-7"><a href="#cb39-7" aria-hidden="true"></a>    <span class="dt">K2</span> () (<span class="dt">Rec1</span> <span class="dt">Pair</span> c) (<span class="dt">Rec1</span> <span class="dt">Pair</span> j)</span>
<span id="cb39-8"><a href="#cb39-8" aria-hidden="true"></a><span class="ot">=</span> <span class="dt">K2</span> () is still <span class="dv">1</span></span>
<span id="cb39-9"><a href="#cb39-9" aria-hidden="true"></a>    <span class="dv">1</span></span></code></pre></div>
<p>Look at that, baby. Isomorphic types, that compute the same answer.</p>
<p>As usual, today’s code is available on <a href="https://gist.github.com/isovector/8a02f5c21bdb5ff5034b661ef9d28d10">Github</a>.</p>
        ]]>
      </content>
    </entry>
    <entry>
      <title>Automating Wordle</title>
      <id>blog/wordle/index.html</id>
      <link href='blog/wordle/index.html'/>
      <published>2022-01-20T18:02:00Z</published>
      <updated>2022-01-20T18:02:00Z</updated>

      <content type="html">
        <![CDATA[
        <p>It’s been a weird day.</p>
<p>Erin’s family has recently been into a word game called <a href="https://www.powerlanguage.co.uk/wordle/">Wordle</a>. Inevitably it spilled into Erin’s life, and subsequently into mine. The rules are simple: there’s a secret five-letter word, and you need to find it by guessing words. If your word shares a letter in the same place as the secret word, that letter is marked as green. If you have a letter in a different place, but also in the secret word, it’s marked as yellow.</p>
<p>The goal is to find the secret word in six guesses or fewer. Yesterday’s, for example, was “pilot.”</p>
<p>After two days of doing it by hand, like a damn pleb, I decided it would be more fun to try to automate this game. So I spent all day thinking about how to do it, and eventually came up with a nice strategy. This blog post documents it, taking time to explain how it works, and more importantly, why.</p>
<h2 id="measuring-information">Measuring Information</h2>
<p>The trick to Wordle is to extract as much information from your guesses as possible. But what does it mean to “extract” information? Is information something we can put a number on?</p>
<p>Rather surprisingly, the answer is yes.</p>
<p>Let’s illustrate the idea by ignoring Wordle for a moment. Instead, imagine I have a buried treasure, somewhere on this map:</p>
<center>
<img src="/images/wordle/map0.png">
</center>
<p>You don’t know where the treasure is, but you can ask me some yes/no questions, and I promise to answer truthfully. In six questions, can you find the treasure?</p>
<p>The trick here is to be very strategic about how you ask your questions. For example, the first question you ask might be “is the treasure on the left half of the map?”, to which I reply yes. We can now redraw the map, using red to highlight the places the treasure could still be:</p>
<center>
<img src="/images/wordle/map1.png">
</center>
<p>Next you can ask “is the treasure on the bottom half <em>of the remaining red region?</em>” I say no. Thus the treasure is on the top half, and our refined map looks like this:</p>
<center>
<img src="/images/wordle/map2.png">
</center>
<p>“Is the treasure on the right half?” Yes.</p>
<center>
<img src="/images/wordle/map3.png">
</center>
<p>“Top?” No.</p>
<center>
<img src="/images/wordle/map4.png">
</center>
<p>You get the idea. By phrasing subsequent questions like this, each time we cut in half the remaining possible hiding spots for the treasure. When we find the treasure, we’re done.</p>
<p>To quantify the amount of information necessary to find the treasure, we need only count how many questions we asked. If we can go from the full map to finding the treasure in 7 questions, we say we needed <em>7 bits</em> of information to find it.</p>
<p>In general, the information required to solve a problem is the number of times we need to split the space in half in order to find what we were looking for. Information is measured in “bits.”</p>
<h2 id="back-to-wordle">Back To Wordle</h2>
<p>How does any of this apply to Wordle? The first question to ask ourselves is just how much information is required to win the game. But what does that mean? We’re trying to find one particular five-letter word in the entire English language. So, how many five-letter words are there in the English language? Nobody knows for sure, but I wrote a program to look through the dictionary, and it came up with <strong>5150 words.</strong></p>
<p>If we need to find one word in particular out of these 5150, how many times do we need to cut it in half? Let’s do the math:</p>
<pre><code>  5150 / 2
= 2575 / 2
= 1288 / 2
= 644  / 2
= 322  / 2
= 161  / 2
= 81   / 2
= 41   / 2
= 21   / 2
= 11   / 2
= 6    / 2
= 3    / 2
= 2    / 2
= 1</code></pre>
<p>Thirteen cuts! It takes thirteen cuts to trim down the search space of all possible Wordle words down to a single word. Thus, analogously to our hidden treasure, we need thirteen bits of information in order to find the secret word.</p>
<h2 id="discovering-information">Discovering Information</h2>
<p>Knowing the amount of information necessary to solve Wordle is one thing, but where does that information actually come from? Recall, the rules of the game <em>don’t even let us</em> ask yes or no questions; all we’re allowed to do is guess a five-letter word.</p>
<p>How can we turn a five-letter word into a yes/no question? Much like with the buried treasure, it helps to have a lay of the land. Imagine that by some chance, exactly half the words in the dictionary had an <code>e</code> in them, and the other half had no <code>e</code>. Then, by guessing a word that contains an <code>e</code>, we could narrow down the possible words by half depending on whether or not we got a yellow result from Wordle.</p>
<p>Imagine by another coincidence that exactly half the words in the dictionary had an <code>s</code> in them, and the other half didn’t. We could further refine our possibilities by guessing a word that has an <code>s</code> as well as an <code>e</code>.</p>
<p>So that’s the idea. Of course, no letter is going to be in exactly half of the words, but some will be <em>more</em> “exactly half” than others. We can inspect the dictionary, and find the letters which are most “balanced.” Doing that, we get the following:</p>
<pre><code>e: 203
a: 497
r: 641
o: 969
t: 981
l: 1019
i: 1021
s: 1079
n: 1215
u: 1401
c: 1419
y: 1481
h: 1557
d: 1575
p: 1623
g: 1715
m: 1719
b: 1781
f: 1901
k: 1911
w: 1927
v: 2017
x: 2241
z: 2245
q: 2257
j: 2261</code></pre>
<p>The numbers here measure the imbalance of each letter. That is, there are 203 fewer words that contain <code>e</code> than do not. On the other end, there are <code>2261</code> more words that don’t contain <code>j</code> than do. This means that by guessing <code>e</code>, we are going to get a much more even split than by guessing <code>j</code>.</p>
<p>The letters with lower numbers give us more information on average than the letters with big numbers. And remember, information is the name of the game here.</p>
<p>By forming a five-letter word out of the most-balanced letters on this list, we can extract approximately five bits of information from the system. So that means we’d like to come up with a word from the letters <code>earot</code> if at all possible. Unfortunately, there is no such word, so we need to look a little further and also pull in <code>l</code>. Now we can make a word from <code>earotl</code>—<code>later</code>!</p>
<p>Since <code>later</code> is formed from the most balanced letters in the word set, it has the <em>highest expected information.</em> By trying <code>later</code> first, we are statistically most likely to learn more than any other guess.</p>
<p>Let’s see how it does against yesterday’s word <code>pilot</code>. We get:</p>
<p>🟨⬛🟨⬛⬛</p>
<p>No greens, but we know that the secret word (pilot) doesn’t have any <code>a</code>s, <code>e</code>s or <code>r</code>s. Furthermore, we know it does have both a <code>l</code> and a <code>t</code>. Therefore, we can eliminate a huge chunk of our words, for example:</p>
<ul>
<li><code>titan</code> because the secret word has no <code>a</code></li>
<li><code>cupid</code> because it doesn’t have an <code>l</code></li>
</ul>
<p>and, as you can imagine, lots of other words.</p>
<p>In fact, the number of words remaining is 27. They are:</p>
<pre><code>blitz,blunt,built,cloth,clout,filth,flint,flout,glint,
guilt,hotly,light,limit,lofty,lusty,moult,pilot,quilt,
sloth,spilt, split,still,stilt,stool,tulip,unlit,until</code></pre>
<p>We can check how many bits of information we extracted:</p>
<pre><code>log2 (5150 / 27) = 7.58</code></pre>
<p>We managed to extract nearly 8 bits of information from this one guess! That’s significantly better than the 5 we should have gotten “theoretically.” Not bad at all!</p>
<p>Our next guess can be found in the same way. Take the 27 remaining words, and figure out which letters are best balanced among them:</p>
<pre><code>u: 5
i: 7
o: 9
s: 13
h: 17
n: 17
f: 19
p: 19
b: 21
g: 21
y: 21
c: 23
m: 23
q: 25
z: 25
a: 27
d: 27
e: 27
j: 27
k: 27
l: 27
r: 27
t: 27
v: 27
w: 27
x: 27</code></pre>
<p>Notice that several letters have an unbalanced count of 27. This means either all the words have (or do not have) this letter, and thus, these are completely unhelpful letters to guess.</p>
<p>Of our remaining 27, the most balanced word we can make from these letters is <code>until</code>. But notice that <code>until</code> uses both <code>t</code> and <code>l</code>, which we already learned from <code>later</code>!</p>
<p>We can do better by picking a word from the original dictionary which is most balanced according to these numbers. That word is <code>using</code>. Let’s use it for our next guess, which results in:</p>
<p>⬛⬛🟨⬛⬛</p>
<p>We’re left with only four words:</p>
<pre><code>blitz,filth,limit,pilot</code></pre>
<p>Rinse and repeat, by finding the most balanced letters in the remaining possibilities, and then finding the best word in the dictionary made out of those letters. The next guess is <code>morph</code>:</p>
<p>⬛🟨⬛🟨⬛</p>
<p>Which eliminates all words except for <code>pilot</code>. Nice.</p>
<p>With that, we’ve successfully automated away playing a fun game. Yay? This strategy works for any word, and hones in on it extremely quickly.</p>
<p>All the code can be found on <a href="https://gist.github.com/isovector/00c7974588e5e1dfeb94f2ea7a7ef675">Github.</a></p>
        ]]>
      </content>
    </entry>
    <entry>
      <title>Review: Shall We Vote on Values, But Bet on Beliefs?</title>
      <id>blog/review-futarchy/index.html</id>
      <link href='blog/review-futarchy/index.html'/>
      <published>2022-01-14T15:55:00Z</published>
      <updated>2022-01-14T15:55:00Z</updated>

      <content type="html">
        <![CDATA[
        <p>Another week, another paper review. This week we’re looking at Robin Hanson’s <a href="">“Shall We Vote on Values, But Bet on Beliefs?”</a> (SWVVBBB). In SWVVBBB, Hanson proposes a new form of government he calls “futuarchy,” which injects prediction markets into democratic government.</p>
<p>The preamble starts like this:</p>
<ol type="1">
<li>Democracies fail by not aggregating information</li>
<li>Prediction markets are really good at aggregating information</li>
<li>We can postdict which nations did better than others.</li>
</ol>
<p>These three assumptions seem relatively self-evident, though perhaps the first is the least obvious. In support of this assumption, Hanson presents some evidence:</p>
<ol type="1">
<li>Most people vote the same way they’ve always voted.</li>
<li>Most people don’t know what the government is doing.</li>
<li>Most people don’t know which platforms parties stand for.</li>
<li>It’s hard for governments to disseminate information.</li>
<li>The populace often has different ideas about what government should do than what experts say it should do.</li>
<li>At large, the populace believes in a bunch of rather crazy things (eg. 85% of Americans believe Jesus was born to a virgin, and 52% believe astrology has some scientific proof.)</li>
<li>It seems untenable that bad policy decisions would be adopted if they were known to be bad policy decisions.</li>
</ol>
<p>The first three points are pretty easy to believe as well. The fourth is also tenable; the government relies on mainstream media to get messages out, where it can be editorialized before being published. Points five and six taken together suggest that the people are often <em>wrong</em> about what constitutes good policy.</p>
<p>Hanson presents sources for these claims, but I don’t have any issues taking them on faith — this isn’t the crux of the paper. It’s safe to say that failure to aggregate information is a serious problem in democracies.</p>
<p>Why does this matter? Because democracy gives us one vote, with which not only do we need to vote on our values, but also on how we’d like the government to bring about those values. For example, political parties’ platforms involve both <em>values</em> (“we care about healthcare, equality, housing, etc.”), and <em>strategy</em> (“we will build 1,000,000 new houses and hire 50,000 new nurses.”)</p>
<p>Personally, I support Canada’s left-most party’s values, but I don’t think they’d be very capable if they actually got into power. This tension leads me away from voting for them, in an attempt to find a better mix of <em>competent</em> and <em>represents what I care about.</em></p>
<p>The question that SWVVBBB answers is “how can we separate voting for values from voting for execution of those values.” And as the title suggests, the trick is to do it by putting our money where our mouths are.</p>
<h2 id="betting-on-beliefs">Betting on Beliefs</h2>
<p>The main contribution of SWVVBBB in my opinion is its clever mechanism design to pull <em>probabilities</em> out of <em>prices.</em> This will take some explanation.</p>
<p>At a high level, the idea is we should vote for a party based only on our values. The winning party is responsible for choosing an explicit mathematical function that represents how well the country is doing on its values. For example, this function might be “GDP”, or “percent of the population employed,” or “global happiness ranking,” or what have you. Probably, it will be some combination of these things.</p>
<p>The government’s only job is to define what success looks like, and how we’re going to measure it. That’s all the government does. They don’t get to raise taxes, or allocate spending, or appoint judges, or anything like that. They are responsible only to pick the utility function, and to create any agencies that might be required to measure it.</p>
<p>Here’s where it gets interesting.</p>
<p>We now put a prediction market in place. For a fee, anybody can propose any intervention on the way the country is run. Collectively, people buy and sell bonds corresponding to whether they think the proposal will help maximize the government’s value function. By looking at the market price of the bonds, we can get a good sense of whether or not the market thinks the proposal is a good idea. If it is, the proposal immediately gets turned into law.</p>
<p>The details on how to actually go about building this market are a good chunk of the paper, which we will get to in the next section. For now, let’s continue thinking about the high-level idea.</p>
<p>By connecting the law to a market, we immediately get a few benefits. The first is that we now incentivize people to have true beliefs about governance. If my ideas about how the country should be run are in fact good, I can make money off of that skill. Furthermore, it incentivizes transparency. If people can make lots of money off of this market, you can bet they’ll watch it extremely closely.</p>
<p>Perhaps best of all, it pushes stupid people out of the market. If you are consistently <em>wrong</em> about what constitutes good governance, you will quickly price yourself out of the market — similar to people who go broke trying to play the stock market on the advice of their uncle.</p>
<p>To be clear, this doesn’t disenfranchise people. They still get to vote on the government. But it requires questions of policy to be answered by putting your money where your mouth is. Thus, under this scheme, it becomes prohibitively expensive to have stupid beliefs strongly held.</p>
<h2 id="mechanism-design">Mechanism Design</h2>
<p>So, that’s the high level idea. How do we actually go about implementing it?</p>
<h3 id="discovering-probability">Discovering Probability</h3>
<p>Imagine a particular question of fact, that can be definitely observed in the future. For example, maybe we want to determine whether or not it will be raining next Friday at 10am in the park beside my house. The more specific the question, the better.</p>
<p>The bank can offer a pair of assets:</p>
<ol type="1">
<li>Pays \$1 if it is raining on Friday at 10am.</li>
<li>Pays \$1 if it is not raining on Friday at 10am.</li>
</ol>
<p>and the bank is happy to sell these assets for \$1, because exactly one of them will actually pay off. In the meantime, the bank can collect interest for free.</p>
<p>Suppose Market-Making Marty buys 10,000 of these pairs from the bank. Marty can now sell the assets individually, for example, he might sell some not raining assets to Dusty, and some raining assets to Misty. Initially, he might price both assets at \$0.60.</p>
<p>By selling both sides of the pair at \$0.60, Marty safely makes \$2,000 dollars off of his \$10,000 investment. It’s safe because he no longer holds any assets except for cold hard cash.</p>
<p>Dusty figures that it’s sunny more than 60% of the time, so paying \$0.60 for an asset that pays \$1.00 is a good deal. If he estimates the likelihood of it being sunny on Friday at 80%, then he expects an 80% chance of making \$10,000, and a 20% chance of making \$0. Adding these together, he computes his expected value at <span class="math inline">\(0.8 * 10000 + 0.2 * 0 = 8000\)</span>, which is \$2,000 more in expectation than the cost of buying all the assets at \$6,000.</p>
<p>Misty does some chain of reasoning that makes her believe that her money is also well spent.</p>
<p>Summer has been thinking hard, and is pretty sure the chance of rain on Friday is actually closer to 5%. So she approaches Dusty, and offers to buy some of his no-rain assets for \$0.90. Dusty thinks this is too confident, so he happily unloads his options to Summer, since again he expects to be making money on this trade.</p>
<p>When everything settles, no-rain assets are trading at a market price of \$0.83, while rain assets are at \$0.17 (in the limit, these must add up to \$1.00, or else you can make money by holding both sides.)</p>
<p>Patty, who was thinking about having a picnic in the park on Friday, looks at the asset prices, and decides it’s not going to rain, since no-rain is trading above rain.</p>
<p>Thus, Patty has made a decision about the future, based on information aggregated from Dusty, Misty, Summer, and whoever else might have been in on the market.</p>
<p>Friday comes along, and it doesn’t rain. Patty is happy, as is everyone holding no-rain assets, since they all made money.</p>
<h3 id="discovering-expected-value">Discovering Expected Value</h3>
<p>We can play the same game to extract information about expected values from the market. Suppose we want to guess the price of flour next week. The bank can look at the historical high of flour price, and sell pairs of assets:</p>
<ol type="1">
<li>Pays \$x, where <code>x</code> is the percentage of the cost of flour with respect to its all-time high. For example, if the all-time high was \$40, and the cost of flour next week was \$30, this asset pays \$0.75 (<span class="math inline">\(30/40\)</span>).</li>
<li>Pays \$(1 - x).</li>
</ol>
<p>Again, the bank is happy to make this trade because they are still only paying out \$1, and they still get to make interest on that dollar until the market pays out.</p>
<p>The trading price of these assets now correspond to the market’s opinion of the expected value of the price of flour next week. If \$x assets are trading at \$0.30, we can read the expected value of flour next week to be <span class="math inline">\(0.3 * 40 = 12\)</span>.</p>
<h3 id="conditional-assets">Conditional Assets</h3>
<p>There’s one last trick we can do. We can make conditional assets, that is, assets which only pay out when a certain precondition is met. We can consider the case of whether or not a big law firm BLF wins its case, conditional on whether or not they put Litigious Larry on as the lead prosecutor. In this case, the bank offers quads of assets for \$1:</p>
<ol type="1">
<li>Pays \$1 if BLF wins with Larry</li>
<li>Pays \$1 if BLF wins without Larry</li>
<li>Pays \$1 if BLF loses with Larry</li>
<li>Pays \$1 if BLF loses without Larry</li>
</ol>
<p>Again, only one of these four cases will actually pay out (ignoring the possibility that it doesn’t go to court, but that’s a simplification for the example, not a limitation of the technique.)</p>
<p>Like Patty in the park, BLF can make a decision about the future: whether or not they should put Larry on the case based on whether Win|Larry is trading higher than Win|-Larry.</p>
<p>Furthermore, they can rethink whether or not they want to settle out of court if the BLF loses assets are trading at better than BLF wins.</p>
<h2 id="putting-it-into-practice">Putting It Into Practice</h2>
<p>With the mechanism design under our belt, we can now think about implementing futarchy.</p>
<p>The people vote on the government based on parties’ values. The government puts forward its value function. Now, anyone can pay a transaction fee (perhaps quite high) to propose a policy intervention. The bank can offer a pair of assets:</p>
<ol type="1">
<li>Pays \$x if the intervention is made</li>
<li>Pays \$(1-x) if the intervention is made</li>
</ol>
<p>where x is linear in the observed value function at some point in the future. The idea is to tie the payoff of the asset to how well it helps influence our value function.</p>
<p>For example, maybe the government decides the value function is GDP. Maybe the target GDP in five years is \$30 trillion. Phoebe then proposes building a high-speed train between Toronto and Vancouver. The bank can offer assets as above, where x is the observed percentage of GDP out of \$30 trillion.</p>
<p>After some period of trading, the \$x assets are trading well above \$(1-x). This is interpreted as the market thinking this train would be good for long term GDP. Immediately, the decision to build the train is ensconced in law.</p>
<p>That doesn’t mean all the details are necessarily worked out. If Phoebe had the whole plan for the train worked out, she could have put those in her proposal. But let’s assume she didn’t. Instead, someone can make a new proposal, that Cost-Cutting Carlos should get put in charge of the project. At the same time, there is a proposal that Safety Susan should be put in charge. Markets pop up for both, and whichever is trading higher gets the bid (unless neither is trading well!)</p>
<p>We can follow this process ad infinitum, to work out more and more particulars. If, at any time, someone thinks the train is actually a bad idea, they can make a proposal to stop its development. We need not worry about the inefficiency inherent this sort of flip-flopping; the market will necessarily price-in the sunk costs.</p>
        ]]>
      </content>
    </entry>
</feed>

